import { RestService } from '@abp/ng.core';
import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "@abp/ng.core";
export class IdentityUserLookupService {
    constructor(restService) {
        this.restService = restService;
        this.apiName = 'AbpIdentity';
        this.findById = (id) => this.restService.request({
            method: 'GET',
            url: `/api/identity/users/lookup/${id}`,
        }, { apiName: this.apiName });
        this.findByUserName = (userName) => this.restService.request({
            method: 'GET',
            url: `/api/identity/users/lookup/by-username/${userName}`,
        }, { apiName: this.apiName });
        this.getCount = (input) => this.restService.request({
            method: 'GET',
            url: '/api/identity/users/lookup/count',
            params: { filter: input.filter },
        }, { apiName: this.apiName });
        this.search = (input) => this.restService.request({
            method: 'GET',
            url: '/api/identity/users/lookup/search',
            params: { filter: input.filter, sorting: input.sorting, skipCount: input.skipCount, maxResultCount: input.maxResultCount },
        }, { apiName: this.apiName });
    }
}
IdentityUserLookupService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: IdentityUserLookupService, deps: [{ token: i1.RestService }], target: i0.ɵɵFactoryTarget.Injectable });
IdentityUserLookupService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: IdentityUserLookupService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: IdentityUserLookupService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.RestService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWRlbnRpdHktdXNlci1sb29rdXAuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2lkZW50aXR5L3Byb3h5L3NyYy9saWIvcHJveHkvaWRlbnRpdHkvaWRlbnRpdHktdXNlci1sb29rdXAuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRTNDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7OztBQU0zQyxNQUFNLE9BQU8seUJBQXlCO0lBaUNwQyxZQUFvQixXQUF3QjtRQUF4QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTtRQWhDNUMsWUFBTyxHQUFHLGFBQWEsQ0FBQztRQUV4QixhQUFRLEdBQUcsQ0FBQyxFQUFVLEVBQUUsRUFBRSxDQUN4QixJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBZ0I7WUFDdEMsTUFBTSxFQUFFLEtBQUs7WUFDYixHQUFHLEVBQUUsOEJBQThCLEVBQUUsRUFBRTtTQUN4QyxFQUNELEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBRTdCLG1CQUFjLEdBQUcsQ0FBQyxRQUFnQixFQUFFLEVBQUUsQ0FDcEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQWdCO1lBQ3RDLE1BQU0sRUFBRSxLQUFLO1lBQ2IsR0FBRyxFQUFFLDBDQUEwQyxRQUFRLEVBQUU7U0FDMUQsRUFDRCxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUU3QixhQUFRLEdBQUcsQ0FBQyxLQUE4QixFQUFFLEVBQUUsQ0FDNUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQWM7WUFDcEMsTUFBTSxFQUFFLEtBQUs7WUFDYixHQUFHLEVBQUUsa0NBQWtDO1lBQ3ZDLE1BQU0sRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLENBQUMsTUFBTSxFQUFFO1NBQ2pDLEVBQ0QsRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFFN0IsV0FBTSxHQUFHLENBQUMsS0FBK0IsRUFBRSxFQUFFLENBQzNDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUErQjtZQUNyRCxNQUFNLEVBQUUsS0FBSztZQUNiLEdBQUcsRUFBRSxtQ0FBbUM7WUFDeEMsTUFBTSxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxTQUFTLEVBQUUsY0FBYyxFQUFFLEtBQUssQ0FBQyxjQUFjLEVBQUU7U0FDM0gsRUFDRCxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztJQUVrQixDQUFDOztzSEFqQ3JDLHlCQUF5QjswSEFBekIseUJBQXlCLGNBRnhCLE1BQU07MkZBRVAseUJBQXlCO2tCQUhyQyxVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgVXNlckxvb2t1cENvdW50SW5wdXREdG8sIFVzZXJMb29rdXBTZWFyY2hJbnB1dER0byB9IGZyb20gJy4vbW9kZWxzJztcclxuaW1wb3J0IHsgUmVzdFNlcnZpY2UgfSBmcm9tICdAYWJwL25nLmNvcmUnO1xyXG5pbXBvcnQgdHlwZSB7IExpc3RSZXN1bHREdG8gfSBmcm9tICdAYWJwL25nLmNvcmUnO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB0eXBlIHsgVXNlckRhdGEgfSBmcm9tICcuLi91c2Vycy9tb2RlbHMnO1xyXG5cclxuQEluamVjdGFibGUoe1xyXG4gIHByb3ZpZGVkSW46ICdyb290JyxcclxufSlcclxuZXhwb3J0IGNsYXNzIElkZW50aXR5VXNlckxvb2t1cFNlcnZpY2Uge1xyXG4gIGFwaU5hbWUgPSAnQWJwSWRlbnRpdHknO1xyXG5cclxuICBmaW5kQnlJZCA9IChpZDogc3RyaW5nKSA9PlxyXG4gICAgdGhpcy5yZXN0U2VydmljZS5yZXF1ZXN0PGFueSwgVXNlckRhdGE+KHtcclxuICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgdXJsOiBgL2FwaS9pZGVudGl0eS91c2Vycy9sb29rdXAvJHtpZH1gLFxyXG4gICAgfSxcclxuICAgIHsgYXBpTmFtZTogdGhpcy5hcGlOYW1lIH0pO1xyXG5cclxuICBmaW5kQnlVc2VyTmFtZSA9ICh1c2VyTmFtZTogc3RyaW5nKSA9PlxyXG4gICAgdGhpcy5yZXN0U2VydmljZS5yZXF1ZXN0PGFueSwgVXNlckRhdGE+KHtcclxuICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgdXJsOiBgL2FwaS9pZGVudGl0eS91c2Vycy9sb29rdXAvYnktdXNlcm5hbWUvJHt1c2VyTmFtZX1gLFxyXG4gICAgfSxcclxuICAgIHsgYXBpTmFtZTogdGhpcy5hcGlOYW1lIH0pO1xyXG5cclxuICBnZXRDb3VudCA9IChpbnB1dDogVXNlckxvb2t1cENvdW50SW5wdXREdG8pID0+XHJcbiAgICB0aGlzLnJlc3RTZXJ2aWNlLnJlcXVlc3Q8YW55LCBudW1iZXI+KHtcclxuICAgICAgbWV0aG9kOiAnR0VUJyxcclxuICAgICAgdXJsOiAnL2FwaS9pZGVudGl0eS91c2Vycy9sb29rdXAvY291bnQnLFxyXG4gICAgICBwYXJhbXM6IHsgZmlsdGVyOiBpbnB1dC5maWx0ZXIgfSxcclxuICAgIH0sXHJcbiAgICB7IGFwaU5hbWU6IHRoaXMuYXBpTmFtZSB9KTtcclxuXHJcbiAgc2VhcmNoID0gKGlucHV0OiBVc2VyTG9va3VwU2VhcmNoSW5wdXREdG8pID0+XHJcbiAgICB0aGlzLnJlc3RTZXJ2aWNlLnJlcXVlc3Q8YW55LCBMaXN0UmVzdWx0RHRvPFVzZXJEYXRhPj4oe1xyXG4gICAgICBtZXRob2Q6ICdHRVQnLFxyXG4gICAgICB1cmw6ICcvYXBpL2lkZW50aXR5L3VzZXJzL2xvb2t1cC9zZWFyY2gnLFxyXG4gICAgICBwYXJhbXM6IHsgZmlsdGVyOiBpbnB1dC5maWx0ZXIsIHNvcnRpbmc6IGlucHV0LnNvcnRpbmcsIHNraXBDb3VudDogaW5wdXQuc2tpcENvdW50LCBtYXhSZXN1bHRDb3VudDogaW5wdXQubWF4UmVzdWx0Q291bnQgfSxcclxuICAgIH0sXHJcbiAgICB7IGFwaU5hbWU6IHRoaXMuYXBpTmFtZSB9KTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZXN0U2VydmljZTogUmVzdFNlcnZpY2UpIHt9XHJcbn1cclxuIl19