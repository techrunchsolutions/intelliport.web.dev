import { ConfigStateService, getShortDateFormat, getShortDateShortTimeFormat, getShortTimeFormat, ListService, PermissionService, } from '@abp/ng.core';
import { formatDate } from '@angular/common';
import { ChangeDetectionStrategy, Component, Inject, Injector, Input, LOCALE_ID, TemplateRef, } from '@angular/core';
import { map } from 'rxjs/operators';
import { ExtensionsService } from '../../services/extensions.service';
import { ENTITY_PROP_TYPE_CLASSES, EXTENSIONS_IDENTIFIER, PROP_DATA_STREAM, } from '../../tokens/extensions.token';
import * as i0 from "@angular/core";
import * as i1 from "@abp/ng.core";
import * as i2 from "@swimlane/ngx-datatable";
import * as i3 from "../grid-actions/grid-actions.component";
import * as i4 from "@abp/ng.theme.shared";
import * as i5 from "@angular/common";
const DEFAULT_ACTIONS_COLUMN_WIDTH = 150;
export class ExtensibleTableComponent {
    constructor(locale, config, injector) {
        this.locale = locale;
        this.config = config;
        this.injector = injector;
        this.trackByFn = (_, item) => item.name;
        this.entityPropTypeClasses = injector.get(ENTITY_PROP_TYPE_CLASSES);
        this.getInjected = injector.get.bind(injector);
        const extensions = injector.get(ExtensionsService);
        const name = injector.get(EXTENSIONS_IDENTIFIER);
        this.propList = extensions.entityProps.get(name).props;
        this.actionList = extensions['entityActions'].get(name)
            .actions;
        const permissionService = injector.get(PermissionService);
        this.hasAtLeastOnePermittedAction =
            permissionService.filterItemsByPolicy(this.actionList.toArray().map(action => ({ requiredPolicy: action.permission }))).length > 0;
        this.setColumnWidths(DEFAULT_ACTIONS_COLUMN_WIDTH);
    }
    set actionsText(value) {
        this._actionsText = value;
    }
    get actionsText() {
        return this._actionsText ?? (this.actionList.length > 1 ? 'AbpUi::Actions' : '');
    }
    set actionsColumnWidth(width) {
        this.setColumnWidths(width ? Number(width) : undefined);
    }
    setColumnWidths(actionsColumn) {
        const widths = [actionsColumn];
        this.propList.forEach(({ value: prop }) => {
            widths.push(prop.columnWidth);
        });
        this.columnWidths = widths;
    }
    getDate(value, format) {
        return value ? formatDate(value, format, this.locale) : '';
    }
    getIcon(value) {
        return value
            ? '<div class="text-success"><i class="fa fa-check"></i></div>'
            : '<div class="text-danger"><i class="fa fa-times"></i></div>';
    }
    getEnum(rowValue, list) {
        if (!list)
            return rowValue;
        const { key } = list.find(({ value }) => value === rowValue);
        return key;
    }
    getContent(prop, data) {
        return prop.valueResolver(data).pipe(map(value => {
            switch (prop.type) {
                case "boolean" /* Boolean */:
                    return this.getIcon(value);
                case "date" /* Date */:
                    return this.getDate(value, getShortDateFormat(this.config));
                case "time" /* Time */:
                    return this.getDate(value, getShortTimeFormat(this.config));
                case "datetime" /* DateTime */:
                    return this.getDate(value, getShortDateShortTimeFormat(this.config));
                case "enum" /* Enum */:
                    return this.getEnum(value, prop.enumList);
                default:
                    return value;
                // More types can be handled in the future
            }
        }));
    }
    ngOnChanges({ data }) {
        if (!data?.currentValue)
            return;
        this.data = data.currentValue.map((record, index) => {
            this.propList.forEach(prop => {
                const propData = { getInjected: this.getInjected, record, index };
                const value = this.getContent(prop.value, propData);
                const propKey = `_${prop.value.name}`;
                record[propKey] = {
                    visible: prop.value.visible(propData),
                    value,
                };
                if (prop.value.component) {
                    const injector = Injector.create([
                        {
                            provide: PROP_DATA_STREAM,
                            useValue: value,
                        },
                    ], this.injector);
                    record[propKey].injector = injector;
                    record[propKey].component = prop.value.component;
                }
            });
            return record;
        });
    }
}
ExtensibleTableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ExtensibleTableComponent, deps: [{ token: LOCALE_ID }, { token: i1.ConfigStateService }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
ExtensibleTableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.6", type: ExtensibleTableComponent, selector: "abp-extensible-table", inputs: { actionsText: "actionsText", data: "data", list: "list", recordsTotal: "recordsTotal", actionsColumnWidth: "actionsColumnWidth", actionsTemplate: "actionsTemplate" }, exportAs: ["abpExtensibleTable"], usesOnChanges: true, ngImport: i0, template: "<ngx-datatable default [rows]=\"data\" [count]=\"recordsTotal\" [list]=\"list\">\r\n  <ngx-datatable-column\r\n    *ngIf=\"actionsTemplate || (actionList.length && hasAtLeastOnePermittedAction)\"\r\n    [name]=\"actionsText | abpLocalization\"\r\n    [maxWidth]=\"columnWidths[0]\"\r\n    [width]=\"columnWidths[0]\"\r\n    [sortable]=\"false\"\r\n  >\r\n    <ng-template let-row=\"row\" let-i=\"rowIndex\" ngx-datatable-cell-template>\r\n      <ng-container\r\n        *ngTemplateOutlet=\"actionsTemplate || gridActions; context: { $implicit: row, index: i }\"\r\n      ></ng-container>\r\n      <ng-template #gridActions>\r\n        <abp-grid-actions [index]=\"i\" [record]=\"row\" text=\"AbpUi::Actions\"></abp-grid-actions>\r\n      </ng-template>\r\n    </ng-template>\r\n  </ngx-datatable-column>\r\n\r\n  <ng-container *ngFor=\"let prop of propList; let i = index; trackBy: trackByFn\">\r\n    <ngx-datatable-column\r\n      [width]=\"columnWidths[i + 1] || 200\"\r\n      [name]=\"prop.displayName | abpLocalization\"\r\n      [prop]=\"prop.name\"\r\n      [sortable]=\"prop.sortable\"\r\n    >\r\n      <ng-template let-row=\"row\" let-i=\"index\" ngx-datatable-cell-template>\r\n        <ng-container *abpPermission=\"prop.permission; runChangeDetection: false\">\r\n          <ng-container *ngIf=\"row['_' + prop.name]?.visible\">\r\n            <div\r\n              *ngIf=\"!row['_' + prop.name].component; else component\"\r\n              [innerHTML]=\"row['_' + prop.name]?.value | async\"\r\n              (click)=\"\r\n                prop.action && prop.action({ getInjected: getInjected, record: row, index: i })\r\n              \"\r\n              [ngClass]=\"entityPropTypeClasses[prop.type]\"\r\n              [class.pointer]=\"prop.action\"\r\n            ></div>\r\n          </ng-container>\r\n          <ng-template #component>\r\n            <ng-container\r\n              *ngComponentOutlet=\"\r\n                row['_' + prop.name].component;\r\n                injector: row['_' + prop.name].injector\r\n              \"\r\n            ></ng-container>\r\n          </ng-template>\r\n        </ng-container>\r\n      </ng-template>\r\n    </ngx-datatable-column>\r\n  </ng-container>\r\n</ngx-datatable>\r\n", components: [{ type: i2.DatatableComponent, selector: "ngx-datatable", inputs: ["selected", "scrollbarV", "scrollbarH", "rowHeight", "columnMode", "headerHeight", "footerHeight", "externalPaging", "externalSorting", "loadingIndicator", "reorderable", "swapColumns", "sortType", "sorts", "cssClasses", "messages", "groupExpansionDefault", "selectAllRowsOnPage", "virtualization", "summaryRow", "summaryHeight", "summaryPosition", "rowIdentity", "rows", "groupedRows", "groupRowsBy", "columns", "limit", "count", "offset", "targetMarkerTemplate", "selectionType", "rowClass", "selectCheck", "displayCheck", "trackByProp", "treeFromRelation", "treeToRelation"], outputs: ["scroll", "activate", "select", "sort", "page", "reorder", "resize", "tableContextmenu", "treeAction"] }, { type: i3.GridActionsComponent, selector: "abp-grid-actions", inputs: ["icon", "index", "text"], exportAs: ["abpGridActions"] }], directives: [{ type: i4.NgxDatatableDefaultDirective, selector: "ngx-datatable[default]", inputs: ["class"], exportAs: ["ngxDatatableDefault"] }, { type: i4.NgxDatatableListDirective, selector: "ngx-datatable[list]", inputs: ["list"], exportAs: ["ngxDatatableList"] }, { type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.DataTableColumnDirective, selector: "ngx-datatable-column", inputs: ["name", "prop", "frozenLeft", "frozenRight", "flexGrow", "resizeable", "comparator", "pipe", "sortable", "draggable", "canAutoResize", "minWidth", "width", "maxWidth", "checkboxable", "headerCheckboxable", "headerClass", "cellClass", "isTreeColumn", "treeLevelIndent", "summaryFunc", "summaryTemplate", "cellTemplate", "headerTemplate", "treeToggleTemplate"] }, { type: i2.DataTableColumnCellDirective, selector: "[ngx-datatable-cell-template]" }, { type: i5.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i5.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.PermissionDirective, selector: "[abpPermission]", inputs: ["abpPermission", "abpPermissionRunChangeDetection"] }, { type: i5.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i5.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModuleFactory"] }], pipes: { "abpLocalization": i1.LocalizationPipe, "async": i5.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ExtensibleTableComponent, decorators: [{
            type: Component,
            args: [{ exportAs: 'abpExtensibleTable', selector: 'abp-extensible-table', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ngx-datatable default [rows]=\"data\" [count]=\"recordsTotal\" [list]=\"list\">\r\n  <ngx-datatable-column\r\n    *ngIf=\"actionsTemplate || (actionList.length && hasAtLeastOnePermittedAction)\"\r\n    [name]=\"actionsText | abpLocalization\"\r\n    [maxWidth]=\"columnWidths[0]\"\r\n    [width]=\"columnWidths[0]\"\r\n    [sortable]=\"false\"\r\n  >\r\n    <ng-template let-row=\"row\" let-i=\"rowIndex\" ngx-datatable-cell-template>\r\n      <ng-container\r\n        *ngTemplateOutlet=\"actionsTemplate || gridActions; context: { $implicit: row, index: i }\"\r\n      ></ng-container>\r\n      <ng-template #gridActions>\r\n        <abp-grid-actions [index]=\"i\" [record]=\"row\" text=\"AbpUi::Actions\"></abp-grid-actions>\r\n      </ng-template>\r\n    </ng-template>\r\n  </ngx-datatable-column>\r\n\r\n  <ng-container *ngFor=\"let prop of propList; let i = index; trackBy: trackByFn\">\r\n    <ngx-datatable-column\r\n      [width]=\"columnWidths[i + 1] || 200\"\r\n      [name]=\"prop.displayName | abpLocalization\"\r\n      [prop]=\"prop.name\"\r\n      [sortable]=\"prop.sortable\"\r\n    >\r\n      <ng-template let-row=\"row\" let-i=\"index\" ngx-datatable-cell-template>\r\n        <ng-container *abpPermission=\"prop.permission; runChangeDetection: false\">\r\n          <ng-container *ngIf=\"row['_' + prop.name]?.visible\">\r\n            <div\r\n              *ngIf=\"!row['_' + prop.name].component; else component\"\r\n              [innerHTML]=\"row['_' + prop.name]?.value | async\"\r\n              (click)=\"\r\n                prop.action && prop.action({ getInjected: getInjected, record: row, index: i })\r\n              \"\r\n              [ngClass]=\"entityPropTypeClasses[prop.type]\"\r\n              [class.pointer]=\"prop.action\"\r\n            ></div>\r\n          </ng-container>\r\n          <ng-template #component>\r\n            <ng-container\r\n              *ngComponentOutlet=\"\r\n                row['_' + prop.name].component;\r\n                injector: row['_' + prop.name].injector\r\n              \"\r\n            ></ng-container>\r\n          </ng-template>\r\n        </ng-container>\r\n      </ng-template>\r\n    </ngx-datatable-column>\r\n  </ng-container>\r\n</ngx-datatable>\r\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: i1.ConfigStateService }, { type: i0.Injector }]; }, propDecorators: { actionsText: [{
                type: Input
            }], data: [{
                type: Input
            }], list: [{
                type: Input
            }], recordsTotal: [{
                type: Input
            }], actionsColumnWidth: [{
                type: Input
            }], actionsTemplate: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZW5zaWJsZS10YWJsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy90aGVtZS1zaGFyZWQvZXh0ZW5zaW9ucy9zcmMvbGliL2NvbXBvbmVudHMvZXh0ZW5zaWJsZS10YWJsZS9leHRlbnNpYmxlLXRhYmxlLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3RoZW1lLXNoYXJlZC9leHRlbnNpb25zL3NyYy9saWIvY29tcG9uZW50cy9leHRlbnNpYmxlLXRhYmxlL2V4dGVuc2libGUtdGFibGUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLGtCQUFrQixFQUNsQixrQkFBa0IsRUFDbEIsMkJBQTJCLEVBQzNCLGtCQUFrQixFQUNsQixXQUFXLEVBQ1gsaUJBQWlCLEdBQ2xCLE1BQU0sY0FBYyxDQUFDO0FBQ3RCLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUM3QyxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxNQUFNLEVBR04sUUFBUSxFQUNSLEtBQUssRUFDTCxTQUFTLEVBR1QsV0FBVyxHQUdaLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUtyQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUN0RSxPQUFPLEVBQ0wsd0JBQXdCLEVBRXhCLHFCQUFxQixFQUNyQixnQkFBZ0IsR0FDakIsTUFBTSwrQkFBK0IsQ0FBQzs7Ozs7OztBQUV2QyxNQUFNLDRCQUE0QixHQUFHLEdBQUcsQ0FBQztBQVF6QyxNQUFNLE9BQU8sd0JBQXdCO0lBZ0NuQyxZQUM2QixNQUFjLEVBQ2pDLE1BQTBCLEVBQzFCLFFBQWtCO1FBRkMsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNq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OzBCQW1DNUMsTUFBTTsyQkFBQyxTQUFTO29HQTlCZixXQUFXO3NCQURkLEtBQUs7Z0JBUUcsSUFBSTtzQkFBWixLQUFLO2dCQUNHLElBQUk7c0JBQVosS0FBSztnQkFDRyxZQUFZO3NCQUFwQixLQUFLO2dCQUNPLGtCQUFrQjtzQkFBOUIsS0FBSztnQkFHRyxlQUFlO3NCQUF2QixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBBQlAsXHJcbiAgQ29uZmlnU3RhdGVTZXJ2aWNlLFxyXG4gIGdldFNob3J0RGF0ZUZvcm1hdCxcclxuICBnZXRTaG9ydERhdGVTaG9ydFRpbWVGb3JtYXQsXHJcbiAgZ2V0U2hvcnRUaW1lRm9ybWF0LFxyXG4gIExpc3RTZXJ2aWNlLFxyXG4gIFBlcm1pc3Npb25TZXJ2aWNlLFxyXG59IGZyb20gJ0BhYnAvbmcuY29yZSc7XHJcbmltcG9ydCB7IGZvcm1hdERhdGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQge1xyXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gIENvbXBvbmVudCxcclxuICBJbmplY3QsXHJcbiAgSW5qZWN0RmxhZ3MsXHJcbiAgSW5qZWN0aW9uVG9rZW4sXHJcbiAgSW5qZWN0b3IsXHJcbiAgSW5wdXQsXHJcbiAgTE9DQUxFX0lELFxyXG4gIE9uQ2hhbmdlcyxcclxuICBTaW1wbGVDaGFuZ2VzLFxyXG4gIFRlbXBsYXRlUmVmLFxyXG4gIFRyYWNrQnlGdW5jdGlvbixcclxuICBUeXBlLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgZVByb3BUeXBlIH0gZnJvbSAnLi4vLi4vZW51bXMvcHJvcHMuZW51bSc7XHJcbmltcG9ydCB7IEVudGl0eUFjdGlvbkxpc3QgfSBmcm9tICcuLi8uLi9tb2RlbHMvZW50aXR5LWFjdGlvbnMnO1xyXG5pbXBvcnQgeyBFbnRpdHlQcm9wLCBFbnRpdHlQcm9wTGlzdCB9IGZyb20gJy4uLy4uL21vZGVscy9lbnRpdHktcHJvcHMnO1xyXG5pbXBvcnQgeyBQcm9wRGF0YSB9IGZyb20gJy4uLy4uL21vZGVscy9wcm9wcyc7XHJcbmltcG9ydCB7IEV4dGVuc2lvbnNTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZXh0ZW5zaW9ucy5zZXJ2aWNlJztcclxuaW1wb3J0IHtcclxuICBFTlRJVFlfUFJPUF9UWVBFX0NMQVNTRVMsXHJcbiAgRW50aXR5UHJvcFR5cGVDbGFzcyxcclxuICBFWFRFTlNJT05TX0lERU5USUZJRVIsXHJcbiAgUFJPUF9EQVRBX1NUUkVBTSxcclxufSBmcm9tICcuLi8uLi90b2tlbnMvZXh0ZW5zaW9ucy50b2tlbic7XHJcblxyXG5jb25zdCBERUZBVUxUX0FDVElPTlNfQ09MVU1OX1dJRFRIID0gMTUwO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgZXhwb3J0QXM6ICdhYnBFeHRlbnNpYmxlVGFibGUnLFxyXG4gIHNlbGVjdG9yOiAnYWJwLWV4dGVuc2libGUtdGFibGUnLFxyXG4gIHRlbXBsYXRlVXJsOiAnLi9leHRlbnNpYmxlLXRhYmxlLmNvbXBvbmVudC5odG1sJyxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxufSlcclxuZXhwb3J0IGNsYXNzIEV4dGVuc2libGVUYWJsZUNvbXBvbmVudDxSID0gYW55PiBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XHJcbiAgcHJvdGVjdGVkIF9hY3Rpb25zVGV4dDogc3RyaW5nO1xyXG4gIEBJbnB1dCgpXHJcbiAgc2V0IGFjdGlvbnNUZXh0KHZhbHVlOiBzdHJpbmcpIHtcclxuICAgIHRoaXMuX2FjdGlvbnNUZXh0ID0gdmFsdWU7XHJcbiAgfVxyXG4gIGdldCBhY3Rpb25zVGV4dCgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuX2FjdGlvbnNUZXh0ID8/ICh0aGlzLmFjdGlvbkxpc3QubGVuZ3RoID4gMSA/ICdBYnBVaTo6QWN0aW9ucycgOiAnJyk7XHJcbiAgfVxyXG5cclxuICBASW5wdXQoKSBkYXRhOiBSW107XHJcbiAgQElucHV0KCkgbGlzdDogTGlzdFNlcnZpY2U7XHJcbiAgQElucHV0KCkgcmVjb3Jkc1RvdGFsOiBudW1iZXI7XHJcbiAgQElucHV0KCkgc2V0IGFjdGlvbnNDb2x1bW5XaWR0aCh3aWR0aDogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnNldENvbHVtbldpZHRocyh3aWR0aCA/IE51bWJlcih3aWR0aCkgOiB1bmRlZmluZWQpO1xyXG4gIH1cclxuICBASW5wdXQoKSBhY3Rpb25zVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcblxyXG4gIGdldEluamVjdGVkOiA8VD4odG9rZW46IFR5cGU8VD4gfCBJbmplY3Rpb25Ub2tlbjxUPiwgbm90Rm91bmRWYWx1ZT86IFQsIGZsYWdzPzogSW5qZWN0RmxhZ3MpID0+IFQ7XHJcblxyXG4gIGhhc0F0TGVhc3RPbmVQZXJtaXR0ZWRBY3Rpb246IGJvb2xlYW47XHJcblxyXG4gIGVudGl0eVByb3BUeXBlQ2xhc3NlczogRW50aXR5UHJvcFR5cGVDbGFzcztcclxuXHJcbiAgcmVhZG9ubHkgY29sdW1uV2lkdGhzOiBudW1iZXJbXTtcclxuXHJcbiAgcmVhZG9ubHkgcHJvcExpc3Q6IEVudGl0eVByb3BMaXN0PFI+O1xyXG5cclxuICByZWFkb25seSBhY3Rpb25MaXN0OiBFbnRpdHlBY3Rpb25MaXN0PFI+O1xyXG5cclxuICByZWFkb25seSB0cmFja0J5Rm46IFRyYWNrQnlGdW5jdGlvbjxFbnRpdHlQcm9wPFI+PiA9IChfLCBpdGVtKSA9PiBpdGVtLm5hbWU7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQEluamVjdChMT0NBTEVfSUQpIHByaXZhdGUgbG9jYWxlOiBzdHJpbmcsXHJcbiAgICBwcml2YXRlIGNvbmZpZzogQ29uZmlnU3RhdGVTZXJ2aWNlLFxyXG4gICAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IsXHJcbiAgKSB7XHJcbiAgICB0aGlzLmVudGl0eVByb3BUeXBlQ2xhc3NlcyA9IGluamVjdG9yLmdldChFTlRJVFlfUFJPUF9UWVBFX0NMQVNTRVMpO1xyXG4gICAgdGhpcy5nZXRJbmplY3RlZCA9IGluamVjdG9yLmdldC5iaW5kKGluamVjdG9yKTtcclxuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBpbmplY3Rvci5nZXQoRXh0ZW5zaW9uc1NlcnZpY2UpO1xyXG4gICAgY29uc3QgbmFtZSA9IGluamVjdG9yLmdldChFWFRFTlNJT05TX0lERU5USUZJRVIpO1xyXG4gICAgdGhpcy5wcm9wTGlzdCA9IGV4dGVuc2lvbnMuZW50aXR5UHJvcHMuZ2V0KG5hbWUpLnByb3BzO1xyXG4gICAgdGhpcy5hY3Rpb25MaXN0ID0gZXh0ZW5zaW9uc1snZW50aXR5QWN0aW9ucyddLmdldChuYW1lKVxyXG4gICAgICAuYWN0aW9ucyBhcyB1bmtub3duIGFzIEVudGl0eUFjdGlvbkxpc3Q8Uj47XHJcblxyXG4gICAgY29uc3QgcGVybWlzc2lvblNlcnZpY2UgPSBpbmplY3Rvci5nZXQoUGVybWlzc2lvblNlcnZpY2UpO1xyXG4gICAgdGhpcy5oYXNBdExlYXN0T25lUGVybWl0dGVkQWN0aW9uID1cclxuICAgICAgcGVybWlzc2lvblNlcnZpY2UuZmlsdGVySXRlbXNCeVBvbGljeShcclxuICAgICAgICB0aGlzLmFjdGlvbkxpc3QudG9BcnJheSgpLm1hcChhY3Rpb24gPT4gKHsgcmVxdWlyZWRQb2xpY3k6IGFjdGlvbi5wZXJtaXNzaW9uIH0pKSxcclxuICAgICAgKS5sZW5ndGggPiAwO1xyXG4gICAgdGhpcy5zZXRDb2x1bW5XaWR0aHMoREVGQVVMVF9BQ1RJT05TX0NPTFVNTl9XSURUSCk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNldENvbHVtbldpZHRocyhhY3Rpb25zQ29sdW1uOiBudW1iZXIpIHtcclxuICAgIGNvbnN0IHdpZHRocyA9IFthY3Rpb25zQ29sdW1uXTtcclxuICAgIHRoaXMucHJvcExpc3QuZm9yRWFjaCgoeyB2YWx1ZTogcHJvcCB9KSA9PiB7XHJcbiAgICAgIHdpZHRocy5wdXNoKHByb3AuY29sdW1uV2lkdGgpO1xyXG4gICAgfSk7XHJcbiAgICAodGhpcy5jb2x1bW5XaWR0aHMgYXMgYW55KSA9IHdpZHRocztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0RGF0ZSh2YWx1ZTogRGF0ZSwgZm9ybWF0OiBzdHJpbmcpIHtcclxuICAgIHJldHVybiB2YWx1ZSA/IGZvcm1hdERhdGUodmFsdWUsIGZvcm1hdCwgdGhpcy5sb2NhbGUpIDogJyc7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldEljb24odmFsdWU6IGJvb2xlYW4pIHtcclxuICAgIHJldHVybiB2YWx1ZVxyXG4gICAgICA/ICc8ZGl2IGNsYXNzPVwidGV4dC1zdWNjZXNzXCI+PGkgY2xhc3M9XCJmYSBmYS1jaGVja1wiPjwvaT48L2Rpdj4nXHJcbiAgICAgIDogJzxkaXYgY2xhc3M9XCJ0ZXh0LWRhbmdlclwiPjxpIGNsYXNzPVwiZmEgZmEtdGltZXNcIj48L2k+PC9kaXY+JztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0RW51bShyb3dWYWx1ZTogYW55LCBsaXN0OiBBcnJheTxBQlAuT3B0aW9uPGFueT4+KSB7XHJcbiAgICBpZiAoIWxpc3QpIHJldHVybiByb3dWYWx1ZTtcclxuICAgIGNvbnN0IHsga2V5IH0gPSBsaXN0LmZpbmQoKHsgdmFsdWUgfSkgPT4gdmFsdWUgPT09IHJvd1ZhbHVlKTtcclxuICAgIHJldHVybiBrZXk7XHJcbiAgfVxyXG5cclxuICBnZXRDb250ZW50KHByb3A6IEVudGl0eVByb3A8Uj4sIGRhdGE6IFByb3BEYXRhKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcclxuICAgIHJldHVybiBwcm9wLnZhbHVlUmVzb2x2ZXIoZGF0YSkucGlwZShcclxuICAgICAgbWFwKHZhbHVlID0+IHtcclxuICAgICAgICBzd2l0Y2ggKHByb3AudHlwZSkge1xyXG4gICAgICAgICAgY2FzZSBlUHJvcFR5cGUuQm9vbGVhbjpcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWNvbih2YWx1ZSk7XHJcbiAgICAgICAgICBjYXNlIGVQcm9wVHlwZS5EYXRlOlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRlKHZhbHVlLCBnZXRTaG9ydERhdGVGb3JtYXQodGhpcy5jb25maWcpKTtcclxuICAgICAgICAgIGNhc2UgZVByb3BUeXBlLlRpbWU6XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERhdGUodmFsdWUsIGdldFNob3J0VGltZUZvcm1hdCh0aGlzLmNvbmZpZykpO1xyXG4gICAgICAgICAgY2FzZSBlUHJvcFR5cGUuRGF0ZVRpbWU6XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERhdGUodmFsdWUsIGdldFNob3J0RGF0ZVNob3J0VGltZUZvcm1hdCh0aGlzLmNvbmZpZykpO1xyXG4gICAgICAgICAgY2FzZSBlUHJvcFR5cGUuRW51bTpcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW51bSh2YWx1ZSwgcHJvcC5lbnVtTGlzdCk7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAvLyBNb3JlIHR5cGVzIGNhbiBiZSBoYW5kbGVkIGluIHRoZSBmdXR1cmVcclxuICAgICAgICB9XHJcbiAgICAgIH0pLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIG5nT25DaGFuZ2VzKHsgZGF0YSB9OiBTaW1wbGVDaGFuZ2VzKSB7XHJcbiAgICBpZiAoIWRhdGE/LmN1cnJlbnRWYWx1ZSkgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMuZGF0YSA9IGRhdGEuY3VycmVudFZhbHVlLm1hcCgocmVjb3JkLCBpbmRleCkgPT4ge1xyXG4gICAgICB0aGlzLnByb3BMaXN0LmZvckVhY2gocHJvcCA9PiB7XHJcbiAgICAgICAgY29uc3QgcHJvcERhdGEgPSB7IGdldEluamVjdGVkOiB0aGlzLmdldEluamVjdGVkLCByZWNvcmQsIGluZGV4IH0gYXMgYW55O1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRDb250ZW50KHByb3AudmFsdWUsIHByb3BEYXRhKTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvcEtleSA9IGBfJHtwcm9wLnZhbHVlLm5hbWV9YDtcclxuICAgICAgICByZWNvcmRbcHJvcEtleV0gPSB7XHJcbiAgICAgICAgICB2aXNpYmxlOiBwcm9wLnZhbHVlLnZpc2libGUocHJvcERhdGEpLFxyXG4gICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAocHJvcC52YWx1ZS5jb21wb25lbnQpIHtcclxuICAgICAgICAgIGNvbnN0IGluamVjdG9yID0gSW5qZWN0b3IuY3JlYXRlKFxyXG4gICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgcHJvdmlkZTogUFJPUF9EQVRBX1NUUkVBTSxcclxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB0aGlzLmluamVjdG9yLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHJlY29yZFtwcm9wS2V5XS5pbmplY3RvciA9IGluamVjdG9yO1xyXG4gICAgICAgICAgcmVjb3JkW3Byb3BLZXldLmNvbXBvbmVudCA9IHByb3AudmFsdWUuY29tcG9uZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gcmVjb3JkO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbiIsIjxuZ3gtZGF0YXRhYmxlIGRlZmF1bHQgW3Jvd3NdPVwiZGF0YVwiIFtjb3VudF09XCJyZWNvcmRzVG90YWxcIiBbbGlzdF09XCJsaXN0XCI+XHJcbiAgPG5neC1kYXRhdGFibGUtY29sdW1uXHJcbiAgICAqbmdJZj1cImFjdGlvbnNUZW1wbGF0ZSB8fCAoYWN0aW9uTGlzdC5sZW5ndGggJiYgaGFzQXRMZWFzdE9uZVBlcm1pdHRlZEFjdGlvbilcIlxyXG4gICAgW25hbWVdPVwiYWN0aW9uc1RleHQgfCBhYnBMb2NhbGl6YXRpb25cIlxyXG4gICAgW21heFdpZHRoXT1cImNvbHVtbldpZHRoc1swXVwiXHJcbiAgICBbd2lkdGhdPVwiY29sdW1uV2lkdGhzWzBdXCJcclxuICAgIFtzb3J0YWJsZV09XCJmYWxzZVwiXHJcbiAgPlxyXG4gICAgPG5nLXRlbXBsYXRlIGxldC1yb3c9XCJyb3dcIiBsZXQtaT1cInJvd0luZGV4XCIgbmd4LWRhdGF0YWJsZS1jZWxsLXRlbXBsYXRlPlxyXG4gICAgICA8bmctY29udGFpbmVyXHJcbiAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJhY3Rpb25zVGVtcGxhdGUgfHwgZ3JpZEFjdGlvbnM7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiByb3csIGluZGV4OiBpIH1cIlxyXG4gICAgICA+PC9uZy1jb250YWluZXI+XHJcbiAgICAgIDxuZy10ZW1wbGF0ZSAjZ3JpZEFjdGlvbnM+XHJcbiAgICAgICAgPGFicC1ncmlkLWFjdGlvbnMgW2luZGV4XT1cImlcIiBbcmVjb3JkXT1cInJvd1wiIHRleHQ9XCJBYnBVaTo6QWN0aW9uc1wiPjwvYWJwLWdyaWQtYWN0aW9ucz5cclxuICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgIDwvbmctdGVtcGxhdGU+XHJcbiAgPC9uZ3gtZGF0YXRhYmxlLWNvbHVtbj5cclxuXHJcbiAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgcHJvcCBvZiBwcm9wTGlzdDsgbGV0IGkgPSBpbmRleDsgdHJhY2tCeTogdHJhY2tCeUZuXCI+XHJcbiAgICA8bmd4LWRhdGF0YWJsZS1jb2x1bW5cclxuICAgICAgW3dpZHRoXT1cImNvbHVtbldpZHRoc1tpICsgMV0gfHwgMjAwXCJcclxuICAgICAgW25hbWVdPVwicHJvcC5kaXNwbGF5TmFtZSB8IGFicExvY2FsaXphdGlvblwiXHJcbiAgICAgIFtwcm9wXT1cInByb3AubmFtZVwiXHJcbiAgICAgIFtzb3J0YWJsZV09XCJwcm9wLnNvcnRhYmxlXCJcclxuICAgID5cclxuICAgICAgPG5nLXRlbXBsYXRlIGxldC1yb3c9XCJyb3dcIiBsZXQtaT1cImluZGV4XCIgbmd4LWRhdGF0YWJsZS1jZWxsLXRlbXBsYXRlPlxyXG4gICAgICAgIDxuZy1jb250YWluZXIgKmFicFBlcm1pc3Npb249XCJwcm9wLnBlcm1pc3Npb247IHJ1bkNoYW5nZURldGVjdGlvbjogZmFsc2VcIj5cclxuICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJyb3dbJ18nICsgcHJvcC5uYW1lXT8udmlzaWJsZVwiPlxyXG4gICAgICAgICAgICA8ZGl2XHJcbiAgICAgICAgICAgICAgKm5nSWY9XCIhcm93WydfJyArIHByb3AubmFtZV0uY29tcG9uZW50OyBlbHNlIGNvbXBvbmVudFwiXHJcbiAgICAgICAgICAgICAgW2lubmVySFRNTF09XCJyb3dbJ18nICsgcHJvcC5uYW1lXT8udmFsdWUgfCBhc3luY1wiXHJcbiAgICAgICAgICAgICAgKGNsaWNrKT1cIlxyXG4gICAgICAgICAgICAgICAgcHJvcC5hY3Rpb24gJiYgcHJvcC5hY3Rpb24oeyBnZXRJbmplY3RlZDogZ2V0SW5qZWN0ZWQsIHJlY29yZDogcm93LCBpbmRleDogaSB9KVxyXG4gICAgICAgICAgICAgIFwiXHJcbiAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiZW50aXR5UHJvcFR5cGVDbGFzc2VzW3Byb3AudHlwZV1cIlxyXG4gICAgICAgICAgICAgIFtjbGFzcy5wb2ludGVyXT1cInByb3AuYWN0aW9uXCJcclxuICAgICAgICAgICAgPjwvZGl2PlxyXG4gICAgICAgICAgPC9uZy1jb250YWluZXI+XHJcbiAgICAgICAgICA8bmctdGVtcGxhdGUgI2NvbXBvbmVudD5cclxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxyXG4gICAgICAgICAgICAgICpuZ0NvbXBvbmVudE91dGxldD1cIlxyXG4gICAgICAgICAgICAgICAgcm93WydfJyArIHByb3AubmFtZV0uY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgaW5qZWN0b3I6IHJvd1snXycgKyBwcm9wLm5hbWVdLmluamVjdG9yXHJcbiAgICAgICAgICAgICAgXCJcclxuICAgICAgICAgICAgPjwvbmctY29udGFpbmVyPlxyXG4gICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cclxuICAgICAgPC9uZy10ZW1wbGF0ZT5cclxuICAgIDwvbmd4LWRhdGF0YWJsZS1jb2x1bW4+XHJcbiAgPC9uZy1jb250YWluZXI+XHJcbjwvbmd4LWRhdGF0YWJsZT5cclxuIl19