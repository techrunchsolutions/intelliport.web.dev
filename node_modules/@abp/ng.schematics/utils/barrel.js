"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateBarrelFromPath = exports.createBarrelsGenerator = exports.createProxyIndexGenerator = void 0;
const core_1 = require("@angular-devkit/core");
const constants_1 = require("../constants");
const file_1 = require("./file");
function createProxyIndexGenerator(targetPath) {
    return createBarrelsGenerator(targetPath + constants_1.PROXY_PATH);
}
exports.createProxyIndexGenerator = createProxyIndexGenerator;
function createBarrelsGenerator(rootPath) {
    return (tree) => {
        generateBarrelFromPath(tree, rootPath);
        return tree;
    };
}
exports.createBarrelsGenerator = createBarrelsGenerator;
function generateBarrelFromPath(tree, indexPath) {
    const saveFile = file_1.createFileSaver(tree);
    const asterisk = collectAsteriskBarrel(tree, indexPath);
    const named = collectNamedBarrel(tree, indexPath);
    if (asterisk.exports.length + named.exports.length)
        saveFile(indexPath + '/index.ts', generateBarrelContent(asterisk, named));
}
exports.generateBarrelFromPath = generateBarrelFromPath;
function generateBarrelContent(asterisk, named) {
    const namedImports = !named.imports.length
        ? ''
        : named.imports.join(`
`) +
            `
`;
    const namedExports = !named.exports.length
        ? ''
        : `export { ${named.exports.join(', ')} };
`;
    const asteriskExports = !asterisk.exports.length
        ? ''
        : asterisk.exports.join(`
`) +
            `
`;
    return namedImports + asteriskExports + namedExports;
}
function collectNamedBarrel(tree, indexPath) {
    const dir = tree.getDir(indexPath);
    const barrel = new NamedBarrel();
    dir.subdirs.forEach(fragment => {
        const subDirPath = indexPath + '/' + fragment;
        const subDir = tree.getDir(subDirPath);
        let hasFiles = false;
        subDir.visit(() => (hasFiles = true));
        if (!hasFiles)
            return;
        const namespaceFragment = core_1.strings.classify(fragment);
        barrel.imports.push(`import * as ${namespaceFragment} from './${fragment}';`);
        barrel.exports.push(namespaceFragment);
        generateBarrelFromPath(tree, subDirPath);
    });
    barrel.imports.sort();
    barrel.exports.sort();
    return barrel;
}
function collectAsteriskBarrel(tree, indexPath) {
    const dir = tree.getDir(indexPath);
    const barrel = new AsteriskBarrel();
    dir.subfiles.forEach(fragment => {
        if (!fragment.endsWith('.ts') || fragment === 'index.ts')
            return;
        barrel.exports.push(`export * from './${fragment.replace(/\.ts$/, '')}';`);
    });
    barrel.exports.sort();
    return barrel;
}
class Barrel {
    constructor() {
        this.imports = [];
        this.exports = [];
    }
}
class AsteriskBarrel extends Barrel {
    constructor() {
        super(...arguments);
        this.type = 'Asterisk';
    }
}
class NamedBarrel extends Barrel {
    constructor() {
        super(...arguments);
        this.type = 'Named';
    }
}
//# sourceMappingURL=barrel.js.map