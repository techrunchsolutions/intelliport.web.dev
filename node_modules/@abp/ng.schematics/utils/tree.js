"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseGenerics = exports.TypeNode = void 0;
class TypeNode {
    constructor(data, parent, mapperFn = (node) => node.data) {
        this.data = data;
        this.parent = parent;
        this.mapperFn = mapperFn;
        this.children = [];
        this.index = 0;
    }
    toGenerics() {
        const generics = this.children.length ? `<${this.children.map(n => `T${n.index}`)}>` : '';
        return [this.data + generics].concat(this.children.reduce((acc, node) => acc.concat(node.toGenerics()), []));
    }
    toString() {
        const self = this.mapperFn(this);
        if (!self)
            return '';
        const representation = self + this.children.filter(String).join(', ');
        if (!this.parent)
            return representation;
        const siblings = this.parent.children;
        return ((siblings[0] === this ? '<' : '') +
            representation +
            (siblings[siblings.length - 1] === this ? '>' : ''));
    }
    valueOf() {
        return this.toString();
    }
}
exports.TypeNode = TypeNode;
function parseGenerics(type, mapperFn) {
    const [rootType, ...types] = type.split('<');
    const root = new TypeNode(rootType, null, mapperFn);
    types.reduce((parent, t) => {
        const [left, right] = t.split(/>+,?\s*/);
        const leftNode = new TypeNode(left, parent, mapperFn);
        leftNode.index = parent.children.length;
        parent.children.push(leftNode);
        parent = leftNode;
        let { length } = t.match(/>/g) || [];
        while (length--)
            parent = parent.parent;
        if (right) {
            parent = parent.parent;
            const rightNode = new TypeNode(right, parent, mapperFn);
            rightNode.index = parent.children.length;
            parent.children.push(rightNode);
            parent = rightNode;
        }
        return parent;
    }, root);
    return root;
}
exports.parseGenerics = parseGenerics;
//# sourceMappingURL=tree.js.map