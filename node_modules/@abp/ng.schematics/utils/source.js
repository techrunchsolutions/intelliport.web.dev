"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateProxyConfigJson = exports.createProxyConfigJsonCreator = exports.createFileWriterCreator = exports.createProxyConfigWriterCreator = exports.createProxyConfigSaver = exports.createProxyWarningSaver = exports.createProxyClearer = exports.createProxyConfigReader = exports.getSourceUrl = exports.createRootNamespaceGetter = exports.createApiDefinitionGetter = void 0;
/* eslint-disable no-empty */
const schematics_1 = require("@angular-devkit/schematics");
const got_1 = require("got");
const constants_1 = require("../constants");
const ast_1 = require("./ast");
const common_1 = require("./common");
const workspace_1 = require("./workspace");
function createApiDefinitionGetter(params) {
    const apiName = params.apiName || 'default';
    let sourceUrl = params.url;
    return async (host) => {
        const source = await workspace_1.resolveProject(host, params.source);
        if (!sourceUrl) {
            sourceUrl = getSourceUrl(host, source, apiName);
        }
        return await getApiDefinition(sourceUrl);
    };
}
exports.createApiDefinitionGetter = createApiDefinitionGetter;
async function getApiDefinition(sourceUrl) {
    const url = sourceUrl + constants_1.API_DEFINITION_ENDPOINT;
    let body;
    try {
        ({ body } = await got_1.default(url, {
            responseType: 'json',
            searchParams: { includeTypes: true },
            https: { rejectUnauthorized: false },
        }));
    }
    catch ({ response }) {
        // handle redirects
        if (!(response === null || response === void 0 ? void 0 : response.body) || response.statusCode >= 400)
            throw new schematics_1.SchematicsException(common_1.interpolate("[API Not Available] Request to {0} is unsuccessful. Please double-check the URL in the source project environment and make sure your application is up and running." /* NoApi */, url));
        body = response.body;
    }
    return body;
}
function createRootNamespaceGetter(params) {
    const apiName = params.apiName || 'default';
    return async (tree) => {
        const project = await workspace_1.resolveProject(tree, params.source);
        const environmentExpr = workspace_1.readEnvironment(tree, project.definition);
        if (!environmentExpr)
            throw new schematics_1.SchematicsException(common_1.interpolate("[Environment Not Found] An environment file cannot be located in \"{0}\" project." /* NoEnvironment */, project.name));
        let assignment = ast_1.getAssignedPropertyFromObjectliteral(environmentExpr, [
            'apis',
            apiName,
            'rootNamespace',
        ]);
        if (!assignment)
            assignment = ast_1.getAssignedPropertyFromObjectliteral(environmentExpr, [
                'apis',
                'default',
                'rootNamespace',
            ]);
        if (!assignment)
            throw new schematics_1.SchematicsException(common_1.interpolate("[Root Namespace Not Found] Cannot resolve root namespace for \"{1}\" api from \"{0}\" project." /* NoRootNamespace */, project.name, apiName));
        return assignment.replace(/[`'"]/g, '');
    };
}
exports.createRootNamespaceGetter = createRootNamespaceGetter;
function getSourceUrl(tree, project, apiName) {
    const environmentExpr = workspace_1.readEnvironment(tree, project.definition);
    if (!environmentExpr)
        throw new schematics_1.SchematicsException(common_1.interpolate("[Environment Not Found] An environment file cannot be located in \"{0}\" project." /* NoEnvironment */, project.name));
    let assignment = ast_1.getAssignedPropertyFromObjectliteral(environmentExpr, ['apis', apiName, 'url']);
    if (!assignment)
        assignment = ast_1.getAssignedPropertyFromObjectliteral(environmentExpr, ['apis', 'default', 'url']);
    if (!assignment)
        throw new schematics_1.SchematicsException(common_1.interpolate("[API URL Not Found] Cannot resolve API URL for \"{1}\" remote service name from \"{0}\" project." /* NoApiUrl */, project.name, apiName));
    return assignment.replace(/[`'"]/g, '');
}
exports.getSourceUrl = getSourceUrl;
function createProxyConfigReader(targetPath) {
    targetPath += constants_1.PROXY_CONFIG_PATH;
    return (tree) => {
        try {
            const buffer = tree.read(targetPath);
            return JSON.parse(buffer.toString());
        }
        catch (_) { }
        throw new schematics_1.SchematicsException(common_1.interpolate("[Proxy Config Not Found] There is no JSON file at \"{0}\"." /* NoProxyConfig */, targetPath));
    };
}
exports.createProxyConfigReader = createProxyConfigReader;
function createProxyClearer(targetPath) {
    targetPath += constants_1.PROXY_PATH;
    const proxyIndexPath = `${targetPath}/index.ts`;
    return (tree) => {
        try {
            tree.getDir(targetPath).subdirs.forEach(dirName => {
                const dirPath = `${targetPath}/${dirName}`;
                tree.getDir(dirPath).visit(filePath => tree.delete(filePath));
                tree.delete(dirPath);
            });
            if (tree.exists(proxyIndexPath))
                tree.delete(proxyIndexPath);
            return tree;
        }
        catch (_) {
            throw new schematics_1.SchematicsException(common_1.interpolate("[Directory Remove Failed] Cannot remove \"{0}\"." /* DirRemoveFailed */, targetPath));
        }
    };
}
exports.createProxyClearer = createProxyClearer;
function createProxyWarningSaver(targetPath) {
    targetPath += constants_1.PROXY_WARNING_PATH;
    const createFileWriter = createFileWriterCreator(targetPath);
    return (tree) => {
        const op = tree.exists(targetPath) ? 'overwrite' : 'create';
        const writeWarningMD = createFileWriter(op, constants_1.PROXY_WARNING);
        writeWarningMD(tree);
        return tree;
    };
}
exports.createProxyWarningSaver = createProxyWarningSaver;
function createProxyConfigSaver(apiDefinition, targetPath) {
    const createProxyConfigJson = createProxyConfigJsonCreator(apiDefinition);
    const readPreviousConfig = createProxyConfigReader(targetPath);
    const createProxyConfigWriter = createProxyConfigWriterCreator(targetPath);
    targetPath += constants_1.PROXY_CONFIG_PATH;
    return (tree) => {
        const generated = [];
        let op = 'create';
        if (tree.exists(targetPath)) {
            op = 'overwrite';
            try {
                readPreviousConfig(tree).generated.forEach(m => generated.push(m));
            }
            catch (_) { }
        }
        const json = createProxyConfigJson(generated);
        const writeProxyConfig = createProxyConfigWriter(op, json);
        writeProxyConfig(tree);
        return tree;
    };
}
exports.createProxyConfigSaver = createProxyConfigSaver;
function createProxyConfigWriterCreator(targetPath) {
    targetPath += constants_1.PROXY_CONFIG_PATH;
    return createFileWriterCreator(targetPath);
}
exports.createProxyConfigWriterCreator = createProxyConfigWriterCreator;
function createFileWriterCreator(targetPath) {
    return (op, data) => (tree) => {
        try {
            tree[op](targetPath, data);
            return tree;
        }
        catch (_) { }
        throw new schematics_1.SchematicsException(common_1.interpolate("[File Write Failed] Cannot write file at \"{0}\"." /* FileWriteFailed */, targetPath));
    };
}
exports.createFileWriterCreator = createFileWriterCreator;
function createProxyConfigJsonCreator(apiDefinition) {
    return (generated) => generateProxyConfigJson(Object.assign({ generated }, apiDefinition));
}
exports.createProxyConfigJsonCreator = createProxyConfigJsonCreator;
function generateProxyConfigJson(proxyConfig) {
    return JSON.stringify(proxyConfig, null, 2);
}
exports.generateProxyConfigJson = generateProxyConfigJson;
//# sourceMappingURL=source.js.map