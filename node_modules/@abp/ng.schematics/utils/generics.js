"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replacePlaceholdersWithGenerics = exports.extractGenerics = exports.extractSimpleGenerics = exports.generateRefWithPlaceholders = exports.GenericsCollector = void 0;
const models_1 = require("../models");
class GenericsCollector {
    constructor(getTypeIdentifier = (type) => type) {
        this.getTypeIdentifier = getTypeIdentifier;
        this._generics = [];
        this.apply = (value, index) => {
            const generic = this.get(index);
            if (generic) {
                if (!generic.type)
                    generic.setType(value);
                return value + generic.default;
            }
            return value;
        };
    }
    get generics() {
        return this._generics;
    }
    createGeneric(type, ref, defaultValue) {
        const _default = this.getTypeIdentifier(defaultValue);
        const refs = [generateRefWithPlaceholders(ref)];
        const generic = new models_1.Generic({ type, default: _default, refs });
        return generic;
    }
    register(index, generic) {
        const existing = this.get(index);
        if (existing) {
            existing.setDefault(generic.default);
            existing.setType(generic.type);
        }
        else
            this.set(index, generic);
    }
    collect(generics, genericArguments) {
        generics.forEach((ref, i) => {
            const generic = this.createGeneric(genericArguments[i], ref, genericArguments.includes(ref) ? '' : ref);
            this.register(i, generic);
        });
    }
    get(index) {
        return this.generics[index];
    }
    set(index, value) {
        this.generics[index] = value;
    }
    reset() {
        this._generics = [];
    }
}
exports.GenericsCollector = GenericsCollector;
function generateRefWithPlaceholders(sourceType) {
    // eslint-disable-next-line prefer-const
    let { identifier, generics } = extractGenerics(sourceType);
    generics = generics.map((_, i) => `T${i}`);
    return generics.length ? `${identifier}<${generics}>` : identifier;
}
exports.generateRefWithPlaceholders = generateRefWithPlaceholders;
function extractSimpleGenerics(sourceType) {
    const { identifier, generics } = extractGenerics(sourceType);
    return {
        identifier: getLastSegment(identifier),
        generics: generics.map(getLastSegment),
    };
}
exports.extractSimpleGenerics = extractSimpleGenerics;
function extractGenerics(sourceType) {
    var _a, _b;
    const regex = /(?<identifier>[^<]+)(<(?<generics>.+)>)?/g;
    const { identifier = '', generics = '' } = (_b = (_a = regex.exec(sourceType)) === null || _a === void 0 ? void 0 : _a.groups) !== null && _b !== void 0 ? _b : {};
    return {
        identifier,
        generics: generics.split(/,\s*/).filter(Boolean),
    };
}
exports.extractGenerics = extractGenerics;
function getLastSegment(str) {
    return str.split('.').pop();
}
function replacePlaceholdersWithGenerics(type, generics, genericsCollector) {
    return generics
        .map(genericsCollector.apply)
        .reduce((acc, v, i) => acc.replace(new RegExp(`([<, ])T${i}([,>])`, 'g'), `$1${v}$2`), type);
}
exports.replacePlaceholdersWithGenerics = replacePlaceholdersWithGenerics;
//# sourceMappingURL=generics.js.map