"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRefToImportReducerCreator = exports.createImportRefToInterfaceReducerCreator = exports.createImportRefsToModelReducer = void 0;
const constants_1 = require("../constants");
const models_1 = require("../models");
const generics_1 = require("./generics");
const namespace_1 = require("./namespace");
const path_1 = require("./path");
const text_1 = require("./text");
const tree_1 = require("./tree");
const type_1 = require("./type");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const shouldQuote = require('should-quote');
function createImportRefsToModelReducer(params) {
    const reduceImportRefsToInterfaces = createImportRefToInterfaceReducerCreator(params);
    const createRefToImportReducer = createRefToImportReducerCreator(params);
    const { solution, types } = params;
    return (models, importRefs) => {
        const enums = [];
        const interfaces = importRefs.reduce(reduceImportRefsToInterfaces, []);
        sortInterfaces(interfaces);
        interfaces.forEach(_interface => {
            if (constants_1.VOLO_REGEX.test(_interface.ref))
                return;
            if (types[_interface.ref].isEnum) {
                if (!enums.includes(_interface.ref))
                    enums.push(_interface.ref);
                return;
            }
            const index = models.findIndex(m => m.namespace === _interface.namespace);
            if (index > -1) {
                if (models[index].interfaces.some(i => i.identifier === _interface.identifier))
                    return;
                models[index].interfaces.push(_interface);
            }
            else {
                const { namespace } = _interface;
                models.push(new models_1.Model({
                    interfaces: [_interface],
                    namespace,
                    path: path_1.relativePathToModel(namespace, namespace),
                }));
            }
        });
        models.forEach(model => {
            const toBeImported = [];
            model.interfaces.forEach(_interface => {
                const { baseType } = types[_interface.ref];
                if (baseType && namespace_1.parseNamespace(solution, baseType) !== model.namespace)
                    toBeImported.push({
                        type: baseType.split('<')[0],
                        isEnum: false,
                    });
                [..._interface.properties, ..._interface.generics].forEach(prop => {
                    prop.refs.forEach(ref => {
                        const propType = types[ref];
                        if (!propType)
                            return;
                        if (propType.isEnum)
                            toBeImported.push({ type: ref, isEnum: true });
                        else if (namespace_1.parseNamespace(solution, ref) !== model.namespace)
                            toBeImported.push({ type: ref, isEnum: false });
                    });
                });
            });
            if (!toBeImported.length)
                return;
            const reduceRefToImport = createRefToImportReducer(model.namespace);
            reduceRefToImport(model.imports, toBeImported);
        });
        return models;
    };
}
exports.createImportRefsToModelReducer = createImportRefsToModelReducer;
function sortInterfaces(interfaces) {
    interfaces.sort((a, b) => (a.identifier > b.identifier ? 1 : -1));
}
function createImportRefToInterfaceReducerCreator(params) {
    const { solution, types } = params;
    const parseType = type_1.createTypeParser(type_1.removeTypeModifiers);
    const simplifyType = type_1.createTypeSimplifier();
    const getIdentifier = (type) => type_1.removeTypeModifiers(simplifyType(type));
    const genericsCollector = new generics_1.GenericsCollector(getIdentifier);
    return reduceRefsToInterfaces;
    function reduceRefsToInterfaces(interfaces, ref) {
        var _a;
        const typeDef = types[ref];
        if (!typeDef)
            return interfaces;
        const namespace = namespace_1.parseNamespace(solution, ref);
        let { baseType: base, genericArguments } = typeDef;
        genericArguments = genericArguments || [];
        let identifier = getIdentifier(ref);
        identifier = generics_1.replacePlaceholdersWithGenerics(identifier, genericArguments, genericsCollector);
        if (base) {
            if (type_1.extendsSelf(ref, base)) {
                genericsCollector.collect(generics_1.extractGenerics(base).generics, genericArguments);
                return reduceRefsToInterfaces(interfaces, generics_1.generateRefWithPlaceholders(base));
            }
            else {
                base = getIdentifier(base);
            }
        }
        const { generics } = genericsCollector;
        const _interface = new models_1.Interface({ identifier, base, namespace, ref, generics });
        genericsCollector.reset();
        (_a = typeDef.properties) === null || _a === void 0 ? void 0 : _a.forEach(prop => {
            let name = prop.jsonName || text_1.camel(prop.name);
            name = shouldQuote(name) ? `'${name}'` : name;
            const type = simplifyType(prop.typeSimple);
            const refs = parseType(prop.type).reduce((acc, r) => acc.concat(tree_1.parseGenerics(r).toGenerics()), []);
            const property = new models_1.Property({ name, type, refs });
            property.setOptional(isOptionalProperty(prop));
            _interface.properties.push(property);
        });
        interfaces.push(_interface);
        return [..._interface.properties, ..._interface.generics]
            .reduce((refs, prop) => {
            prop.refs.forEach(type => {
                var _a;
                if ((_a = types[type]) === null || _a === void 0 ? void 0 : _a.isEnum)
                    return;
                if (interfaces.some(i => i.ref === type))
                    return;
                refs.push(type);
            });
            return refs;
        }, [])
            .concat(base ? tree_1.parseGenerics(typeDef.baseType).toGenerics() : [])
            .reduce(reduceRefsToInterfaces, interfaces);
    }
}
exports.createImportRefToInterfaceReducerCreator = createImportRefToInterfaceReducerCreator;
function createRefToImportReducerCreator(params) {
    const { solution } = params;
    return (namespace) => type_1.createTypesToImportsReducer(solution, namespace);
}
exports.createRefToImportReducerCreator = createRefToImportReducerCreator;
function isOptionalProperty(prop) {
    return (prop.typeSimple.endsWith('?') || (prop.typeSimple === 'string' && prop.isRequired === false));
}
//# sourceMappingURL=model.js.map