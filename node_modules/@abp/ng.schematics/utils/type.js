"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extendsSelf = exports.createTypeAdapter = exports.createTypeToImportMapper = exports.createTypesToImportsReducer = exports.removeTypeModifiers = exports.removeGenerics = exports.normalizeTypeAnnotations = exports.flattenDictionaryTypes = exports.createTypeNormalizer = exports.createTypeParser = exports.createTypeSimplifier = void 0;
const constants_1 = require("../constants");
const enums_1 = require("../enums");
const models_1 = require("../models");
const generics_1 = require("./generics");
const namespace_1 = require("./namespace");
const path_1 = require("./path");
const tree_1 = require("./tree");
function createTypeSimplifier() {
    const parseType = createTypeParser(t => {
        let type = t.replace(/(?<![^<, ])System\.([0-9A-Za-z.]+)/g, (_, match) => { var _a; return (_a = constants_1.SYSTEM_TYPES.get(match)) !== null && _a !== void 0 ? _a : 'any'; });
        type = /any</.test(type) ? 'any' : type;
        const { identifier, generics } = generics_1.extractSimpleGenerics(type);
        return generics.length ? `${identifier}<${generics.join(', ')}>` : identifier;
    });
    return (type) => {
        const parsed = parseType(type);
        const last = parsed.pop();
        return parsed.reduceRight((record, tKey) => `Record<${tKey}, ${record}>`, last);
    };
}
exports.createTypeSimplifier = createTypeSimplifier;
function createTypeParser(replacerFn = (t) => t) {
    const normalizeType = createTypeNormalizer(replacerFn);
    return (originalType) => flattenDictionaryTypes([], originalType).map(normalizeType);
}
exports.createTypeParser = createTypeParser;
function createTypeNormalizer(replacerFn = (t) => t) {
    return (type) => {
        return replacerFn(normalizeTypeAnnotations(type));
    };
}
exports.createTypeNormalizer = createTypeNormalizer;
function flattenDictionaryTypes(types, type) {
    type
        .replace(/[}{]/g, '')
        .split(':')
        .forEach(t => types.push(t));
    return types;
}
exports.flattenDictionaryTypes = flattenDictionaryTypes;
function normalizeTypeAnnotations(type) {
    return type.replace(/\[(.+)+\]/g, '$1[]').replace(/\?/g, '');
}
exports.normalizeTypeAnnotations = normalizeTypeAnnotations;
function removeGenerics(type) {
    return type.replace(/<.+>/g, '');
}
exports.removeGenerics = removeGenerics;
function removeTypeModifiers(type) {
    return type.replace(/\[\]/g, '');
}
exports.removeTypeModifiers = removeTypeModifiers;
function createTypesToImportsReducer(solution, namespace) {
    const mapTypeToImport = createTypeToImportMapper(solution, namespace);
    return (imports, types) => {
        types.forEach(({ type, isEnum }) => {
            const newImport = mapTypeToImport(type, isEnum);
            if (!newImport)
                return;
            const existingImport = imports.find(({ keyword, path }) => keyword === newImport.keyword && path === newImport.path);
            if (!existingImport)
                return imports.push(newImport);
            existingImport.refs = [...new Set([...existingImport.refs, ...newImport.refs])];
            existingImport.specifiers = [
                ...new Set([...existingImport.specifiers, ...newImport.specifiers]),
            ].sort();
        });
        return imports;
    };
}
exports.createTypesToImportsReducer = createTypesToImportsReducer;
function createTypeToImportMapper(solution, namespace) {
    const adaptType = createTypeAdapter();
    const simplifyType = createTypeSimplifier();
    return (type, isEnum) => {
        if (!type || type.startsWith('System'))
            return;
        const modelNamespace = namespace_1.parseNamespace(solution, type);
        const refs = [removeTypeModifiers(type)];
        const specifiers = [adaptType(simplifyType(refs[0]).split('<')[0])];
        const path = constants_1.VOLO_REGEX.test(type)
            ? '@abp/ng.core'
            : isEnum
                ? path_1.relativePathToEnum(namespace, modelNamespace, specifiers[0])
                : path_1.relativePathToModel(namespace, modelNamespace);
        return new models_1.Import({ keyword: enums_1.eImportKeyword.Type, path, refs, specifiers });
    };
}
exports.createTypeToImportMapper = createTypeToImportMapper;
function createTypeAdapter() {
    const simplifyType = createTypeSimplifier();
    return (type) => tree_1.parseGenerics(type, node => simplifyType(node.data)).toString();
}
exports.createTypeAdapter = createTypeAdapter;
// naming here is depictive only
function extendsSelf(type, base) {
    return removeGenerics(base) === removeGenerics(type);
}
exports.extendsSelf = extendsSelf;
//# sourceMappingURL=type.js.map