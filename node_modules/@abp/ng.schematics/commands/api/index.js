"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const utils_1 = require("../../utils");
const cases = require("../../utils/text");
function default_1(schema) {
    const params = utils_1.removeDefaultPlaceholders(schema);
    const moduleName = params.module || 'app';
    return schematics_1.chain([
        async (tree, _context) => {
            const getRootNamespace = utils_1.createRootNamespaceGetter(params);
            const solution = await getRootNamespace(tree);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const target = await utils_1.resolveProject(tree, params.target);
            const targetPath = utils_1.buildDefaultPath(target.definition);
            const readProxyConfig = utils_1.createProxyConfigReader(targetPath);
            const createProxyConfigWriter = utils_1.createProxyConfigWriterCreator(targetPath);
            const data = readProxyConfig(tree);
            const types = data.types;
            const modules = data.modules;
            if (!types || !modules)
                throw new schematics_1.SchematicsException("[Invalid API Definition] The provided API definition is invalid." /* InvalidApiDefinition */);
            const definition = data.modules[moduleName];
            if (!definition)
                throw new schematics_1.SchematicsException(utils_1.interpolate("[Invalid Module] Backend module \"{0}\" does not exist in API definition." /* InvalidModule */, moduleName));
            const apiName = definition.remoteServiceName;
            const controllers = Object.values(definition.controllers || {});
            const serviceImports = {};
            const generateServices = createServiceGenerator({
                targetPath,
                solution,
                types,
                apiName,
                controllers,
                serviceImports,
            });
            const modelImports = {};
            const generateModels = createModelGenerator({
                targetPath,
                solution,
                types,
                serviceImports,
                modelImports,
            });
            const generateEnums = createEnumGenerator({
                targetPath,
                solution,
                types,
                serviceImports,
                modelImports,
            });
            if (!data.generated.includes(moduleName))
                data.generated.push(moduleName);
            data.generated.sort();
            const json = utils_1.generateProxyConfigJson(data);
            const overwriteProxyConfig = createProxyConfigWriter('overwrite', json);
            return schematics_1.branchAndMerge(schematics_1.chain([generateServices, generateModels, generateEnums, overwriteProxyConfig]));
        },
    ]);
}
exports.default = default_1;
function createEnumGenerator(params) {
    const { targetPath, serviceImports, modelImports } = params;
    const mapImportRefToEnum = utils_1.createImportRefToEnumMapper(params);
    const enumRefs = [
        ...new Set([
            ...utils_1.getEnumNamesFromImports(serviceImports),
            ...utils_1.getEnumNamesFromImports(modelImports),
        ]),
    ];
    return schematics_1.chain(enumRefs.map(ref => {
        return utils_1.applyWithOverwrite(schematics_1.url('./files-enum'), [
            schematics_1.applyTemplates(Object.assign(Object.assign({}, cases), mapImportRefToEnum(ref))),
            schematics_1.move(core_1.normalize(targetPath)),
        ]);
    }));
}
function createModelGenerator(params) {
    const { targetPath, serviceImports, modelImports } = params;
    const reduceImportRefsToModels = utils_1.createImportRefsToModelReducer(params);
    const models = Object.values(serviceImports).reduce(reduceImportRefsToModels, []);
    models.forEach(({ imports }) => imports.forEach(({ refs, path }) => refs.forEach(ref => {
        if (path === '@abp/ng.core')
            return;
        if (!modelImports[path])
            return (modelImports[path] = [ref]);
        modelImports[path] = [...new Set([...modelImports[path], ref])];
    })));
    return schematics_1.chain(models.map(model => utils_1.applyWithOverwrite(schematics_1.url('./files-model'), [
        schematics_1.applyTemplates(Object.assign(Object.assign({}, cases), model)),
        schematics_1.move(core_1.normalize(targetPath)),
    ])));
}
function createServiceGenerator(params) {
    const { targetPath, controllers, serviceImports } = params;
    const mapControllerToService = utils_1.createControllerToServiceMapper(params);
    return schematics_1.chain(controllers.map(controller => {
        const service = mapControllerToService(controller);
        service.imports.forEach(({ refs, path }) => refs.forEach(ref => {
            if (path === '@abp/ng.core')
                return;
            if (!serviceImports[path])
                return (serviceImports[path] = [ref]);
            serviceImports[path] = [...new Set([...serviceImports[path], ref])];
        }));
        return utils_1.applyWithOverwrite(schematics_1.url('./files-service'), [
            schematics_1.applyTemplates(Object.assign(Object.assign(Object.assign({}, cases), { serializeParameters: utils_1.serializeParameters }), service)),
            schematics_1.move(core_1.normalize(targetPath)),
        ]);
    }));
}
//# sourceMappingURL=index.js.map