import * as i0 from '@angular/core';
import { ChangeDetectorRef, Component, Input, InjectionToken, Injectable, Inject, isDevMode, Optional, SkipSelf, Directive, EventEmitter, Output, Self, Injector, Pipe, NgModule, APP_INITIALIZER, LOCALE_ID, NgModuleFactory, Compiler, ComponentFactoryResolver, ApplicationRef, inject } from '@angular/core';
import * as i1$1 from '@angular/router';
import { PRIMARY_OUTLET, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, ActivatedRoute, Router, RouterModule } from '@angular/router';
import * as i5 from '@angular/common';
import { registerLocaleData, DOCUMENT, DatePipe, DATE_PIPE_DEFAULT_TIMEZONE, CommonModule } from '@angular/common';
import { BehaviorSubject, Subject, throwError, combineLatest, from, Subscription, fromEvent, of, timer, pipe, Observable, concat, ReplaySubject } from 'rxjs';
import { map, distinctUntilChanged, filter, catchError, switchMap, take, mapTo, debounceTime, takeUntil, tap, finalize, retryWhen, delay, shareReplay } from 'rxjs/operators';
import * as i1 from '@angular/common/http';
import { HttpParams, HttpHeaders, HttpClient, HttpClientModule, HttpClientXsrfModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import compare from 'just-compare';
import * as i1$2 from '@angular/forms';
import { FormsModule, ReactiveFormsModule, Validators } from '@angular/forms';
import * as i1$3 from 'angular-oauth2-oidc';
import { OAuthStorage, OAuthService, OAuthErrorEvent, OAuthInfoEvent, OAuthModule } from 'angular-oauth2-oidc';
import clone from 'just-clone';

// Not an abstract class on purpose. Do not change!
class AbstractNgModelComponent {
    constructor(injector) {
        this.injector = injector;
        this.valueFn = value => value;
        this.valueLimitFn = value => false;
        this.cdRef = injector.get(ChangeDetectorRef);
    }
    set value(value) {
        value = this.valueFn(value, this._value);
        if (this.valueLimitFn(value, this._value) !== false || this.readonly)
            return;
        this._value = value;
        this.notifyValueChange();
    }
    get value() {
        return this._value || this.defaultValue;
    }
    get defaultValue() {
        return this._value;
    }
    notifyValueChange() {
        if (this.onChange) {
            this.onChange(this.value);
        }
    }
    writeValue(value) {
        this._value = this.valueLimitFn(value, this._value) || value;
        setTimeout(() => this.cdRef.markForCheck(), 0);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
AbstractNgModelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbstractNgModelComponent, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Component });
AbstractNgModelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.6", type: AbstractNgModelComponent, selector: "ng-component", inputs: { disabled: "disabled", readonly: "readonly", valueFn: "valueFn", valueLimitFn: "valueLimitFn", value: "value" }, ngImport: i0, template: '', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbstractNgModelComponent, decorators: [{
            type: Component,
            args: [{ template: '' }]
        }], ctorParameters: function () { return [{ type: i0.Injector }]; }, propDecorators: { disabled: [{
                type: Input
            }], readonly: [{
                type: Input
            }], valueFn: [{
                type: Input
            }], valueLimitFn: [{
                type: Input
            }], value: [{
                type: Input
            }] } });

const LOCALIZATIONS = new InjectionToken('LOCALIZATIONS');
function localizationContributor(localizations) {
    if (localizations) {
        localizations$.next([...localizations$.value, ...localizations]);
    }
}
const localizations$ = new BehaviorSubject([]);

const CORE_OPTIONS = new InjectionToken('CORE_OPTIONS');
function coreOptionsFactory({ ...options }) {
    return {
        ...options,
    };
}

// This will not be necessary when only Angukar 9.1+ is supported
function getLocaleDirection(locale) {
    return /^(ar(-[A-Z]{2})?|ckb(-IR)?|fa(-AF)?|he|ks|lrc(-IQ)?|mzn|pa-Arab|ps(-PK)?|sd|ug|ur(-IN)?|uz-Arab|yi)$/.test(locale)
        ? 'rtl'
        : 'ltr';
}
function createLocalizer(localization) {
    return (resourceName, key, defaultValue) => {
        if (resourceName === '_')
            return key;
        const resource = localization?.values?.[resourceName];
        if (!resource)
            return defaultValue;
        return resource[key] || defaultValue;
    };
}
function createLocalizerWithFallback(localization) {
    const findLocalization = createLocalizationFinder(localization);
    return (resourceNames, keys, defaultValue) => {
        const { localized } = findLocalization(resourceNames, keys);
        return localized || defaultValue;
    };
}
function createLocalizationPipeKeyGenerator(localization) {
    const findLocalization = createLocalizationFinder(localization);
    return (resourceNames, keys, defaultKey) => {
        const { resourceName, key } = findLocalization(resourceNames, keys);
        return !resourceName ? defaultKey : resourceName === '_' ? key : `${resourceName}::${key}`;
    };
}
function createLocalizationFinder(localization) {
    const localize = createLocalizer(localization);
    return (resourceNames, keys) => {
        resourceNames = resourceNames.concat(localization.defaultResourceName || '').filter(Boolean);
        const resourceCount = resourceNames.length;
        const keyCount = keys.length;
        for (let i = 0; i < resourceCount; i++) {
            const resourceName = resourceNames[i];
            for (let j = 0; j < keyCount; j++) {
                const key = keys[j];
                const localized = localize(resourceName, key, null);
                if (localized)
                    return { resourceName, key, localized };
            }
        }
        return { resourceName: undefined, key: undefined, localized: undefined };
    };
}

function createTokenParser(format) {
    return (str) => {
        const tokens = [];
        const regex = format.replace(/\./g, '\\.').replace(/\{\s?([0-9a-zA-Z]+)\s?\}/g, (_, token) => {
            tokens.push(token);
            return '(.+)';
        });
        const matches = (str.match(regex) || []).slice(1);
        return matches.reduce((acc, v, i) => {
            const key = tokens[i];
            acc[key] = [...(acc[key] || []), v].filter(Boolean);
            return acc;
        }, {});
    };
}
function interpolate(text, params) {
    return text
        .replace(/(['"]?\{\s*(\d+)\s*\}['"]?)/g, (_, match, digit) => params[digit] ?? match)
        .replace(/\s+/g, ' ');
}
function escapeHtmlChars(value) {
    return value && typeof value === 'string'
        ? value
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
        : value;
}

function noop() {
    const fn = function () { };
    return fn;
}
function isUndefinedOrEmptyString(value) {
    return value === undefined || value === '';
}
function isNullOrUndefined(obj) {
    return obj === null || obj === undefined;
}
function exists(obj) {
    return !isNullOrUndefined(obj);
}
function isObject(obj) {
    return obj instanceof Object;
}
function isArray(obj) {
    return Array.isArray(obj);
}
function isObjectAndNotArray(obj) {
    return isObject(obj) && !isArray(obj);
}
function isNode(obj) {
    return obj instanceof Node;
}
function isObjectAndNotArrayNotNode(obj) {
    return isObjectAndNotArray(obj) && !isNode(obj);
}

function deepMerge(target, source) {
    if (isObjectAndNotArrayNotNode(target) && isObjectAndNotArrayNotNode(source)) {
        return deepMergeRecursively(target, source);
    }
    else if (isNullOrUndefined(target) && isNullOrUndefined(source)) {
        return {};
    }
    else {
        return exists(source) ? source : target;
    }
}
function deepMergeRecursively(target, source) {
    const shouldNotRecurse = isNullOrUndefined(target) ||
        isNullOrUndefined(source) || // at least one not defined
        isArray(target) ||
        isArray(source) || // at least one array
        !isObject(target) ||
        !isObject(source) || // at least one not an object
        isNode(target) ||
        isNode(source); // at least one node
    /**
     * if we will not recurse any further,
     * we will prioritize source if it is a defined value.
     */
    if (shouldNotRecurse) {
        return exists(source) ? source : target;
    }
    const keysOfTarget = Object.keys(target);
    const keysOfSource = Object.keys(source);
    const uniqueKeys = new Set(keysOfTarget.concat(keysOfSource));
    return [...uniqueKeys].reduce((retVal, key) => {
        retVal[key] = deepMergeRecursively(target[key], source[key]);
        return retVal;
    }, {});
}

class InternalStore {
    constructor(initialState) {
        this.initialState = initialState;
        this.state$ = new BehaviorSubject(this.initialState);
        this.update$ = new Subject();
        this.sliceState = (selector, compareFn = compare) => this.state$.pipe(map(selector), distinctUntilChanged(compareFn));
        this.sliceUpdate = (selector, filterFn = (x) => x !== undefined) => this.update$.pipe(map(selector), filter(filterFn));
    }
    get state() {
        return this.state$.value;
    }
    patch(state) {
        let patchedState = state;
        if (typeof state === 'object' && !Array.isArray(state)) {
            patchedState = { ...this.state, ...state };
        }
        this.state$.next(patchedState);
        this.update$.next(patchedState);
    }
    deepPatch(state) {
        this.state$.next(deepMerge(this.state, state));
        this.update$.next(state);
    }
    set(state) {
        this.state$.next(state);
        this.update$.next(state);
    }
    reset() {
        this.set(this.initialState);
    }
}

const mapToApiUrl = (key) => (apis) => (apis[key] || apis.default).url || apis.default.url;
class EnvironmentService {
    constructor() {
        this.store = new InternalStore({});
    }
    get createOnUpdateStream() {
        return this.store.sliceUpdate;
    }
    getEnvironment$() {
        return this.store.sliceState(state => state);
    }
    getEnvironment() {
        return this.store.state;
    }
    getApiUrl(key) {
        return mapToApiUrl(key)(this.store.state.apis);
    }
    getApiUrl$(key) {
        return this.store.sliceState(state => state.apis).pipe(map(mapToApiUrl(key)));
    }
    setState(environment) {
        this.store.set(environment);
    }
}
EnvironmentService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: EnvironmentService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
EnvironmentService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: EnvironmentService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: EnvironmentService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class HttpErrorReporterService {
    constructor() {
        this._reporter$ = new Subject();
        this._errors$ = new BehaviorSubject([]);
        this.reportError = (error) => {
            this._reporter$.next(error);
            this._errors$.next([...this.errors, error]);
        };
    }
    get reporter$() {
        return this._reporter$.asObservable();
    }
    get errors$() {
        return this._errors$.asObservable();
    }
    get errors() {
        return this._errors$.value;
    }
}
HttpErrorReporterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: HttpErrorReporterService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
HttpErrorReporterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: HttpErrorReporterService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: HttpErrorReporterService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class RestService {
    constructor(options, http, environment, httpErrorReporter) {
        this.options = options;
        this.http = http;
        this.environment = environment;
        this.httpErrorReporter = httpErrorReporter;
    }
    getApiFromStore(apiName) {
        return this.environment.getApiUrl(apiName);
    }
    handleError(err) {
        this.httpErrorReporter.reportError(err);
        return throwError(err);
    }
    request(request, config, api) {
        config = config || {};
        api = api || this.getApiFromStore(config.apiName);
        const { method, params, ...options } = request;
        const { observe = "body" /* Body */, skipHandleError } = config;
        return this.http
            .request(method, api + request.url, {
            observe,
            ...(params && {
                params: this.getParams(params, config.httpParamEncoder),
            }),
            ...options,
        })
            .pipe(catchError(err => (skipHandleError ? throwError(err) : this.handleError(err))));
    }
    getParams(params, encoder) {
        const filteredParams = Object.keys(params).reduce((acc, key) => {
            const value = params[key];
            if (isUndefinedOrEmptyString(value))
                return acc;
            if (value === null && !this.options.sendNullsAsQueryParam)
                return acc;
            acc[key] = value;
            return acc;
        }, {});
        return encoder
            ? new HttpParams({ encoder, fromObject: filteredParams })
            : new HttpParams({ fromObject: filteredParams });
    }
}
RestService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RestService, deps: [{ token: CORE_OPTIONS }, { token: i1.HttpClient }, { token: EnvironmentService }, { token: HttpErrorReporterService }], target: i0.ɵɵFactoryTarget.Injectable });
RestService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RestService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RestService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [CORE_OPTIONS]
                }] }, { type: i1.HttpClient }, { type: EnvironmentService }, { type: HttpErrorReporterService }]; } });

class AbpApplicationConfigurationService {
    constructor(restService) {
        this.restService = restService;
        this.apiName = 'abp';
    }
    get() {
        return this.restService.request({
            method: 'GET',
            url: '/api/abp/application-configuration',
        }, { apiName: this.apiName });
    }
}
AbpApplicationConfigurationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbpApplicationConfigurationService, deps: [{ token: RestService }], target: i0.ɵɵFactoryTarget.Injectable });
AbpApplicationConfigurationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbpApplicationConfigurationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbpApplicationConfigurationService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: RestService }]; } });

class ConfigStateService {
    constructor(abpConfigService) {
        this.abpConfigService = abpConfigService;
        this.store = new InternalStore({});
        this.updateSubject = new Subject();
        this.initUpdateStream();
    }
    get createOnUpdateStream() {
        return this.store.sliceUpdate;
    }
    initUpdateStream() {
        this.updateSubject
            .pipe(switchMap(() => this.abpConfigService.get()))
            .subscribe(res => this.store.set(res));
    }
    refreshAppState() {
        this.updateSubject.next();
        return this.createOnUpdateStream(state => state).pipe(take(1));
    }
    getOne$(key) {
        return this.store.sliceState(state => state[key]);
    }
    getOne(key) {
        return this.store.state[key];
    }
    getAll$() {
        return this.store.sliceState(state => state);
    }
    getAll() {
        return this.store.state;
    }
    getDeep$(keys) {
        keys = splitKeys(keys);
        return this.store
            .sliceState(state => state)
            .pipe(map(state => {
            return keys.reduce((acc, val) => {
                if (acc) {
                    return acc[val];
                }
                return undefined;
            }, state);
        }));
    }
    getDeep(keys) {
        keys = splitKeys(keys);
        return keys.reduce((acc, val) => {
            if (acc) {
                return acc[val];
            }
            return undefined;
        }, this.store.state);
    }
    getFeature(key) {
        return this.store.state.features?.values?.[key];
    }
    getFeature$(key) {
        return this.store.sliceState(state => state.features?.values?.[key]);
    }
    getFeatures(keys) {
        const { features } = this.store.state;
        if (!features)
            return;
        return keys.reduce((acc, key) => ({ ...acc, [key]: features.values[key] }), {});
    }
    getFeatures$(keys) {
        return this.store.sliceState(({ features }) => {
            if (!features?.values)
                return;
            return keys.reduce((acc, key) => ({ ...acc, [key]: features.values[key] }), {});
        });
    }
    getSetting(key) {
        return this.store.state.setting?.values?.[key];
    }
    getSetting$(key) {
        return this.store.sliceState(state => state.setting?.values?.[key]);
    }
    getSettings(keyword) {
        const settings = this.store.state.setting?.values || {};
        if (!keyword)
            return settings;
        const keysFound = Object.keys(settings).filter(key => key.indexOf(keyword) > -1);
        return keysFound.reduce((acc, key) => {
            acc[key] = settings[key];
            return acc;
        }, {});
    }
    getSettings$(keyword) {
        return this.store
            .sliceState(state => state.setting?.values)
            .pipe(map((settings = {}) => {
            if (!keyword)
                return settings;
            const keysFound = Object.keys(settings).filter(key => key.indexOf(keyword) > -1);
            return keysFound.reduce((acc, key) => {
                acc[key] = settings[key];
                return acc;
            }, {});
        }));
    }
}
ConfigStateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ConfigStateService, deps: [{ token: AbpApplicationConfigurationService }], target: i0.ɵɵFactoryTarget.Injectable });
ConfigStateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ConfigStateService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ConfigStateService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: AbpApplicationConfigurationService }]; } });
function splitKeys(keys) {
    if (typeof keys === 'string') {
        keys = keys.split('.');
    }
    if (!Array.isArray(keys)) {
        throw new Error('The argument must be a dot string or an string array.');
    }
    return keys;
}

class SessionStateService {
    constructor(configState) {
        this.configState = configState;
        this.store = new InternalStore({});
        this.updateLocalStorage = () => {
            localStorage.setItem('abpSession', JSON.stringify(this.store.state));
        };
        this.init();
        this.setInitialLanguage();
    }
    init() {
        const session = localStorage.getItem('abpSession');
        if (session) {
            this.store.set(JSON.parse(session));
        }
        this.store.sliceUpdate(state => state).subscribe(this.updateLocalStorage);
    }
    setInitialLanguage() {
        if (this.getLanguage())
            return;
        this.configState
            .getDeep$('localization.currentCulture.cultureName')
            .pipe(filter(cultureName => !!cultureName), take(1))
            .subscribe(lang => {
            if (lang.includes(';')) {
                lang = lang.split(';')[0];
            }
            this.setLanguage(lang);
        });
    }
    onLanguageChange$() {
        return this.store.sliceUpdate(state => state.language);
    }
    onTenantChange$() {
        return this.store.sliceUpdate(state => state.tenant);
    }
    getLanguage() {
        return this.store.state.language;
    }
    getLanguage$() {
        return this.store.sliceState(state => state.language);
    }
    getTenant() {
        return this.store.state.tenant;
    }
    getTenant$() {
        return this.store.sliceState(state => state.tenant);
    }
    setTenant(tenant) {
        if (compare(tenant, this.store.state.tenant))
            return;
        this.store.set({ ...this.store.state, tenant });
    }
    setLanguage(language) {
        if (language === this.store.state.language)
            return;
        this.store.patch({ language });
        document.documentElement.setAttribute('lang', language);
    }
}
SessionStateService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: SessionStateService, deps: [{ token: ConfigStateService }], target: i0.ɵɵFactoryTarget.Injectable });
SessionStateService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: SessionStateService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: SessionStateService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: ConfigStateService }]; } });

class LocalizationService {
    constructor(sessionState, injector, otherInstance, configState) {
        this.sessionState = sessionState;
        this.injector = injector;
        this.configState = configState;
        this.latestLang = this.sessionState.getLanguage();
        this._languageChange$ = new Subject();
        this.uiLocalizations$ = new BehaviorSubject(new Map());
        this.localizations$ = new BehaviorSubject(new Map());
        if (otherInstance)
            throw new Error('LocalizationService should have only one instance.');
        this.listenToSetLanguage();
        this.initLocalizationValues();
    }
    /**
     * Returns currently selected language
     * Even though this looks like it's redundant to return the same value as `getLanguage()`,
     * it's actually not. This could be invoked any time, and the latestLang could be different from the
     * sessionState.getLanguage() value.
     */
    get currentLang() {
        return this.latestLang || this.sessionState.getLanguage();
    }
    get currentLang$() {
        return this.sessionState.getLanguage$();
    }
    get languageChange$() {
        return this._languageChange$.asObservable();
    }
    initLocalizationValues() {
        localizations$.subscribe(val => this.addLocalization(val));
        const remoteLocalizations$ = this.configState.getDeep$('localization.values');
        const currentLanguage$ = this.sessionState.getLanguage$();
        const uiLocalizations$ = combineLatest([currentLanguage$, this.uiLocalizations$]).pipe(map(([currentLang, localizations]) => localizations.get(currentLang)));
        combineLatest([remoteLocalizations$, uiLocalizations$])
            .pipe(map(([remote, local]) => {
            if (remote) {
                if (!local) {
                    local = new Map();
                }
                Object.entries(remote).forEach(entry => {
                    const resourceName = entry[0];
                    const remoteTexts = entry[1];
                    let resource = local.get(resourceName) || {};
                    resource = { ...resource, ...remoteTexts };
                    local.set(resourceName, resource);
                });
            }
            return local;
        }))
            .subscribe(val => this.localizations$.next(val));
    }
    addLocalization(localizations) {
        if (!localizations)
            return;
        const localizationMap = this.uiLocalizations$.value;
        localizations.forEach(loc => {
            const cultureMap = localizationMap.get(loc.culture) || new Map();
            loc.resources.forEach(res => {
                let resource = cultureMap.get(res.resourceName) || {};
                resource = { ...resource, ...res.texts };
                cultureMap.set(res.resourceName, resource);
            });
            localizationMap.set(loc.culture, cultureMap);
        });
        this.uiLocalizations$.next(localizationMap);
    }
    listenToSetLanguage() {
        this.sessionState
            .onLanguageChange$()
            .pipe(filter(lang => this.configState.getDeep('localization.currentCulture.cultureName') !== lang), switchMap(lang => this.configState.refreshAppState().pipe(mapTo(lang))), switchMap(lang => from(this.registerLocale(lang).then(() => lang))))
            .subscribe(lang => this._languageChange$.next(lang));
    }
    registerLocale(locale) {
        const { registerLocaleFn } = this.injector.get(CORE_OPTIONS);
        return registerLocaleFn(locale).then(module => {
            if (module?.default)
                registerLocaleData(module.default);
            this.latestLang = locale;
        });
    }
    /**
     * Returns an observable localized text with the given interpolation parameters in current language.
     * @param key Localizaton key to replace with localized text
     * @param interpolateParams Values to interpolate
     */
    get(key, ...interpolateParams) {
        return this.configState
            .getAll$()
            .pipe(map(state => this.getLocalization(state, key, ...interpolateParams)));
    }
    getResource(resourceName) {
        return this.localizations$.value.get(resourceName);
    }
    getResource$(resourceName) {
        return this.localizations$.pipe(map(res => res.get(resourceName)));
    }
    /**
     * Returns localized text with the given interpolation parameters in current language.
     * @param key Localization key to replace with localized text
     * @param interpolateParams Values to intepolate.
     */
    instant(key, ...interpolateParams) {
        return this.getLocalization(this.configState.getAll(), key, ...interpolateParams);
    }
    localize(resourceName, key, defaultValue) {
        return this.configState.getOne$('localization').pipe(map(createLocalizer), map(localize => localize(resourceName, key, defaultValue)));
    }
    localizeSync(resourceName, key, defaultValue) {
        const localization = this.configState.getOne('localization');
        return createLocalizer(localization)(resourceName, key, defaultValue);
    }
    localizeWithFallback(resourceNames, keys, defaultValue) {
        return this.configState.getOne$('localization').pipe(map(createLocalizerWithFallback), map(localizeWithFallback => localizeWithFallback(resourceNames, keys, defaultValue)));
    }
    localizeWithFallbackSync(resourceNames, keys, defaultValue) {
        const localization = this.configState.getOne('localization');
        return createLocalizerWithFallback(localization)(resourceNames, keys, defaultValue);
    }
    getLocalization(state, key, ...interpolateParams) {
        if (!key)
            key = '';
        let defaultValue;
        if (typeof key !== 'string') {
            defaultValue = key.defaultValue;
            key = key.key;
        }
        const keys = key.split('::');
        const warn = (message) => {
            if (isDevMode)
                console.warn(message);
        };
        if (keys.length < 2) {
            warn('The localization source separator (::) not found.');
            return defaultValue || key;
        }
        if (!state.localization)
            return defaultValue || keys[1];
        const sourceName = keys[0] || state.localization.defaultResourceName;
        const sourceKey = keys[1];
        if (sourceName === '_') {
            return defaultValue || sourceKey;
        }
        if (!sourceName) {
            warn('Localization source name is not specified and the defaultResourceName was not defined!');
            return defaultValue || sourceKey;
        }
        const source = this.localizations$.value.get(sourceName);
        if (!source) {
            warn('Could not find localization source: ' + sourceName);
            return defaultValue || sourceKey;
        }
        let localization = source[sourceKey];
        if (typeof localization === 'undefined') {
            return defaultValue || sourceKey;
        }
        interpolateParams = interpolateParams.filter(params => params != null);
        if (localization)
            localization = interpolate(localization, interpolateParams);
        if (typeof localization !== 'string')
            localization = '';
        return localization || defaultValue || key;
    }
}
LocalizationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LocalizationService, deps: [{ token: SessionStateService }, { token: i0.Injector }, { token: LocalizationService, optional: true, skipSelf: true }, { token: ConfigStateService }], target: i0.ɵɵFactoryTarget.Injectable });
LocalizationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LocalizationService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LocalizationService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: SessionStateService }, { type: i0.Injector }, { type: LocalizationService, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: ConfigStateService }]; } });

function findRoute(routesService, path) {
    const node = routesService.find(route => route.path === path);
    return node || path === '/'
        ? node
        : findRoute(routesService, path.split('/').slice(0, -1).join('/') || '/');
}
function getRoutePath(router, url = router.url) {
    const emptyGroup = { segments: [] };
    const primaryGroup = router.parseUrl(url).root.children[PRIMARY_OUTLET];
    return '/' + (primaryGroup || emptyGroup).segments.map(({ path }) => path).join('/');
}
function reloadRoute(router, ngZone) {
    const { shouldReuseRoute } = router.routeReuseStrategy;
    const setRouteReuse = (reuse) => {
        router.routeReuseStrategy.shouldReuseRoute = reuse;
    };
    setRouteReuse(() => false);
    router.navigated = false;
    ngZone.run(async () => {
        await router.navigateByUrl(router.url).catch(noop);
        setRouteReuse(shouldReuseRoute);
    });
}

class ReplaceableComponentsService {
    constructor(ngZone, router) {
        this.ngZone = ngZone;
        this.router = router;
        this.store = new InternalStore([]);
    }
    get replaceableComponents$() {
        return this.store.sliceState(state => state);
    }
    get replaceableComponents() {
        return this.store.state;
    }
    get onUpdate$() {
        return this.store.sliceUpdate(state => state);
    }
    add(replaceableComponent, reload) {
        const replaceableComponents = [...this.store.state];
        const index = replaceableComponents.findIndex(component => component.key === replaceableComponent.key);
        if (index > -1) {
            replaceableComponents[index] = replaceableComponent;
        }
        else {
            replaceableComponents.push(replaceableComponent);
        }
        this.store.set(replaceableComponents);
        if (reload)
            reloadRoute(this.router, this.ngZone);
    }
    get(replaceableComponentKey) {
        return this.replaceableComponents.find(component => component.key === replaceableComponentKey);
    }
    get$(replaceableComponentKey) {
        return this.replaceableComponents$.pipe(map(components => components.find(component => component.key === replaceableComponentKey)));
    }
}
ReplaceableComponentsService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ReplaceableComponentsService, deps: [{ token: i0.NgZone }, { token: i1$1.Router }], target: i0.ɵɵFactoryTarget.Injectable });
ReplaceableComponentsService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ReplaceableComponentsService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ReplaceableComponentsService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: i1$1.Router }]; } });

const NavigationEvent = {
    Cancel: NavigationCancel,
    End: NavigationEnd,
    Error: NavigationError,
    Start: NavigationStart,
};
class RouterEvents {
    constructor(router) {
        this.router = router;
    }
    getEvents(...eventTypes) {
        const filterRouterEvents = (event) => eventTypes.some(type => event instanceof type);
        return this.router.events.pipe(filter(filterRouterEvents));
    }
    getNavigationEvents(...navigationEventKeys) {
        const filterNavigationEvents = (event) => navigationEventKeys.some(key => event instanceof NavigationEvent[key]);
        return this.router.events.pipe(filter(filterNavigationEvents));
    }
    getAllEvents() {
        return this.router.events;
    }
    getAllNavigationEvents() {
        const keys = Object.keys(NavigationEvent);
        return this.getNavigationEvents(...keys);
    }
}
RouterEvents.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RouterEvents, deps: [{ token: i1$1.Router }], target: i0.ɵɵFactoryTarget.Injectable });
RouterEvents.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RouterEvents, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RouterEvents, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i1$1.Router }]; } });

function pushValueTo(array) {
    return (element) => {
        array.push(element);
        return array;
    };
}

/* eslint-disable @typescript-eslint/ban-types */
class BaseTreeNode {
    constructor(props) {
        this.children = [];
        this.isLeaf = true;
        Object.assign(this, props);
    }
    static create(props) {
        return new BaseTreeNode(props);
    }
}
function createTreeFromList(list, keySelector, parentKeySelector, valueMapper) {
    const map = createMapFromList(list, keySelector, valueMapper);
    const tree = [];
    list.forEach(row => {
        const id = keySelector(row);
        const parentId = parentKeySelector(row);
        const node = map.get(id);
        if (!node)
            return;
        if (parentId) {
            const parent = map.get(parentId);
            if (!parent)
                return;
            parent.children.push(node);
            parent.isLeaf = false;
            node.parent = parent;
        }
        else {
            tree.push(node);
        }
    });
    return tree;
}
function createMapFromList(list, keySelector, valueMapper) {
    const map = new Map();
    list.forEach(row => map.set(keySelector(row), valueMapper(row)));
    return map;
}
function createTreeNodeFilterCreator(key, mapperFn) {
    return (search) => {
        const regex = new RegExp('.*' + search + '.*', 'i');
        return function collectNodes(nodes, matches = []) {
            for (const node of nodes) {
                if (regex.test(mapperFn(node[key])))
                    matches.push(node);
                if (node.children.length)
                    collectNodes(node.children, matches);
            }
            return matches;
        };
    };
}

class PermissionService {
    constructor(configState) {
        this.configState = configState;
    }
    getGrantedPolicy$(key) {
        return this.getStream().pipe(map(grantedPolicies => this.isPolicyGranted(key, grantedPolicies)));
    }
    getGrantedPolicy(key) {
        const policies = this.getSnapshot();
        return this.isPolicyGranted(key, policies);
    }
    filterItemsByPolicy(items) {
        const policies = this.getSnapshot();
        return items.filter(item => !item.requiredPolicy || this.isPolicyGranted(item.requiredPolicy, policies));
    }
    filterItemsByPolicy$(items) {
        return this.getStream().pipe(map(policies => items.filter(item => !item.requiredPolicy || this.isPolicyGranted(item.requiredPolicy, policies))));
    }
    isPolicyGranted(key, grantedPolicies) {
        if (!key)
            return true;
        const orRegexp = /\|\|/g;
        const andRegexp = /&&/g;
        // TODO: Allow combination of ANDs & ORs
        if (orRegexp.test(key)) {
            const keys = key.split('||').filter(Boolean);
            if (keys.length < 2)
                return false;
            return keys.some(k => this.getPolicy(k.trim(), grantedPolicies));
        }
        else if (andRegexp.test(key)) {
            const keys = key.split('&&').filter(Boolean);
            if (keys.length < 2)
                return false;
            return keys.every(k => this.getPolicy(k.trim(), grantedPolicies));
        }
        return this.getPolicy(key, grantedPolicies);
    }
    getStream() {
        return this.configState.getAll$().pipe(map(this.mapToPolicies));
    }
    getSnapshot() {
        return this.mapToPolicies(this.configState.getAll());
    }
    mapToPolicies(applicationConfiguration) {
        return applicationConfiguration?.auth?.grantedPolicies || {};
    }
    getPolicy(key, grantedPolicies) {
        return grantedPolicies[key] || false;
    }
}
PermissionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: PermissionService, deps: [{ token: ConfigStateService }], target: i0.ɵɵFactoryTarget.Injectable });
PermissionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: PermissionService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: PermissionService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: ConfigStateService }]; } });

// eslint-disable-next-line @typescript-eslint/ban-types
class AbstractTreeService {
    constructor() {
        this._flat$ = new BehaviorSubject([]);
        this._tree$ = new BehaviorSubject([]);
        this._visible$ = new BehaviorSubject([]);
    }
    get flat() {
        return this._flat$.value;
    }
    get flat$() {
        return this._flat$.asObservable();
    }
    get tree() {
        return this._tree$.value;
    }
    get tree$() {
        return this._tree$.asObservable();
    }
    get visible() {
        return this._visible$.value;
    }
    get visible$() {
        return this._visible$.asObservable();
    }
    createTree(items) {
        return createTreeFromList(items, item => item[this.id], item => item[this.parentId], item => BaseTreeNode.create(item));
    }
    filterWith(setOrMap) {
        return this._flat$.value.filter(item => !setOrMap.has(item[this.id]));
    }
    findItemsToRemove(set) {
        return this._flat$.value.reduce((acc, item) => {
            if (!acc.has(item[this.parentId]))
                return acc;
            const childSet = new Set([item[this.id]]);
            const children = this.findItemsToRemove(childSet);
            return new Set([...acc, ...children]);
        }, set);
    }
    publish(flatItems, visibleItems) {
        this._flat$.next(flatItems);
        this._tree$.next(this.createTree(flatItems));
        this._visible$.next(this.createTree(visibleItems));
        return flatItems;
    }
    add(items) {
        const map = new Map();
        items.forEach(item => map.set(item[this.id], item));
        const flatItems = this.filterWith(map);
        map.forEach(pushValueTo(flatItems));
        flatItems.sort(this.sort);
        const visibleItems = flatItems.filter(item => !this.hide(item));
        return this.publish(flatItems, visibleItems);
    }
    find(predicate, tree = this.tree) {
        return tree.reduce((acc, node) => (acc ? acc : predicate(node) ? node : this.find(predicate, node.children)), null);
    }
    patch(identifier, props) {
        const flatItems = this._flat$.value;
        const index = flatItems.findIndex(item => item[this.id] === identifier);
        if (index < 0)
            return false;
        flatItems[index] = { ...flatItems[index], ...props };
        flatItems.sort(this.sort);
        const visibleItems = flatItems.filter(item => !this.hide(item));
        return this.publish(flatItems, visibleItems);
    }
    refresh() {
        return this.add([]);
    }
    remove(identifiers) {
        const set = new Set();
        identifiers.forEach(id => set.add(id));
        const setToRemove = this.findItemsToRemove(set);
        const flatItems = this.filterWith(setToRemove);
        const visibleItems = flatItems.filter(item => !this.hide(item));
        return this.publish(flatItems, visibleItems);
    }
    search(params, tree = this.tree) {
        const searchKeys = Object.keys(params);
        return tree.reduce((acc, node) => acc
            ? acc
            : searchKeys.every(key => node[key] === params[key])
                ? node
                : this.search(params, node.children), null);
    }
}
class AbstractNavTreeService extends AbstractTreeService {
    constructor(injector) {
        super();
        this.injector = injector;
        this.id = 'name';
        this.parentId = 'parentName';
        this.hide = (item) => item.invisible || !this.isGranted(item);
        this.sort = (a, b) => {
            if (!Number.isInteger(a.order))
                return 1;
            if (!Number.isInteger(b.order))
                return -1;
            return a.order - b.order;
        };
        const configState = this.injector.get(ConfigStateService);
        this.subscription = configState
            .createOnUpdateStream(state => state)
            .subscribe(() => this.refresh());
        this.permissionService = injector.get(PermissionService);
    }
    isGranted({ requiredPolicy }) {
        return this.permissionService.getGrantedPolicy(requiredPolicy);
    }
    hasChildren(identifier) {
        const node = this.find(item => item[this.id] === identifier);
        return Boolean(node?.children?.length);
    }
    hasInvisibleChild(identifier) {
        const node = this.find(item => item[this.id] === identifier);
        return node?.children?.some(child => child.invisible);
    }
    /* istanbul ignore next */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
}
AbstractNavTreeService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbstractNavTreeService, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
AbstractNavTreeService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbstractNavTreeService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbstractNavTreeService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });
class RoutesService extends AbstractNavTreeService {
}
RoutesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RoutesService, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
RoutesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RoutesService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RoutesService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class SubscriptionService {
    constructor() {
        this.subscription = new Subscription();
    }
    get isClosed() {
        return this.subscription.closed;
    }
    addOne(source$, nextOrObserver, error) {
        const subscription = source$.subscribe(nextOrObserver, error);
        this.subscription.add(subscription);
        return subscription;
    }
    closeAll() {
        this.subscription.unsubscribe();
    }
    closeOne(subscription) {
        this.removeOne(subscription);
        subscription.unsubscribe();
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    removeOne(subscription) {
        if (!subscription)
            return;
        this.subscription.remove(subscription);
    }
    reset() {
        this.subscription.unsubscribe();
        this.subscription = new Subscription();
    }
}
SubscriptionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: SubscriptionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
SubscriptionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: SubscriptionService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: SubscriptionService, decorators: [{
            type: Injectable
        }] });

class DynamicLayoutComponent {
    constructor(injector, localizationService, replaceableComponents, subscription, routerEvents, dynamicLayoutComponent) {
        this.localizationService = localizationService;
        this.replaceableComponents = replaceableComponents;
        this.subscription = subscription;
        this.routerEvents = routerEvents;
        // TODO: Consider a shared enum (eThemeSharedComponents) for known layouts
        this.layouts = new Map([
            ['application', 'Theme.ApplicationLayoutComponent'],
            ['account', 'Theme.AccountLayoutComponent'],
            ['empty', 'Theme.EmptyLayoutComponent'],
        ]);
        this.isLayoutVisible = true;
        if (dynamicLayoutComponent) {
            if (isDevMode)
                console.warn('DynamicLayoutComponent must be used only in AppComponent.');
            return;
        }
        this.route = injector.get(ActivatedRoute);
        this.router = injector.get(Router);
        this.routes = injector.get(RoutesService);
        this.checkLayoutOnNavigationEnd();
        this.listenToLanguageChange();
    }
    checkLayoutOnNavigationEnd() {
        const navigationEnd$ = this.routerEvents.getNavigationEvents('End');
        this.subscription.addOne(navigationEnd$, () => this.getLayout());
    }
    getLayout() {
        let expectedLayout = (this.route.snapshot.data || {}).layout;
        if (!expectedLayout) {
            let node = findRoute(this.routes, getRoutePath(this.router));
            node = { parent: node };
            while (node.parent) {
                node = node.parent;
                if (node.layout) {
                    expectedLayout = node.layout;
                    break;
                }
            }
        }
        if (!expectedLayout)
            expectedLayout = "empty" /* empty */;
        if (this.layoutKey === expectedLayout)
            return;
        const key = this.layouts.get(expectedLayout);
        this.layout = this.getComponent(key)?.component;
        this.layoutKey = expectedLayout;
    }
    listenToLanguageChange() {
        this.subscription.addOne(this.localizationService.languageChange$, () => {
            this.isLayoutVisible = false;
            setTimeout(() => (this.isLayoutVisible = true), 0);
        });
    }
    getComponent(key) {
        return this.replaceableComponents.get(key);
    }
}
DynamicLayoutComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: DynamicLayoutComponent, deps: [{ token: i0.Injector }, { token: LocalizationService }, { token: ReplaceableComponentsService }, { token: SubscriptionService }, { token: RouterEvents }, { token: DynamicLayoutComponent, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Component });
DynamicLayoutComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.6", type: DynamicLayoutComponent, selector: "abp-dynamic-layout", providers: [SubscriptionService], ngImport: i0, template: ` <ng-container *ngIf="isLayoutVisible" [ngComponentOutlet]="layout"></ng-container> `, isInline: true, directives: [{ type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i5.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModuleFactory"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: DynamicLayoutComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-dynamic-layout',
                    template: ` <ng-container *ngIf="isLayoutVisible" [ngComponentOutlet]="layout"></ng-container> `,
                    providers: [SubscriptionService],
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: LocalizationService }, { type: ReplaceableComponentsService }, { type: SubscriptionService }, { type: RouterEvents }, { type: DynamicLayoutComponent, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }]; } });

class ReplaceableRouteContainerComponent {
    constructor(route, replaceableComponents, subscription) {
        this.route = route;
        this.replaceableComponents = replaceableComponents;
        this.subscription = subscription;
    }
    ngOnInit() {
        this.defaultComponent = this.route.snapshot.data.replaceableComponent.defaultComponent;
        this.componentKey = this.route.snapshot.data.replaceableComponent.key;
        const component$ = this.replaceableComponents
            .get$(this.componentKey)
            .pipe(distinctUntilChanged());
        this.subscription.addOne(component$, (res = {}) => {
            this.externalComponent = res.component;
        });
    }
}
ReplaceableRouteContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ReplaceableRouteContainerComponent, deps: [{ token: i1$1.ActivatedRoute }, { token: ReplaceableComponentsService }, { token: SubscriptionService }], target: i0.ɵɵFactoryTarget.Component });
ReplaceableRouteContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.6", type: ReplaceableRouteContainerComponent, selector: "abp-replaceable-route-container", providers: [SubscriptionService], ngImport: i0, template: `
    <ng-container *ngComponentOutlet="externalComponent || defaultComponent"></ng-container>
  `, isInline: true, directives: [{ type: i5.NgComponentOutlet, selector: "[ngComponentOutlet]", inputs: ["ngComponentOutlet", "ngComponentOutletInjector", "ngComponentOutletContent", "ngComponentOutletNgModuleFactory"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ReplaceableRouteContainerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-replaceable-route-container',
                    template: `
    <ng-container *ngComponentOutlet="externalComponent || defaultComponent"></ng-container>
  `,
                    providers: [SubscriptionService],
                }]
        }], ctorParameters: function () { return [{ type: i1$1.ActivatedRoute }, { type: ReplaceableComponentsService }, { type: SubscriptionService }]; } });

class RouterOutletComponent {
}
RouterOutletComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RouterOutletComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
RouterOutletComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.6", type: RouterOutletComponent, selector: "abp-router-outlet", ngImport: i0, template: ` <router-outlet></router-outlet> `, isInline: true, directives: [{ type: i1$1.RouterOutlet, selector: "router-outlet", outputs: ["activate", "deactivate", "attach", "detach"], exportAs: ["outlet"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RouterOutletComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'abp-router-outlet',
                    template: ` <router-outlet></router-outlet> `,
                }]
        }] });

// Different locales from .NET
// Key is .NET locale, value is Angular locale
const differentLocales = {
    aa: 'en',
    'aa-DJ': 'en',
    'aa-ER': 'en',
    'aa-ET': 'en',
    'af-ZA': 'af',
    'agq-CM': 'agq',
    'ak-GH': 'ak',
    'am-ET': 'am',
    'ar-001': 'ar',
    arn: 'en',
    'arn-CL': 'en',
    'as-IN': 'as',
    'asa-TZ': 'asa',
    'ast-ES': 'ast',
    'az-Cyrl-AZ': 'az-Cyrl',
    'az-Latn-AZ': 'az-Latn',
    ba: 'ru',
    'ba-RU': 'ru',
    'bas-CM': 'bas',
    'be-BY': 'be',
    'bem-ZM': 'bem',
    'bez-TZ': 'bez',
    'bg-BG': 'bg',
    bin: 'en',
    'bin-NG': 'en',
    'bm-Latn': 'bm',
    'bm-Latn-ML': 'bm',
    'bn-BD': 'bn',
    'bo-CN': 'bo',
    'br-FR': 'br',
    'brx-IN': 'brx',
    'bs-Cyrl-BA': 'bs-Cyrl',
    'bs-Latn-BA': 'bs-Latn',
    byn: 'en',
    'byn-ER': 'en',
    'ca-ES': 'ca',
    'ca-ES-valencia': 'ca-ES-VALENCIA',
    'ce-RU': 'ce',
    'cgg-UG': 'cgg',
    'chr-Cher': 'chr',
    'chr-Cher-US': 'chr',
    co: 'en',
    'co-FR': 'fr',
    'cs-CZ': 'cs',
    'cu-RU': 'cu',
    'cy-GB': 'cy',
    'da-DK': 'da',
    'dav-KE': 'dav',
    'de-DE': 'de',
    'dje-NE': 'dje',
    'dsb-DE': 'dsb',
    'dua-CM': 'dua',
    dv: 'en',
    'dv-MV': 'en',
    'dyo-SN': 'dyo',
    'dz-BT': 'dz',
    'ebu-KE': 'ebu',
    'ee-GH': 'ee',
    'el-GR': 'el',
    'en-029': 'en',
    'en-ID': 'en',
    'en-US': 'en',
    'eo-001': 'en',
    'es-ES': 'es',
    'et-EE': 'et',
    'eu-ES': 'eu',
    'ewo-CM': 'ewo',
    'fa-IR': 'fa',
    'ff-Latn-SN': 'ff-Latn',
    'ff-NG': 'ff',
    'fi-FI': 'fi',
    'fil-PH': 'fil',
    'fo-FO': 'fo',
    'fr-029': 'fr',
    'fr-FR': 'fr',
    'fur-IT': 'fur',
    'fy-NL': 'fy',
    'ga-IE': 'ga',
    'gd-GB': 'gd',
    'gl-ES': 'gl',
    gn: 'en',
    'gn-PY': 'en',
    'gsw-CH': 'gsw',
    'gu-IN': 'gu',
    'guz-KE': 'guz',
    'gv-IM': 'gv',
    'ha-Latn': 'ha',
    'ha-Latn-GH': 'ha-GH',
    'ha-Latn-NE': 'ha-NE',
    'ha-Latn-NG': 'ha',
    'haw-US': 'haw',
    'he-IL': 'he',
    'hi-IN': 'hi',
    'hr-HR': 'hr',
    'hsb-DE': 'hsb',
    'hu-HU': 'hu',
    'hy-AM': 'hy',
    'ia-001': 'ia',
    'ia-FR': 'ia',
    ibb: 'en',
    'ibb-NG': 'en',
    'id-ID': 'id',
    'ig-NG': 'ig',
    'ii-CN': 'ii',
    'is-IS': 'is',
    'it-IT': 'it',
    iu: 'en',
    'iu-Cans': 'en',
    'iu-Cans-CA': 'en',
    'iu-Latn': 'en',
    'iu-Latn-CA': 'en',
    'ja-JP': 'ja',
    'jgo-CM': 'jgo',
    'jmc-TZ': 'jmc',
    'jv-Java': 'jv',
    'jv-Java-ID': 'jv',
    'jv-Latn': 'jv',
    'jv-Latn-ID': 'jv',
    'ka-GE': 'ka',
    'kab-DZ': 'kab',
    'kam-KE': 'kam',
    'kde-TZ': 'kde',
    'kea-CV': 'kea',
    'khq-ML': 'khq',
    'ki-KE': 'ki',
    'kk-KZ': 'kk',
    'kkj-CM': 'kkj',
    'kl-GL': 'kl',
    'kln-KE': 'kln',
    'km-KH': 'km',
    'kn-IN': 'kn',
    'ko-KR': 'ko',
    'kok-IN': 'kok',
    kr: 'en',
    'kr-NG': 'en',
    'ks-Arab': 'ks',
    'ks-Arab-IN': 'ks',
    'ks-Deva': 'ks',
    'ks-Deva-IN': 'ks',
    'ksb-TZ': 'ksb',
    'ksf-CM': 'ksf',
    'ksh-DE': 'ksh',
    'ku-Arab': 'ku',
    'ku-Arab-IQ': 'ku',
    'ku-Arab-IR': 'ku',
    'kw-GB': 'kw',
    'ky-KG': 'ky',
    la: 'en',
    'la-001': 'en',
    'lag-TZ': 'lag',
    'lb-LU': 'lb',
    'lg-UG': 'lg',
    'lkt-US': 'lkt',
    'ln-CD': 'ln',
    'lo-LA': 'lo',
    'lrc-IR': 'lrc',
    'lt-LT': 'lt',
    'lu-CD': 'lu',
    'luo-KE': 'luo',
    'luy-KE': 'luy',
    'lv-LV': 'lv',
    'mas-KE': 'mas',
    'mer-KE': 'mer',
    'mfe-MU': 'mfe',
    'mg-MG': 'mg',
    'mgh-MZ': 'mgh',
    'mgo-CM': 'mgo',
    'mi-NZ': 'mi',
    'mk-MK': 'mk',
    'ml-IN': 'ml',
    'mn-Cyrl': 'mn',
    'mn-MN': 'mn',
    'mn-Mong': 'mn',
    'mn-Mong-CN': 'mn',
    'mn-Mong-MN': 'mn',
    mni: 'en',
    'mni-IN': 'en',
    moh: 'en',
    'moh-CA': 'en',
    'mr-IN': 'mr',
    'ms-MY': 'ms',
    'mt-MT': 'mt',
    'mua-CM': 'mua',
    'my-MM': 'my',
    'mzn-IR': 'mzn',
    'naq-NA': 'naq',
    'nb-NO': 'nb',
    'nd-ZW': 'nd',
    'ne-NP': 'ne',
    'nl-NL': 'nl',
    'nmg-CM': 'ngm',
    'nn-NO': 'nn',
    'nnh-CM': 'nnh',
    no: 'en',
    nqo: 'en',
    'nqo-GN': 'en',
    nr: 'en',
    'nr-ZA': 'en',
    nso: 'en',
    'nso-ZA': 'en',
    'nus-SS': 'nus',
    'nyn-UG': 'nyn',
    oc: 'en',
    'oc-FR': 'fr',
    'om-ET': 'om',
    'or-IN': 'or',
    'os-GE': 'os',
    'pa-Arab-PK': 'pa-Arab',
    'pa-IN': 'pa',
    pap: 'en',
    'pap-029': 'en',
    'pl-PL': 'pl',
    'prg-001': 'prg',
    prs: 'en',
    'prs-AF': 'en',
    'ps-AF': 'ps',
    'pt-BR': 'pt',
    quc: 'en',
    'quc-Latn': 'en',
    'quc-Latn-GT': 'en',
    quz: 'en',
    'quz-BO': 'en',
    'quz-EC': 'en',
    'quz-PE': 'en',
    'rm-CH': 'rm',
    'rn-BI': 'rn',
    'ro-RO': 'ro',
    'rof-TZ': 'rof',
    'ru-RU': 'ru',
    'rw-RW': 'rw',
    'rwk-TZ': 'rwk',
    sa: 'en',
    'sa-IN': 'en',
    'sah-RU': 'sah',
    'saq-KE': 'saq',
    'sbp-TZ': 'en',
    'sd-Arab': 'sd',
    'sd-Arab-PK': 'sd',
    'sd-Deva': 'sd',
    'sd-Deva-IN': 'sd',
    'se-NO': 'se',
    'seh-MZ': 'seh',
    'ses-ML': 'ses',
    'sg-CF': 'sg',
    'shi-Latn-MA': 'shi-Latn',
    'shi-Tfng-MA': 'shi-Tfng',
    'si-LK': 'si',
    'sk-SK': 'sk',
    'sl-SI': 'sl',
    sma: 'en',
    'sma-NO': 'en',
    'sma-SE': 'en',
    smj: 'en',
    'smj-NO': 'en',
    'smj-SE': 'en',
    'smn-FI': 'en',
    sms: 'en',
    'sms-FI': 'en',
    'sn-Latn': 'sn',
    'sn-Latn-ZW': 'sn',
    'so-SO': 'so',
    'sq-AL': 'so',
    'sr-Cyrl-RS': 'sr-Cryl',
    'sr-Latn-RS': 'sr-Latn',
    ss: 'en',
    'ss-SZ': 'en',
    'ss-ZA': 'en',
    ssy: 'en',
    'ssy-ER': 'en',
    st: 'en',
    'st-LS': 'en',
    'st-ZA': 'en',
    'sv-SE': 'sv',
    'sw-TZ': 'sw',
    syr: 'en',
    'syr-SY': 'en',
    'ta-IN': 'ta',
    'te-IN': 'te',
    'teo-UG': 'teo',
    'tg-Cyrl': 'tg',
    'tg-Cyrl-TJ': 'tg',
    'th-TH': 'th',
    'ti-ET': 'ti',
    tig: 'en',
    'tig-ER': 'en',
    'tk-TM': 'tk',
    tn: 'en',
    'tn-BW': 'en',
    'tn-ZA': 'en',
    'to-TO': 'to',
    'tr-TR': 'tr',
    ts: 'en',
    'ts-ZA': 'en',
    'tt-RU': 'tt',
    'twq-NE': 'twq',
    'tzm-Arab': 'tzm',
    'tzm-Arab-MA': 'tzm',
    'tzm-Latn': 'tzm',
    'tzm-Latn-DZ': 'tzm',
    'tzm-Latn-MA': 'tzm',
    'tzm-Tfng': 'tzm',
    'tzm-Tfng-MA': 'tzm',
    'ug-CN': 'ug',
    'uk-UA': 'uk',
    'ur-PK': 'ur',
    'uz-Arab-AF': 'uz-Arab',
    'uz-Cyrl-UZ': 'uz-Cyrl',
    'uz-Latn-UZ': 'uz-Latn',
    'vai-Latn-LR': 'vai-Latn',
    'vai-Vaii-LR': 'vai-Vaii',
    ve: 'en',
    've-ZA': 'en',
    'vi-VN': 'vi',
    'vo-001': 'vo',
    'vun-TZ': 'vun',
    'wae-CH': 'wae',
    wal: 'en',
    'wal-ET': 'en',
    'wo-SN': 'wo',
    'xh-ZA': 'xh',
    'xog-UG': 'xog',
    'yav-CM': 'yav',
    'yi-001': 'yi',
    'yo-NG': 'yo',
    'zgh-Tfng': 'zgh',
    'zgh-Tfng-MA': 'zgh',
    'zh-CN': 'zh',
    'zh-HK': 'zh',
    'zh-MO': 'zh',
    'zh-SG': 'zh',
    'zh-TW': 'zh',
    'zu-ZA': 'zu',
};

class AutofocusDirective {
    constructor(elRef) {
        this.elRef = elRef;
        this._delay = 0;
    }
    set delay(val) {
        this._delay = Number(val) || 0;
    }
    get delay() {
        return this._delay;
    }
    ngAfterViewInit() {
        setTimeout(() => this.elRef.nativeElement.focus(), this.delay);
    }
}
AutofocusDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AutofocusDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
AutofocusDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.6", type: AutofocusDirective, selector: "[autofocus]", inputs: { delay: ["autofocus", "delay"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AutofocusDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[autofocus]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { delay: [{
                type: Input,
                args: ['autofocus']
            }] } });

class InputEventDebounceDirective {
    constructor(el, subscription) {
        this.el = el;
        this.subscription = subscription;
        this.debounce = 300;
        this.debounceEvent = new EventEmitter();
    }
    ngOnInit() {
        const input$ = fromEvent(this.el.nativeElement, 'input').pipe(debounceTime(this.debounce));
        this.subscription.addOne(input$, (event) => {
            this.debounceEvent.emit(event);
        });
    }
}
InputEventDebounceDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: InputEventDebounceDirective, deps: [{ token: i0.ElementRef }, { token: SubscriptionService }], target: i0.ɵɵFactoryTarget.Directive });
InputEventDebounceDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.6", type: InputEventDebounceDirective, selector: "[input.debounce]", inputs: { debounce: "debounce" }, outputs: { debounceEvent: "input.debounce" }, providers: [SubscriptionService], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: InputEventDebounceDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[input.debounce]',
                    providers: [SubscriptionService],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: SubscriptionService }]; }, propDecorators: { debounce: [{
                type: Input
            }], debounceEvent: [{
                type: Output,
                args: ['input.debounce']
            }] } });

class AbpForContext {
    constructor($implicit, index, count, list) {
        this.$implicit = $implicit;
        this.index = index;
        this.count = count;
        this.list = list;
    }
}
class RecordView {
    constructor(record, view) {
        this.record = record;
        this.view = view;
    }
}
class ForDirective {
    constructor(tempRef, vcRef, differs) {
        this.tempRef = tempRef;
        this.vcRef = vcRef;
        this.differs = differs;
    }
    get compareFn() {
        return this.compareBy || compare;
    }
    get trackByFn() {
        return this.trackBy || ((index, item) => item.id || index);
    }
    iterateOverAppliedOperations(changes) {
        const rw = [];
        changes.forEachOperation((record, previousIndex, currentIndex) => {
            if (record.previousIndex == null) {
                const view = this.vcRef.createEmbeddedView(this.tempRef, new AbpForContext(null, -1, -1, this.items), currentIndex);
                rw.push(new RecordView(record, view));
            }
            else if (currentIndex == null) {
                this.vcRef.remove(previousIndex);
            }
            else {
                const view = this.vcRef.get(previousIndex);
                this.vcRef.move(view, currentIndex);
                rw.push(new RecordView(record, view));
            }
        });
        for (let i = 0, l = rw.length; i < l; i++) {
            rw[i].view.context.$implicit = rw[i].record.item;
        }
    }
    iterateOverAttachedViews(changes) {
        for (let i = 0, l = this.vcRef.length; i < l; i++) {
            const viewRef = this.vcRef.get(i);
            viewRef.context.index = i;
            viewRef.context.count = l;
            viewRef.context.list = this.items;
        }
        changes.forEachIdentityChange((record) => {
            const viewRef = this.vcRef.get(record.currentIndex);
            viewRef.context.$implicit = record.item;
        });
    }
    projectItems(items) {
        if (!items.length && this.emptyRef) {
            this.vcRef.clear();
            this.vcRef.createEmbeddedView(this.emptyRef).rootNodes;
            this.isShowEmptyRef = true;
            this.differ = null;
            return;
        }
        if (this.emptyRef && this.isShowEmptyRef) {
            this.vcRef.clear();
            this.isShowEmptyRef = false;
        }
        if (!this.differ && items) {
            this.differ = this.differs.find(items).create(this.trackByFn);
        }
        if (this.differ) {
            const changes = this.differ.diff(items);
            if (changes) {
                this.iterateOverAppliedOperations(changes);
                this.iterateOverAttachedViews(changes);
            }
        }
    }
    sortItems(items) {
        if (this.orderBy) {
            items.sort((a, b) => a[this.orderBy] > b[this.orderBy] ? 1 : a[this.orderBy] < b[this.orderBy] ? -1 : 0);
        }
        else {
            items.sort();
        }
    }
    ngOnChanges() {
        let items = clone(this.items);
        if (!Array.isArray(items))
            return;
        const compareFn = this.compareFn;
        if (typeof this.filterBy !== 'undefined' &&
            typeof this.filterVal !== 'undefined' &&
            this.filterVal !== '') {
            items = items.filter(item => compareFn(item[this.filterBy], this.filterVal));
        }
        switch (this.orderDir) {
            case 'ASC':
                this.sortItems(items);
                this.projectItems(items);
                break;
            case 'DESC':
                this.sortItems(items);
                items.reverse();
                this.projectItems(items);
                break;
            default:
                this.projectItems(items);
        }
    }
}
ForDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ForDirective, deps: [{ token: i0.TemplateRef }, { token: i0.ViewContainerRef }, { token: i0.IterableDiffers }], target: i0.ɵɵFactoryTarget.Directive });
ForDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.6", type: ForDirective, selector: "[abpFor]", inputs: { items: ["abpForOf", "items"], orderBy: ["abpForOrderBy", "orderBy"], orderDir: ["abpForOrderDir", "orderDir"], filterBy: ["abpForFilterBy", "filterBy"], filterVal: ["abpForFilterVal", "filterVal"], trackBy: ["abpForTrackBy", "trackBy"], compareBy: ["abpForCompareBy", "compareBy"], emptyRef: ["abpForEmptyRef", "emptyRef"] }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ForDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpFor]',
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: i0.ViewContainerRef }, { type: i0.IterableDiffers }]; }, propDecorators: { items: [{
                type: Input,
                args: ['abpForOf']
            }], orderBy: [{
                type: Input,
                args: ['abpForOrderBy']
            }], orderDir: [{
                type: Input,
                args: ['abpForOrderDir']
            }], filterBy: [{
                type: Input,
                args: ['abpForFilterBy']
            }], filterVal: [{
                type: Input,
                args: ['abpForFilterVal']
            }], trackBy: [{
                type: Input,
                args: ['abpForTrackBy']
            }], compareBy: [{
                type: Input,
                args: ['abpForCompareBy']
            }], emptyRef: [{
                type: Input,
                args: ['abpForEmptyRef']
            }] } });

class FormSubmitDirective {
    constructor(formGroupDirective, host, cdRef, subscription) {
        this.formGroupDirective = formGroupDirective;
        this.host = host;
        this.cdRef = cdRef;
        this.subscription = subscription;
        this.debounce = 200;
        this.markAsDirtyWhenSubmit = true;
        this.ngSubmit = new EventEmitter();
        this.executedNgSubmit = false;
    }
    ngOnInit() {
        this.subscription.addOne(this.formGroupDirective.ngSubmit, () => {
            if (this.markAsDirtyWhenSubmit) {
                this.markAsDirty();
            }
            this.executedNgSubmit = true;
        });
        const keyup$ = fromEvent(this.host.nativeElement, 'keyup').pipe(debounceTime(this.debounce), filter(event => !(event.target instanceof HTMLTextAreaElement)), filter((event) => event && event.key === 'Enter'));
        this.subscription.addOne(keyup$, () => {
            if (!this.executedNgSubmit) {
                this.host.nativeElement.dispatchEvent(new Event('submit', { bubbles: true, cancelable: true }));
            }
            this.executedNgSubmit = false;
        });
    }
    markAsDirty() {
        const { form } = this.formGroupDirective;
        setDirty(form.controls);
        form.markAsDirty();
        this.cdRef.detectChanges();
    }
}
FormSubmitDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: FormSubmitDirective, deps: [{ token: i1$2.FormGroupDirective, self: true }, { token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: SubscriptionService }], target: i0.ɵɵFactoryTarget.Directive });
FormSubmitDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.6", type: FormSubmitDirective, selector: "form[ngSubmit][formGroup]", inputs: { debounce: "debounce", notValidateOnSubmit: "notValidateOnSubmit", markAsDirtyWhenSubmit: "markAsDirtyWhenSubmit" }, outputs: { ngSubmit: "ngSubmit" }, providers: [SubscriptionService], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: FormSubmitDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: 'form[ngSubmit][formGroup]',
                    providers: [SubscriptionService],
                }]
        }], ctorParameters: function () { return [{ type: i1$2.FormGroupDirective, decorators: [{
                    type: Self
                }] }, { type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: SubscriptionService }]; }, propDecorators: { debounce: [{
                type: Input
            }], notValidateOnSubmit: [{
                type: Input
            }], markAsDirtyWhenSubmit: [{
                type: Input
            }], ngSubmit: [{
                type: Output
            }] } });
function setDirty(controls) {
    if (Array.isArray(controls)) {
        controls.forEach(group => {
            setDirty(group.controls);
        });
        return;
    }
    Object.keys(controls).forEach(key => {
        controls[key].markAsDirty();
        controls[key].updateValueAndValidity();
    });
}

class InitDirective {
    constructor(elRef) {
        this.elRef = elRef;
        this.init = new EventEmitter();
    }
    ngAfterViewInit() {
        this.init.emit(this.elRef);
    }
}
InitDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: InitDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
InitDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.6", type: InitDirective, selector: "[abpInit]", outputs: { init: "abpInit" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: InitDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[abpInit]' }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { init: [{
                type: Output,
                args: ['abpInit']
            }] } });

class PermissionDirective {
    constructor(templateRef, vcRef, permissionService, cdRef) {
        this.templateRef = templateRef;
        this.vcRef = vcRef;
        this.permissionService = permissionService;
        this.cdRef = cdRef;
        this.runChangeDetection = true;
    }
    check() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        this.subscription = this.permissionService
            .getGrantedPolicy$(this.condition || '')
            .pipe(distinctUntilChanged())
            .subscribe(isGranted => {
            this.vcRef.clear();
            if (isGranted)
                this.vcRef.createEmbeddedView(this.templateRef);
            if (this.runChangeDetection) {
                this.cdRef.detectChanges();
            }
            else {
                this.cdRef.markForCheck();
            }
        });
    }
    ngOnDestroy() {
        if (this.subscription)
            this.subscription.unsubscribe();
    }
    ngOnChanges() {
        this.check();
    }
}
PermissionDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: PermissionDirective, deps: [{ token: i0.TemplateRef, optional: true }, { token: i0.ViewContainerRef }, { token: PermissionService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
PermissionDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.6", type: PermissionDirective, selector: "[abpPermission]", inputs: { condition: ["abpPermission", "condition"], runChangeDetection: ["abpPermissionRunChangeDetection", "runChangeDetection"] }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: PermissionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpPermission]',
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }, { type: i0.ViewContainerRef }, { type: PermissionService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { condition: [{
                type: Input,
                args: ['abpPermission']
            }], runChangeDetection: [{
                type: Input,
                args: ['abpPermissionRunChangeDetection']
            }] } });

class ReplaceableTemplateDirective {
    constructor(injector, templateRef, cfRes, vcRef, replaceableComponents, subscription) {
        this.injector = injector;
        this.templateRef = templateRef;
        this.cfRes = cfRes;
        this.vcRef = vcRef;
        this.replaceableComponents = replaceableComponents;
        this.subscription = subscription;
        this.providedData = {
            inputs: {},
            outputs: {},
        };
        this.context = {};
        this.defaultComponentSubscriptions = {};
        this.initialized = false;
        this.context = {
            initTemplate: (ref) => {
                this.resetDefaultComponent();
                this.defaultComponentRef = ref;
                this.setDefaultComponentInputs();
            },
        };
    }
    ngOnInit() {
        const component$ = this.replaceableComponents
            .get$(this.data.componentKey)
            .pipe(filter((res = {}) => !this.initialized || !compare(res.component, this.externalComponent)));
        this.subscription.addOne(component$, (res = {}) => {
            this.vcRef.clear();
            this.externalComponent = res.component;
            if (this.defaultComponentRef) {
                this.resetDefaultComponent();
            }
            if (res.component) {
                this.setProvidedData();
                const customInjector = Injector.create({
                    providers: [{ provide: 'REPLACEABLE_DATA', useValue: this.providedData }],
                    parent: this.injector,
                });
                this.vcRef.createComponent(this.cfRes.resolveComponentFactory(res.component), 0, customInjector);
            }
            else {
                this.vcRef.createEmbeddedView(this.templateRef, this.context);
            }
            this.initialized = true;
        });
    }
    ngOnChanges(changes) {
        if (changes?.data?.currentValue?.inputs && this.defaultComponentRef) {
            this.setDefaultComponentInputs();
        }
    }
    setDefaultComponentInputs() {
        if (!this.defaultComponentRef || (!this.data.inputs && !this.data.outputs))
            return;
        if (this.data.inputs) {
            for (const key in this.data.inputs) {
                if (Object.prototype.hasOwnProperty.call(this.data.inputs, key)) {
                    if (!compare(this.defaultComponentRef[key], this.data.inputs[key].value)) {
                        this.defaultComponentRef[key] = this.data.inputs[key].value;
                    }
                }
            }
        }
        if (this.data.outputs) {
            for (const key in this.data.outputs) {
                if (Object.prototype.hasOwnProperty.call(this.data.outputs, key)) {
                    if (!this.defaultComponentSubscriptions[key]) {
                        this.defaultComponentSubscriptions[key] = this.defaultComponentRef[key].subscribe((value) => {
                            this.data.outputs?.[key](value);
                        });
                    }
                }
            }
        }
    }
    setProvidedData() {
        this.providedData = { outputs: {}, ...this.data, inputs: {} };
        if (!this.data.inputs)
            return;
        Object.defineProperties(this.providedData.inputs, {
            ...Object.keys(this.data.inputs).reduce((acc, key) => ({
                ...acc,
                [key]: {
                    enumerable: true,
                    configurable: true,
                    get: () => this.data.inputs[key]?.value,
                    ...(this.data.inputs[key]?.twoWay && {
                        set: (newValue) => {
                            this.data.inputs[key].value = newValue;
                            this.data.outputs[`${key}Change`](newValue);
                        },
                    }),
                },
            }), {}),
        });
    }
    resetDefaultComponent() {
        Object.keys(this.defaultComponentSubscriptions).forEach(key => {
            this.defaultComponentSubscriptions[key].unsubscribe();
        });
        this.defaultComponentSubscriptions = {};
        this.defaultComponentRef = null;
    }
}
ReplaceableTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ReplaceableTemplateDirective, deps: [{ token: i0.Injector }, { token: i0.TemplateRef }, { token: i0.ComponentFactoryResolver }, { token: i0.ViewContainerRef }, { token: ReplaceableComponentsService }, { token: SubscriptionService }], target: i0.ɵɵFactoryTarget.Directive });
ReplaceableTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.6", type: ReplaceableTemplateDirective, selector: "[abpReplaceableTemplate]", inputs: { data: ["abpReplaceableTemplate", "data"] }, providers: [SubscriptionService], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ReplaceableTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[abpReplaceableTemplate]',
                    providers: [SubscriptionService],
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: i0.TemplateRef }, { type: i0.ComponentFactoryResolver }, { type: i0.ViewContainerRef }, { type: ReplaceableComponentsService }, { type: SubscriptionService }]; }, propDecorators: { data: [{
                type: Input,
                args: ['abpReplaceableTemplate']
            }] } });

class StopPropagationDirective {
    constructor(el, subscription) {
        this.el = el;
        this.subscription = subscription;
        this.stopPropEvent = new EventEmitter();
    }
    ngOnInit() {
        this.subscription.addOne(fromEvent(this.el.nativeElement, 'click'), (event) => {
            event.stopPropagation();
            this.stopPropEvent.emit(event);
        });
    }
}
StopPropagationDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: StopPropagationDirective, deps: [{ token: i0.ElementRef }, { token: SubscriptionService }], target: i0.ɵɵFactoryTarget.Directive });
StopPropagationDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.6", type: StopPropagationDirective, selector: "[click.stop]", outputs: { stopPropEvent: "click.stop" }, providers: [SubscriptionService], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: StopPropagationDirective, decorators: [{
            type: Directive,
            args: [{
                    // eslint-disable-next-line @angular-eslint/directive-selector
                    selector: '[click.stop]',
                    providers: [SubscriptionService],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: SubscriptionService }]; }, propDecorators: { stopPropEvent: [{
                type: Output,
                args: ['click.stop']
            }] } });

class OAuthConfigurationHandler {
    constructor(oAuthService, environmentService, options) {
        this.oAuthService = oAuthService;
        this.environmentService = environmentService;
        this.options = options;
        this.listenToSetEnvironment();
    }
    listenToSetEnvironment() {
        this.environmentService
            .createOnUpdateStream(state => state)
            .pipe(map(environment => environment.oAuthConfig), filter(config => !compare(config, this.options.environment.oAuthConfig)))
            .subscribe(config => {
            this.oAuthService.configure(config);
        });
    }
}
OAuthConfigurationHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: OAuthConfigurationHandler, deps: [{ token: i1$3.OAuthService }, { token: EnvironmentService }, { token: CORE_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });
OAuthConfigurationHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: OAuthConfigurationHandler, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: OAuthConfigurationHandler, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$3.OAuthService }, { type: EnvironmentService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [CORE_OPTIONS]
                }] }]; } });

class RoutesHandler {
    constructor(routes, router) {
        this.routes = routes;
        this.router = router;
        this.addRoutes();
    }
    addRoutes() {
        this.router?.config?.forEach(({ path = '', data }) => {
            if (!data?.routes)
                return;
            if (Array.isArray(data.routes)) {
                this.routes.add(data.routes);
                return;
            }
            const routes = flatRoutes([{ path, ...data.routes }], { path: '' });
            this.routes.add(routes);
        });
    }
}
RoutesHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RoutesHandler, deps: [{ token: RoutesService }, { token: i1$1.Router, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
RoutesHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RoutesHandler, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RoutesHandler, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: RoutesService }, { type: i1$1.Router, decorators: [{
                    type: Optional
                }] }]; } });
function flatRoutes(routes, parent) {
    if (!routes)
        return [];
    return routes.reduce((acc, route) => {
        const { children, ...current } = {
            ...route,
            parentName: parent.name,
            path: (parent.path + '/' + route.path).replace(/\/\//g, '/'),
        };
        acc.push(current, ...flatRoutes(children, current));
        return acc;
    }, []);
}

function getPathName(url) {
    const { pathname } = new URL(url, window.location.origin);
    return pathname;
}
class WebHttpUrlEncodingCodec {
    encodeKey(k) {
        return encodeURIComponent(k);
    }
    encodeValue(v) {
        return encodeURIComponent(v);
    }
    decodeKey(k) {
        return decodeURIComponent(k);
    }
    decodeValue(v) {
        return decodeURIComponent(v);
    }
}

const LOADER_DELAY = new InjectionToken('LOADER_DELAY');

class HttpWaitService {
    constructor(injector) {
        this.store = new InternalStore({
            requests: [],
            filteredRequests: [],
        });
        this.destroy$ = new Subject();
        this.delay = injector.get(LOADER_DELAY, 500);
    }
    getLoading() {
        return !!this.applyFilter(this.store.state.requests).length;
    }
    getLoading$() {
        return this.store
            .sliceState(({ requests }) => requests)
            .pipe(map(requests => !!this.applyFilter(requests).length), switchMap(condition => condition
            ? this.delay === 0
                ? of(true)
                : timer(this.delay).pipe(mapTo(true), takeUntil(this.destroy$))
            : of(false)), tap(() => this.destroy$.next()));
    }
    updateLoading$() {
        return this.store.sliceUpdate(({ requests }) => !!this.applyFilter(requests).length);
    }
    clearLoading() {
        this.store.patch({ requests: [] });
    }
    addRequest(request) {
        this.store.patch({ requests: [...this.store.state.requests, request] });
    }
    deleteRequest(request) {
        const requests = this.store.state.requests.filter(r => r !== request);
        this.store.patch({ requests });
    }
    addFilter(request) {
        const requests = Array.isArray(request) ? request : [request];
        const filteredRequests = [
            ...this.store.state.filteredRequests.filter(f => !requests.some(r => this.isSameRequest(f, r))),
            ...requests,
        ];
        this.store.patch({ filteredRequests });
    }
    removeFilter(request) {
        const requests = Array.isArray(request) ? request : [request];
        const filteredRequests = this.store.state.filteredRequests.filter(f => !requests.some(r => this.isSameRequest(f, r)));
        this.store.patch({ filteredRequests });
    }
    applyFilter(requests) {
        const { filteredRequests } = this.store.state;
        return requests.filter(({ method, url }) => !filteredRequests.find(filteredRequest => this.isSameRequest(filteredRequest, { method, endpoint: getPathName(url) })));
    }
    isSameRequest(filteredRequest, request) {
        const { method, endpoint } = filteredRequest;
        return endpoint === request.endpoint && method === request.method;
    }
}
HttpWaitService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: HttpWaitService, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
HttpWaitService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: HttpWaitService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: HttpWaitService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });

const TENANT_KEY = new InjectionToken('TENANT_KEY');

class ApiInterceptor {
    constructor(oAuthService, sessionState, httpWaitService, tenantKey) {
        this.oAuthService = oAuthService;
        this.sessionState = sessionState;
        this.httpWaitService = httpWaitService;
        this.tenantKey = tenantKey;
    }
    intercept(request, next) {
        this.httpWaitService.addRequest(request);
        return next
            .handle(request.clone({
            setHeaders: this.getAdditionalHeaders(request.headers),
        }))
            .pipe(finalize(() => this.httpWaitService.deleteRequest(request)));
    }
    getAdditionalHeaders(existingHeaders) {
        const headers = {};
        const token = this.oAuthService.getAccessToken();
        if (!existingHeaders?.has('Authorization') && token) {
            headers['Authorization'] = `Bearer ${token}`;
        }
        const lang = this.sessionState.getLanguage();
        if (!existingHeaders?.has('Accept-Language') && lang) {
            headers['Accept-Language'] = lang;
        }
        const tenant = this.sessionState.getTenant();
        if (!existingHeaders?.has(this.tenantKey) && tenant?.id) {
            headers[this.tenantKey] = tenant.id;
        }
        return headers;
    }
}
ApiInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ApiInterceptor, deps: [{ token: i1$3.OAuthService }, { token: SessionStateService }, { token: HttpWaitService }, { token: TENANT_KEY }], target: i0.ɵɵFactoryTarget.Injectable });
ApiInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ApiInterceptor, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ApiInterceptor, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$3.OAuthService }, { type: SessionStateService }, { type: HttpWaitService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TENANT_KEY]
                }] }]; } });

class LocalizationPipe {
    constructor(localization) {
        this.localization = localization;
    }
    transform(value = '', ...interpolateParams) {
        const params = interpolateParams.reduce((acc, val) => {
            if (!acc) {
                return val;
            }
            if (!val) {
                return acc;
            }
            return Array.isArray(val) ? [...acc, ...val] : [...acc, val];
        }, []) || [];
        return this.localization.instant(value, ...params);
    }
}
LocalizationPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LocalizationPipe, deps: [{ token: LocalizationService }], target: i0.ɵɵFactoryTarget.Pipe });
LocalizationPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LocalizationPipe, name: "abpLocalization" });
LocalizationPipe.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LocalizationPipe });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LocalizationPipe, decorators: [{
            type: Injectable
        }, {
            type: Pipe,
            args: [{
                    name: 'abpLocalization',
                }]
        }], ctorParameters: function () { return [{ type: LocalizationService }]; } });

class LocalizationModule {
}
LocalizationModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LocalizationModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
LocalizationModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LocalizationModule, declarations: [LocalizationPipe], exports: [LocalizationPipe] });
LocalizationModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LocalizationModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LocalizationModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [LocalizationPipe],
                    declarations: [LocalizationPipe],
                }]
        }] });

class SortPipe {
    transform(value, sortOrder = 'asc', sortKey) {
        sortOrder = sortOrder && sortOrder.toLowerCase();
        if (!value || (sortOrder !== 'asc' && sortOrder !== 'desc'))
            return value;
        let numberArray = [];
        let stringArray = [];
        if (!sortKey) {
            numberArray = value.filter(item => typeof item === 'number').sort();
            stringArray = value.filter(item => typeof item === 'string').sort();
        }
        else {
            numberArray = value
                .filter(item => typeof item[sortKey] === 'number')
                .sort((a, b) => a[sortKey] - b[sortKey]);
            stringArray = value
                .filter(item => typeof item[sortKey] === 'string')
                .sort((a, b) => {
                if (a[sortKey] < b[sortKey])
                    return -1;
                else if (a[sortKey] > b[sortKey])
                    return 1;
                else
                    return 0;
            });
        }
        const sorted = [
            ...numberArray,
            ...stringArray,
            ...value.filter(item => typeof (sortKey ? item[sortKey] : item) !== 'number' &&
                typeof (sortKey ? item[sortKey] : item) !== 'string'),
        ];
        return sortOrder === 'asc' ? sorted : sorted.reverse();
    }
}
SortPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: SortPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe });
SortPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: SortPipe, name: "abpSort" });
SortPipe.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: SortPipe });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: SortPipe, decorators: [{
            type: Injectable
        }, {
            type: Pipe,
            args: [{
                    name: 'abpSort',
                }]
        }] });

const INJECTOR_PIPE_DATA_TOKEN = new InjectionToken('INJECTOR_PIPE_DATA_TOKEN');
class ToInjectorPipe {
    constructor(injector) {
        this.injector = injector;
    }
    transform(value, token = INJECTOR_PIPE_DATA_TOKEN, name = 'ToInjectorPipe') {
        return Injector.create({
            providers: [
                {
                    provide: token,
                    useValue: value,
                },
            ],
            parent: this.injector,
            name,
        });
    }
}
ToInjectorPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ToInjectorPipe, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Pipe });
ToInjectorPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ToInjectorPipe, name: "toInjector" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ToInjectorPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'toInjector',
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });

const COOKIE_LANGUAGE_KEY = new InjectionToken('COOKIE_LANGUAGE_KEY', {
    factory: () => '.AspNetCore.Culture',
});

function setLanguageToCookie(injector) {
    return () => {
        const sessionState = injector.get(SessionStateService);
        const document = injector.get(DOCUMENT);
        const cookieLanguageKey = injector.get(COOKIE_LANGUAGE_KEY);
        sessionState.getLanguage$().subscribe(language => {
            const cookieValue = encodeURIComponent(`c=${language}|uic=${language}`);
            document.cookie = `${cookieLanguageKey}=${cookieValue}`;
        });
    };
}
const CookieLanguageProvider = {
    provide: APP_INITIALIZER,
    useFactory: setLanguageToCookie,
    deps: [Injector],
    multi: true,
};

class LocaleId extends String {
    constructor(localizationService) {
        super();
        this.localizationService = localizationService;
    }
    toString() {
        const { currentLang } = this.localizationService;
        return differentLocales[currentLang] || currentLang;
    }
    valueOf() {
        return this.toString();
    }
}
const LocaleProvider = {
    provide: LOCALE_ID,
    useClass: LocaleId,
    deps: [LocalizationService],
};

const cookieKey = 'rememberMe';
const storageKey = 'passwordFlow';
function pipeToLogin(params, injector) {
    const configState = injector.get(ConfigStateService);
    const router = injector.get(Router);
    return pipe(switchMap(() => configState.refreshAppState()), tap(() => {
        setRememberMe(params.rememberMe);
        if (params.redirectUrl)
            router.navigate([params.redirectUrl]);
    }));
}
function setTokenResponseToStorage(injector, tokenRes) {
    const { access_token, refresh_token, scope: grantedScopes, expires_in } = tokenRes;
    const storage = injector.get(OAuthStorage);
    storage.setItem('access_token', access_token);
    storage.setItem('refresh_token', refresh_token);
    storage.setItem('access_token_stored_at', '' + Date.now());
    if (grantedScopes) {
        storage.setItem('granted_scopes', JSON.stringify(grantedScopes.split(' ')));
    }
    if (expires_in) {
        const expiresInMilliSeconds = expires_in * 1000;
        const now = new Date();
        const expiresAt = now.getTime() + expiresInMilliSeconds;
        storage.setItem('expires_at', '' + expiresAt);
    }
}
function setRememberMe(remember) {
    removeRememberMe();
    localStorage.setItem(storageKey, 'true');
    document.cookie = `${cookieKey}=true; path=/${remember ? ' ;expires=Fri, 31 Dec 9999 23:59:59 GMT' : ''}`;
}
function removeRememberMe() {
    localStorage.removeItem(storageKey);
    document.cookie = cookieKey + '= ; path=/; expires = Thu, 01 Jan 1970 00:00:00 GMT';
}

const oAuthStorage = localStorage;
class AuthFlowStrategy {
    constructor(injector) {
        this.injector = injector;
        this.catchError = err => {
            this.httpErrorReporter.reportError(err);
            return of(null);
        };
        this.httpErrorReporter = injector.get(HttpErrorReporterService);
        this.environment = injector.get(EnvironmentService);
        this.configState = injector.get(ConfigStateService);
        this.oAuthService = injector.get(OAuthService);
        this.sessionState = injector.get(SessionStateService);
        this.oAuthConfig = this.environment.getEnvironment().oAuthConfig;
        this.tenantKey = injector.get(TENANT_KEY);
        this.listenToOauthErrors();
    }
    async init() {
        const shouldClear = shouldStorageClear(this.environment.getEnvironment().oAuthConfig.clientId, oAuthStorage);
        if (shouldClear)
            clearOAuthStorage(oAuthStorage);
        this.oAuthService.configure(this.oAuthConfig);
        this.oAuthService.events
            .pipe(filter(event => event.type === 'token_refresh_error'))
            .subscribe(() => this.navigateToLogin());
        return this.oAuthService
            .loadDiscoveryDocument()
            .then(() => {
            if (this.oAuthService.hasValidAccessToken() || !this.oAuthService.getRefreshToken()) {
                return Promise.resolve();
            }
            return this.refreshToken();
        })
            .catch(this.catchError);
    }
    refreshToken() {
        return this.oAuthService.refreshToken().catch(() => clearOAuthStorage());
    }
    listenToOauthErrors() {
        this.oAuthService.events
            .pipe(filter(event => event instanceof OAuthErrorEvent), tap(() => clearOAuthStorage()), switchMap(() => this.configState.refreshAppState()))
            .subscribe();
    }
}
class AuthCodeFlowStrategy extends AuthFlowStrategy {
    constructor() {
        super(...arguments);
        this.isInternalAuth = false;
    }
    async init() {
        return super
            .init()
            .then(() => this.oAuthService.tryLogin().catch(noop))
            .then(() => this.oAuthService.setupAutomaticSilentRefresh({}, 'access_token'));
    }
    navigateToLogin(queryParams) {
        this.oAuthService.initCodeFlow('', this.getCultureParams(queryParams));
    }
    checkIfInternalAuth(queryParams) {
        this.oAuthService.initCodeFlow('', this.getCultureParams(queryParams));
        return false;
    }
    logout(queryParams) {
        return from(this.oAuthService.revokeTokenAndLogout(this.getCultureParams(queryParams)));
    }
    login(queryParams) {
        this.oAuthService.initCodeFlow('', this.getCultureParams(queryParams));
        return of(null);
    }
    getCultureParams(queryParams) {
        const lang = this.sessionState.getLanguage();
        const culture = { culture: lang, 'ui-culture': lang };
        return { ...(lang && culture), ...queryParams };
    }
}
class AuthPasswordFlowStrategy extends AuthFlowStrategy {
    constructor() {
        super(...arguments);
        this.isInternalAuth = true;
        this.cookieKey = 'rememberMe';
        this.storageKey = 'passwordFlow';
    }
    listenToTokenExpiration() {
        this.oAuthService.events
            .pipe(filter(event => event instanceof OAuthInfoEvent &&
            event.type === 'token_expires' &&
            event.info === 'access_token'))
            .subscribe(() => {
            if (this.oAuthService.getRefreshToken()) {
                this.refreshToken();
            }
            else {
                this.oAuthService.logOut();
                removeRememberMe();
                this.configState.refreshAppState().subscribe();
            }
        });
    }
    async init() {
        if (!getCookieValueByName(this.cookieKey) && localStorage.getItem(this.storageKey)) {
            this.oAuthService.logOut();
        }
        return super.init().then(() => this.listenToTokenExpiration());
    }
    navigateToLogin(queryParams) {
        const router = this.injector.get(Router);
        router.navigate(['/account/login'], { queryParams });
    }
    checkIfInternalAuth() {
        return true;
    }
    login(params) {
        const tenant = this.sessionState.getTenant();
        return from(this.oAuthService.fetchTokenUsingPasswordFlow(params.username, params.password, new HttpHeaders({ ...(tenant && tenant.id && { [this.tenantKey]: tenant.id }) }))).pipe(this.pipeToLogin(params));
    }
    pipeToLogin(params) {
        const router = this.injector.get(Router);
        return pipe(switchMap(() => this.configState.refreshAppState()), tap(() => {
            setRememberMe(params.rememberMe);
            if (params.redirectUrl)
                router.navigate([params.redirectUrl]);
        }));
    }
    logout(queryParams) {
        const router = this.injector.get(Router);
        return from(this.oAuthService.revokeTokenAndLogout(queryParams)).pipe(switchMap(() => this.configState.refreshAppState()), tap(() => {
            router.navigateByUrl('/');
            removeRememberMe();
        }));
    }
    refreshToken() {
        return this.oAuthService.refreshToken().catch(() => {
            clearOAuthStorage();
            removeRememberMe();
        });
    }
}
const AUTH_FLOW_STRATEGY = {
    Code(injector) {
        return new AuthCodeFlowStrategy(injector);
    },
    Password(injector) {
        return new AuthPasswordFlowStrategy(injector);
    },
};
function clearOAuthStorage(storage = oAuthStorage) {
    const keys = [
        'access_token',
        'id_token',
        'refresh_token',
        'nonce',
        'PKCE_verifier',
        'expires_at',
        'id_token_claims_obj',
        'id_token_expires_at',
        'id_token_stored_at',
        'access_token_stored_at',
        'granted_scopes',
        'session_state',
    ];
    keys.forEach(key => storage.removeItem(key));
}
function shouldStorageClear(clientId, storage) {
    const key = 'abpOAuthClientId';
    if (!storage.getItem(key)) {
        storage.setItem(key, clientId);
        return false;
    }
    const shouldClear = storage.getItem(key) !== clientId;
    if (shouldClear)
        storage.setItem(key, clientId);
    return shouldClear;
}
function getCookieValueByName(name) {
    const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
    return match ? match[2] : '';
}

Date.prototype.toLocalISOString = function () {
    const timezoneOffset = this.getTimezoneOffset();
    return new Date(this.getTime() - timezoneOffset * 60000).toISOString();
};

class AuthService {
    constructor(injector) {
        this.injector = injector;
    }
    get isInternalAuth() {
        return this.strategy.isInternalAuth;
    }
    async init() {
        const environmentService = this.injector.get(EnvironmentService);
        return environmentService
            .getEnvironment$()
            .pipe(map(env => env?.oAuthConfig), filter(oAuthConfig => !!oAuthConfig), tap(oAuthConfig => {
            this.strategy =
                oAuthConfig.responseType === 'code'
                    ? AUTH_FLOW_STRATEGY.Code(this.injector)
                    : AUTH_FLOW_STRATEGY.Password(this.injector);
        }), switchMap(() => from(this.strategy.init())), take(1))
            .toPromise();
    }
    logout(queryParams) {
        return this.strategy.logout(queryParams);
    }
    navigateToLogin(queryParams) {
        this.strategy.navigateToLogin(queryParams);
    }
    login(params) {
        return this.strategy.login(params);
    }
}
AuthService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AuthService, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
AuthService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AuthService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AuthService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });

const APP_INIT_ERROR_HANDLERS = new InjectionToken('APP_INIT_ERROR_HANDLERS');

function getRemoteEnv(injector, environment) {
    const environmentService = injector.get(EnvironmentService);
    const { remoteEnv } = environment;
    const { headers = {}, method = 'GET', url } = remoteEnv || {};
    if (!url)
        return Promise.resolve();
    const http = injector.get(HttpClient);
    const httpErrorReporter = injector.get(HttpErrorReporterService);
    return http
        .request(method, url, { headers })
        .pipe(catchError(err => {
        httpErrorReporter.reportError(err);
        return of(null);
    }), // TODO: Consider get handle function from a provider
    tap(env => environmentService.setState(mergeEnvironments(environment, env, remoteEnv))))
        .toPromise();
}
function mergeEnvironments(local, remote, config) {
    switch (config.mergeStrategy) {
        case 'deepmerge':
            return deepMerge(local, remote);
        case 'overwrite':
        case null:
        case undefined:
            return remote;
        default:
            return config.mergeStrategy(local, remote);
    }
}

class AbpTenantService {
    constructor(restService) {
        this.restService = restService;
        this.apiName = 'abp';
        this.findTenantById = (id, headers) => this.restService.request({
            method: 'GET',
            url: `/api/abp/multi-tenancy/tenants/by-id/${id}`,
            headers,
        }, { apiName: this.apiName });
        this.findTenantByName = (name, headers) => this.restService.request({
            method: 'GET',
            url: `/api/abp/multi-tenancy/tenants/by-name/${name}`,
            headers,
        }, { apiName: this.apiName });
    }
}
AbpTenantService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbpTenantService, deps: [{ token: RestService }], target: i0.ɵɵFactoryTarget.Injectable });
AbpTenantService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbpTenantService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbpTenantService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: RestService }]; } });

class MultiTenancyService {
    constructor(restService, sessionState, tenantService, configStateService, tenantKey) {
        this.restService = restService;
        this.sessionState = sessionState;
        this.tenantService = tenantService;
        this.configStateService = configStateService;
        this.tenantKey = tenantKey;
        this.domainTenant = null;
        this.isTenantBoxVisible = true;
        this.apiName = 'abp';
        this.setTenantToState = (tenant) => {
            this.sessionState.setTenant({ id: tenant.tenantId, name: tenant.name, isAvailable: true });
            return this.configStateService.refreshAppState().pipe(map(_ => tenant));
        };
    }
    setTenantByName(tenantName) {
        return this.tenantService
            .findTenantByName(tenantName, { [this.tenantKey]: '' })
            .pipe(switchMap(this.setTenantToState));
    }
    setTenantById(tenantId) {
        return this.tenantService
            .findTenantById(tenantId, { [this.tenantKey]: '' })
            .pipe(switchMap(this.setTenantToState));
    }
}
MultiTenancyService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MultiTenancyService, deps: [{ token: RestService }, { token: SessionStateService }, { token: AbpTenantService }, { token: ConfigStateService }, { token: TENANT_KEY }], target: i0.ɵɵFactoryTarget.Injectable });
MultiTenancyService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MultiTenancyService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: MultiTenancyService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: RestService }, { type: SessionStateService }, { type: AbpTenantService }, { type: ConfigStateService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TENANT_KEY]
                }] }]; } });

const tenancyPlaceholder = '{0}';
function getCurrentTenancyName(appBaseUrl) {
    if (appBaseUrl.charAt(appBaseUrl.length - 1) !== '/')
        appBaseUrl += '/';
    const parseTokens = createTokenParser(appBaseUrl);
    const token = tenancyPlaceholder.replace(/[}{]/g, '');
    return parseTokens(window.location.href)[token]?.[0];
}
function getCurrentTenancyNameFromUrl(tenantKey) {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(tenantKey);
}
async function parseTenantFromUrl(injector) {
    const environmentService = injector.get(EnvironmentService);
    const multiTenancyService = injector.get(MultiTenancyService);
    const baseUrl = environmentService.getEnvironment()?.application?.baseUrl || '';
    const tenancyName = getCurrentTenancyName(baseUrl);
    const hideTenantBox = () => {
        multiTenancyService.isTenantBoxVisible = false;
    };
    const setDomainTenant = (tenant) => {
        multiTenancyService.domainTenant = {
            id: tenant.tenantId,
            name: tenant.name,
            isAvailable: true,
        };
    };
    const setEnvironmentWithDomainTenant = (tenant) => {
        hideTenantBox();
        setDomainTenant(tenant);
    };
    if (tenancyName) {
        /**
         * We have to replace tenant name within the urls from environment,
         * because the code below will make a http request to find information about the domain tenant.
         * Before this request takes place, we need to replace placeholders aka "{0}".
         */
        replaceTenantNameWithinEnvironment(injector, tenancyName);
        return multiTenancyService
            .setTenantByName(tenancyName)
            .pipe(tap(setEnvironmentWithDomainTenant))
            .toPromise();
    }
    else {
        /**
         * If there is no tenant, we still have to clean up {0}. from baseUrl to avoid incorrect http requests.
         */
        replaceTenantNameWithinEnvironment(injector, '', tenancyPlaceholder + '.');
        const tenantIdFromQueryParams = getCurrentTenancyNameFromUrl(multiTenancyService.tenantKey);
        if (tenantIdFromQueryParams) {
            return multiTenancyService.setTenantById(tenantIdFromQueryParams).toPromise();
        }
    }
    return Promise.resolve();
}
function replaceTenantNameWithinEnvironment(injector, tenancyName, placeholder = tenancyPlaceholder) {
    const environmentService = injector.get(EnvironmentService);
    const environment = clone(environmentService.getEnvironment());
    if (environment.application.baseUrl) {
        environment.application.baseUrl = environment.application.baseUrl.replace(placeholder, tenancyName);
    }
    if (environment.oAuthConfig.redirectUri) {
        environment.oAuthConfig.redirectUri = environment.oAuthConfig.redirectUri.replace(placeholder, tenancyName);
    }
    environment.oAuthConfig.issuer = environment.oAuthConfig.issuer.replace(placeholder, tenancyName);
    Object.keys(environment.apis).forEach(api => {
        Object.keys(environment.apis[api]).forEach(key => {
            environment.apis[api][key] = environment.apis[api][key].replace(placeholder, tenancyName);
        });
    });
    return environmentService.setState(environment);
}

function getInitialData(injector) {
    const fn = async () => {
        const environmentService = injector.get(EnvironmentService);
        const configState = injector.get(ConfigStateService);
        const options = injector.get(CORE_OPTIONS);
        environmentService.setState(options.environment);
        await getRemoteEnv(injector, options.environment);
        await parseTenantFromUrl(injector);
        await injector.get(AuthService).init();
        if (options.skipGetAppConfiguration)
            return;
        return configState
            .refreshAppState()
            .pipe(tap(() => checkAccessToken(injector)), tap(() => {
            const currentTenant = configState.getOne('currentTenant');
            injector.get(SessionStateService).setTenant(currentTenant);
        }), catchError(error => {
            const appInitErrorHandlers = injector.get(APP_INIT_ERROR_HANDLERS, null);
            if (appInitErrorHandlers && appInitErrorHandlers.length) {
                appInitErrorHandlers.forEach(func => func(error));
            }
            return throwError(error);
        }))
            .toPromise();
    };
    return fn;
}
function checkAccessToken(injector) {
    const configState = injector.get(ConfigStateService);
    const oAuth = injector.get(OAuthService);
    if (oAuth.hasValidAccessToken() && !configState.getDeep('currentUser.id')) {
        clearOAuthStorage();
    }
}
function localeInitializer(injector) {
    const fn = () => {
        const sessionState = injector.get(SessionStateService);
        const { registerLocaleFn } = injector.get(CORE_OPTIONS);
        const lang = sessionState.getLanguage() || 'en';
        return new Promise((resolve, reject) => {
            registerLocaleFn(lang).then(module => {
                if (module?.default)
                    registerLocaleData(module.default);
                return resolve('resolved');
            }, reject);
        });
    };
    return fn;
}

class ContentProjectionService {
    constructor(injector) {
        this.injector = injector;
    }
    projectContent(projectionStrategy, injector = this.injector) {
        return projectionStrategy.injectContent(injector);
    }
}
ContentProjectionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ContentProjectionService, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
ContentProjectionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ContentProjectionService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ContentProjectionService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });

function getShortDateFormat(configStateService) {
    const dateTimeFormat = configStateService.getDeep('localization.currentCulture.dateTimeFormat');
    return dateTimeFormat.shortDatePattern;
}
function getShortTimeFormat(configStateService) {
    const dateTimeFormat = configStateService.getDeep('localization.currentCulture.dateTimeFormat');
    return dateTimeFormat.shortTimePattern.replace('tt', 'a');
}
function getShortDateShortTimeFormat(configStateService) {
    const dateTimeFormat = configStateService.getDeep('localization.currentCulture.dateTimeFormat');
    return `${dateTimeFormat.shortDatePattern} ${dateTimeFormat.shortTimePattern.replace('tt', 'a')}`;
}

class LazyModuleFactory extends NgModuleFactory {
    constructor(moduleWithProviders) {
        super();
        this.moduleWithProviders = moduleWithProviders;
    }
    get moduleType() {
        return this.moduleWithProviders.ngModule;
    }
    create(parentInjector) {
        const injector = Injector.create({
            parent: parentInjector,
            providers: this.moduleWithProviders.providers,
        });
        const compiler = injector.get(Compiler);
        const factory = compiler.compileModuleSync(this.moduleType);
        return factory.create(injector);
    }
}
function featuresFactory(configState, featureKeys, mapFn = features => features) {
    return configState.getFeatures$(featureKeys).pipe(filter(Boolean), map(mapFn));
}

function downloadBlob(blob, filename) {
    const blobUrl = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = blobUrl;
    link.download = filename;
    document.body.appendChild(link);
    link.dispatchEvent(new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
        view: window,
    }));
    document.body.removeChild(link);
}

function isNumber(value) {
    return value == Number(value);
}

function mapEnumToOptions(_enum) {
    const options = [];
    for (const member in _enum)
        if (!isNumber(member))
            options.push({
                key: member,
                value: _enum[member],
            });
    return options;
}

function uuid(a) {
    return a
        ? (a ^ ((Math.random() * 16) >> (a / 4))).toString(16)
        : ('' + 1e7 + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, uuid);
}
function generateHash(value) {
    let hashed = 0;
    let charCode;
    for (let i = 0; i < value.length; i++) {
        charCode = value.charCodeAt(i);
        hashed = (hashed << 5) - hashed + charCode;
        hashed |= 0;
    }
    return hashed;
}
function generatePassword(length = 8) {
    length = Math.min(Math.max(4, length), 128);
    const lowers = 'abcdefghijklmnopqrstuvwxyz';
    const uppers = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const numbers = '0123456789';
    const specials = '!@#$%&*()_+{}<>?[]./';
    const all = lowers + uppers + numbers + specials;
    const getRandom = (chrSet) => chrSet[Math.floor(Math.random() * chrSet.length)];
    const password = Array({ length });
    password[0] = getRandom(lowers);
    password[1] = getRandom(uppers);
    password[2] = getRandom(numbers);
    password[3] = getRandom(specials);
    for (let i = 4; i < length; i++) {
        password[i] = getRandom(all);
    }
    return password.sort(() => 0.5 - Math.random()).join('');
}

class CrossOriginStrategy {
    constructor(crossorigin, integrity) {
        this.crossorigin = crossorigin;
        this.integrity = integrity;
    }
    setCrossOrigin(element) {
        if (this.integrity)
            element.setAttribute('integrity', this.integrity);
        element.setAttribute('crossorigin', this.crossorigin);
    }
}
class NoCrossOriginStrategy extends CrossOriginStrategy {
    setCrossOrigin() { }
}
const CROSS_ORIGIN_STRATEGY = {
    Anonymous(integrity) {
        return new CrossOriginStrategy('anonymous', integrity);
    },
    UseCredentials(integrity) {
        return new CrossOriginStrategy('use-credentials', integrity);
    },
    None() {
        return new NoCrossOriginStrategy(null);
    },
};

class DomStrategy {
    constructor(target = document.head, position = 'beforeend') {
        this.target = target;
        this.position = position;
    }
    insertElement(element) {
        this.target.insertAdjacentElement(this.position, element);
    }
}
const DOM_STRATEGY = {
    AfterElement(element) {
        return new DomStrategy(element, 'afterend');
    },
    AppendToBody() {
        return new DomStrategy(document.body, 'beforeend');
    },
    AppendToHead() {
        return new DomStrategy(document.head, 'beforeend');
    },
    BeforeElement(element) {
        return new DomStrategy(element, 'beforebegin');
    },
    PrependToHead() {
        return new DomStrategy(document.head, 'afterbegin');
    },
};

function fromLazyLoad(element, domStrategy = DOM_STRATEGY.AppendToHead(), crossOriginStrategy = CROSS_ORIGIN_STRATEGY.Anonymous()) {
    crossOriginStrategy.setCrossOrigin(element);
    domStrategy.insertElement(element);
    return new Observable((observer) => {
        element.onload = (event) => {
            clearCallbacks(element);
            observer.next(event);
            observer.complete();
        };
        const handleError = createErrorHandler(observer, element);
        element.onerror = handleError;
        element.onabort = handleError;
        element.onemptied = handleError;
        element.onstalled = handleError;
        element.onsuspend = handleError;
        return () => {
            clearCallbacks(element);
            observer.complete();
        };
    });
}
function createErrorHandler(observer, element) {
    return function (event) {
        clearCallbacks(element);
        element.parentNode.removeChild(element);
        observer.error(event);
    };
}
function clearCallbacks(element) {
    element.onload = null;
    element.onerror = null;
    element.onabort = null;
    element.onemptied = null;
    element.onstalled = null;
    element.onsuspend = null;
}

class DomInsertionService {
    constructor() {
        this.inserted = new Set();
    }
    insertContent(contentStrategy) {
        const hash = generateHash(contentStrategy.content);
        if (this.inserted.has(hash))
            return;
        const element = contentStrategy.insertElement();
        this.inserted.add(hash);
        return element;
    }
    removeContent(element) {
        const hash = generateHash(element.textContent);
        this.inserted.delete(hash);
        element.parentNode.removeChild(element);
    }
    has(content) {
        const hash = generateHash(content);
        return this.inserted.has(hash);
    }
}
DomInsertionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: DomInsertionService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DomInsertionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: DomInsertionService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: DomInsertionService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class ResourceWaitService {
    constructor() {
        this.store = new InternalStore({ resources: new Set() });
    }
    getLoading() {
        return !!this.store.state.resources.size;
    }
    getLoading$() {
        return this.store.sliceState(({ resources }) => !!resources.size);
    }
    updateLoading$() {
        return this.store.sliceUpdate(({ resources }) => !!resources.size);
    }
    clearLoading() {
        this.store.patch({ resources: new Set() });
    }
    addResource(resource) {
        const resources = this.store.state.resources;
        resources.add(resource);
        this.store.patch({ resources });
    }
    deleteResource(resource) {
        const resources = this.store.state.resources;
        resources.delete(resource);
        this.store.patch({ resources });
    }
}
ResourceWaitService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ResourceWaitService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ResourceWaitService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ResourceWaitService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ResourceWaitService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class LazyLoadService {
    constructor(resourceWaitService) {
        this.resourceWaitService = resourceWaitService;
        this.loaded = new Map();
    }
    load(strategy, retryTimes, retryDelay) {
        if (this.loaded.has(strategy.path))
            return of(new CustomEvent('load'));
        this.resourceWaitService.addResource(strategy.path);
        return strategy.createStream().pipe(retryWhen(error$ => concat(error$.pipe(delay(retryDelay), take(retryTimes)), throwError(new CustomEvent('error')))), tap(() => {
            this.loaded.set(strategy.path, strategy.element);
            this.resourceWaitService.deleteResource(strategy.path);
        }), delay(100), shareReplay({ bufferSize: 1, refCount: true }));
    }
    remove(path) {
        const element = this.loaded.get(path);
        if (!element)
            return false;
        element.parentNode.removeChild(element);
        this.loaded.delete(path);
        return true;
    }
}
LazyLoadService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LazyLoadService, deps: [{ token: ResourceWaitService }], target: i0.ɵɵFactoryTarget.Injectable });
LazyLoadService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LazyLoadService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: LazyLoadService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: ResourceWaitService }]; } });

const LIST_QUERY_DEBOUNCE_TIME = new InjectionToken('LIST_QUERY_DEBOUNCE_TIME');

class ListService {
    constructor(injector) {
        this._filter = '';
        this._maxResultCount = 10;
        this._skipCount = 0;
        this._page = 0;
        this._sortKey = '';
        this._sortOrder = '';
        this._query$ = new ReplaySubject(1);
        this._isLoading$ = new BehaviorSubject(false);
        this.destroy$ = new Subject();
        this.get = () => {
            this.resetPageWhenUnchanged();
            this.next();
        };
        this.getWithoutPageReset = () => {
            this.next();
        };
        const delay = injector.get(LIST_QUERY_DEBOUNCE_TIME, 300);
        this.delay = delay ? debounceTime(delay) : tap();
        this.get();
    }
    set filter(value) {
        this._filter = value;
        this.get();
    }
    get filter() {
        return this._filter;
    }
    set maxResultCount(value) {
        this._maxResultCount = value;
        this.get();
    }
    get maxResultCount() {
        return this._maxResultCount;
    }
    set page(value) {
        if (value === this._page)
            return;
        this._page = value;
        this.get();
    }
    get page() {
        return this._page;
    }
    set sortKey(value) {
        this._sortKey = value;
        this.get();
    }
    get sortKey() {
        return this._sortKey;
    }
    set sortOrder(value) {
        this._sortOrder = value;
        this.get();
    }
    get sortOrder() {
        return this._sortOrder;
    }
    get query$() {
        return this._query$
            .asObservable()
            .pipe(this.delay, shareReplay({ bufferSize: 1, refCount: true }));
    }
    get isLoading$() {
        return this._isLoading$.asObservable();
    }
    hookToQuery(streamCreatorCallback) {
        return this.query$.pipe(tap(() => this._isLoading$.next(true)), switchMap(query => streamCreatorCallback(query).pipe(catchError(() => of(null)))), filter(Boolean), tap(() => this._isLoading$.next(false)), shareReplay({ bufferSize: 1, refCount: true }), takeUntil(this.destroy$));
    }
    ngOnDestroy() {
        this.destroy$.next();
    }
    resetPageWhenUnchanged() {
        const skipCount = this._page * this._maxResultCount;
        if (skipCount === this._skipCount) {
            this._page = 0;
            this._skipCount = 0;
        }
        else
            this._skipCount = skipCount;
    }
    next() {
        this._query$.next({
            filter: this._filter || undefined,
            maxResultCount: this._maxResultCount,
            skipCount: this._page * this._maxResultCount,
            sorting: this._sortOrder ? `${this._sortKey} ${this._sortOrder}` : undefined,
        });
    }
}
ListService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ListService, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
ListService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ListService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ListService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });

class RouterWaitService {
    constructor(routerEvents, injector) {
        this.routerEvents = routerEvents;
        this.store = new InternalStore({ loading: false });
        this.destroy$ = new Subject();
        this.delay = injector.get(LOADER_DELAY, 500);
        this.updateLoadingStatusOnNavigationEvents();
    }
    updateLoadingStatusOnNavigationEvents() {
        this.routerEvents
            .getAllNavigationEvents()
            .pipe(map(event => event instanceof NavigationStart), switchMap(condition => condition
            ? this.delay === 0
                ? of(true)
                : timer(this.delay || 0).pipe(mapTo(true), takeUntil(this.destroy$))
            : of(false)), tap(() => this.destroy$.next()))
            .subscribe(status => {
            this.setLoading(status);
        });
    }
    getLoading() {
        return this.store.state.loading;
    }
    getLoading$() {
        return this.store.sliceState(({ loading }) => loading);
    }
    updateLoading$() {
        return this.store.sliceUpdate(({ loading }) => loading);
    }
    setLoading(loading) {
        this.store.patch({ loading });
    }
}
RouterWaitService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RouterWaitService, deps: [{ token: RouterEvents }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
RouterWaitService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RouterWaitService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RouterWaitService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: RouterEvents }, { type: i0.Injector }]; } });

const trackBy = (key) => (_, item) => item[key];
const trackByDeep = (
// eslint-disable-next-line @typescript-eslint/ban-types
...keys) => (_, item) => keys.reduce((acc, key) => acc[key], item);
class TrackByService {
    constructor() {
        this.by = trackBy;
        this.byDeep = trackByDeep;
    }
}
TrackByService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: TrackByService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
TrackByService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: TrackByService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: TrackByService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

class ShortDateTimePipe extends DatePipe {
    constructor(configStateService, locale, defaultTimezone) {
        super(locale, defaultTimezone);
        this.configStateService = configStateService;
    }
    transform(value, timezone, locale) {
        const format = getShortDateShortTimeFormat(this.configStateService);
        return super.transform(value, format, timezone, locale);
    }
}
ShortDateTimePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ShortDateTimePipe, deps: [{ token: ConfigStateService }, { token: LOCALE_ID }, { token: DATE_PIPE_DEFAULT_TIMEZONE, optional: true }], target: i0.ɵɵFactoryTarget.Pipe });
ShortDateTimePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ShortDateTimePipe, name: "shortDateTime" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ShortDateTimePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'shortDateTime',
                    pure: true,
                }]
        }], ctorParameters: function () { return [{ type: ConfigStateService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DATE_PIPE_DEFAULT_TIMEZONE]
                }, {
                    type: Optional
                }] }]; } });

class ShortTimePipe extends DatePipe {
    constructor(configStateService, locale, defaultTimezone) {
        super(locale, defaultTimezone);
        this.configStateService = configStateService;
    }
    transform(value, timezone, locale) {
        const format = getShortTimeFormat(this.configStateService);
        return super.transform(value, format, timezone, locale);
    }
}
ShortTimePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ShortTimePipe, deps: [{ token: ConfigStateService }, { token: LOCALE_ID }, { token: DATE_PIPE_DEFAULT_TIMEZONE, optional: true }], target: i0.ɵɵFactoryTarget.Pipe });
ShortTimePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ShortTimePipe, name: "shortTime" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ShortTimePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'shortTime',
                    pure: true,
                }]
        }], ctorParameters: function () { return [{ type: ConfigStateService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DATE_PIPE_DEFAULT_TIMEZONE]
                }, {
                    type: Optional
                }] }]; } });

class ShortDatePipe extends DatePipe {
    constructor(configStateService, locale, defaultTimezone) {
        super(locale, defaultTimezone);
        this.configStateService = configStateService;
    }
    transform(value, timezone, locale) {
        const format = getShortDateFormat(this.configStateService);
        return super.transform(value, format, timezone, locale);
    }
}
ShortDatePipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ShortDatePipe, deps: [{ token: ConfigStateService }, { token: LOCALE_ID }, { token: DATE_PIPE_DEFAULT_TIMEZONE, optional: true }], target: i0.ɵɵFactoryTarget.Pipe });
ShortDatePipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ShortDatePipe, name: "shortDate" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: ShortDatePipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'shortDate',
                    pure: true,
                }]
        }], ctorParameters: function () { return [{ type: ConfigStateService }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [LOCALE_ID]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DATE_PIPE_DEFAULT_TIMEZONE]
                }, {
                    type: Optional
                }] }]; } });

function storageFactory() {
    return oAuthStorage;
}
/**
 * BaseCoreModule is the module that holds
 * all imports, declarations, exports, and entryComponents
 * but not the providers.
 * This module will be imported and exported by all others.
 */
class BaseCoreModule {
}
BaseCoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: BaseCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
BaseCoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: BaseCoreModule, declarations: [AbstractNgModelComponent,
        AutofocusDirective,
        DynamicLayoutComponent,
        ForDirective,
        FormSubmitDirective,
        InitDirective,
        InputEventDebounceDirective,
        PermissionDirective,
        ReplaceableRouteContainerComponent,
        ReplaceableTemplateDirective,
        RouterOutletComponent,
        SortPipe,
        StopPropagationDirective,
        ToInjectorPipe,
        ShortDateTimePipe,
        ShortTimePipe,
        ShortDatePipe], imports: [OAuthModule,
        CommonModule,
        HttpClientModule,
        FormsModule,
        ReactiveFormsModule,
        RouterModule,
        LocalizationModule], exports: [CommonModule,
        HttpClientModule,
        FormsModule,
        ReactiveFormsModule,
        RouterModule,
        LocalizationModule,
        AbstractNgModelComponent,
        AutofocusDirective,
        DynamicLayoutComponent,
        ForDirective,
        FormSubmitDirective,
        InitDirective,
        InputEventDebounceDirective,
        PermissionDirective,
        ReplaceableRouteContainerComponent,
        ReplaceableTemplateDirective,
        RouterOutletComponent,
        SortPipe,
        StopPropagationDirective,
        ToInjectorPipe,
        ShortDateTimePipe,
        ShortTimePipe,
        ShortDatePipe] });
BaseCoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: BaseCoreModule, providers: [LocalizationPipe], imports: [[
            OAuthModule,
            CommonModule,
            HttpClientModule,
            FormsModule,
            ReactiveFormsModule,
            RouterModule,
            LocalizationModule,
        ], CommonModule,
        HttpClientModule,
        FormsModule,
        ReactiveFormsModule,
        RouterModule,
        LocalizationModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: BaseCoreModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [
                        CommonModule,
                        HttpClientModule,
                        FormsModule,
                        ReactiveFormsModule,
                        RouterModule,
                        LocalizationModule,
                        AbstractNgModelComponent,
                        AutofocusDirective,
                        DynamicLayoutComponent,
                        ForDirective,
                        FormSubmitDirective,
                        InitDirective,
                        InputEventDebounceDirective,
                        PermissionDirective,
                        ReplaceableRouteContainerComponent,
                        ReplaceableTemplateDirective,
                        RouterOutletComponent,
                        SortPipe,
                        StopPropagationDirective,
                        ToInjectorPipe,
                        ShortDateTimePipe,
                        ShortTimePipe,
                        ShortDatePipe,
                    ],
                    imports: [
                        OAuthModule,
                        CommonModule,
                        HttpClientModule,
                        FormsModule,
                        ReactiveFormsModule,
                        RouterModule,
                        LocalizationModule,
                    ],
                    declarations: [
                        AbstractNgModelComponent,
                        AutofocusDirective,
                        DynamicLayoutComponent,
                        ForDirective,
                        FormSubmitDirective,
                        InitDirective,
                        InputEventDebounceDirective,
                        PermissionDirective,
                        ReplaceableRouteContainerComponent,
                        ReplaceableTemplateDirective,
                        RouterOutletComponent,
                        SortPipe,
                        StopPropagationDirective,
                        ToInjectorPipe,
                        ShortDateTimePipe,
                        ShortTimePipe,
                        ShortDatePipe,
                    ],
                    providers: [LocalizationPipe],
                }]
        }] });
/**
 * RootCoreModule is the module that will be used at root level
 * and it introduces imports useful at root level (e.g. NGXS)
 */
class RootCoreModule {
}
RootCoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RootCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
RootCoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RootCoreModule, imports: [BaseCoreModule, LocalizationModule,
        OAuthModule, i1.HttpClientXsrfModule], exports: [BaseCoreModule, LocalizationModule] });
RootCoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RootCoreModule, imports: [[
            BaseCoreModule,
            LocalizationModule,
            OAuthModule,
            HttpClientXsrfModule.withOptions({
                cookieName: 'XSRF-TOKEN',
                headerName: 'RequestVerificationToken',
            }),
        ], BaseCoreModule, LocalizationModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: RootCoreModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [BaseCoreModule, LocalizationModule],
                    imports: [
                        BaseCoreModule,
                        LocalizationModule,
                        OAuthModule,
                        HttpClientXsrfModule.withOptions({
                            cookieName: 'XSRF-TOKEN',
                            headerName: 'RequestVerificationToken',
                        }),
                    ],
                }]
        }] });
/**
 * CoreModule is the module that is publicly available
 */
class CoreModule {
    static forRoot(options = {}) {
        return {
            ngModule: RootCoreModule,
            providers: [
                OAuthModule.forRoot().providers,
                LocaleProvider,
                CookieLanguageProvider,
                {
                    provide: 'CORE_OPTIONS',
                    useValue: options,
                },
                {
                    provide: CORE_OPTIONS,
                    useFactory: coreOptionsFactory,
                    deps: ['CORE_OPTIONS'],
                },
                {
                    provide: HTTP_INTERCEPTORS,
                    useExisting: ApiInterceptor,
                    multi: true,
                },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [OAuthConfigurationHandler],
                    useFactory: noop,
                },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [Injector],
                    useFactory: getInitialData,
                },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [Injector],
                    useFactory: localeInitializer,
                },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [LocalizationService],
                    useFactory: noop,
                },
                {
                    provide: APP_INITIALIZER,
                    multi: true,
                    deps: [RoutesHandler],
                    useFactory: noop,
                },
                { provide: OAuthStorage, useFactory: storageFactory },
                { provide: TENANT_KEY, useValue: options.tenantKey || '__tenant' },
                {
                    provide: LOCALIZATIONS,
                    multi: true,
                    useValue: localizationContributor(options.localizations),
                    deps: [LocalizationService],
                },
            ],
        };
    }
    static forChild(options = {}) {
        return {
            ngModule: RootCoreModule,
            providers: [
                {
                    provide: LOCALIZATIONS,
                    multi: true,
                    useValue: localizationContributor(options.localizations),
                    deps: [LocalizationService],
                },
            ],
        };
    }
}
CoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: CoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: CoreModule, imports: [BaseCoreModule], exports: [BaseCoreModule] });
CoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: CoreModule, imports: [[BaseCoreModule], BaseCoreModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: CoreModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [BaseCoreModule],
                    imports: [BaseCoreModule],
                }]
        }] });

class AuthGuard {
    constructor(oauthService, authService) {
        this.oauthService = oauthService;
        this.authService = authService;
    }
    canActivate() {
        const hasValidAccessToken = this.oauthService.hasValidAccessToken();
        if (hasValidAccessToken) {
            return true;
        }
        this.authService.navigateToLogin();
        return false;
    }
}
AuthGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AuthGuard, deps: [{ token: i1$3.OAuthService }, { token: AuthService }], target: i0.ɵɵFactoryTarget.Injectable });
AuthGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AuthGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AuthGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$3.OAuthService }, { type: AuthService }]; } });

class PermissionGuard {
    constructor(router, routesService, permissionService, httpErrorReporter) {
        this.router = router;
        this.routesService = routesService;
        this.permissionService = permissionService;
        this.httpErrorReporter = httpErrorReporter;
    }
    canActivate(route, state) {
        let { requiredPolicy } = route.data || {};
        if (!requiredPolicy) {
            const routeFound = findRoute(this.routesService, getRoutePath(this.router, state.url));
            requiredPolicy = routeFound?.requiredPolicy;
        }
        if (!requiredPolicy)
            return of(true);
        return this.permissionService.getGrantedPolicy$(requiredPolicy).pipe(tap(access => {
            if (!access) {
                this.httpErrorReporter.reportError({ status: 403 });
            }
        }));
    }
}
PermissionGuard.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: PermissionGuard, deps: [{ token: i1$1.Router }, { token: RoutesService }, { token: PermissionService }, { token: HttpErrorReporterService }], target: i0.ɵɵFactoryTarget.Injectable });
PermissionGuard.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: PermissionGuard, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: PermissionGuard, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1$1.Router }, { type: RoutesService }, { type: PermissionService }, { type: HttpErrorReporterService }]; } });

class ListResultDto {
    constructor(initialValues = {}) {
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                this[key] = initialValues[key];
            }
        }
    }
}
class PagedResultDto extends ListResultDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class LimitedResultRequestDto {
    constructor(initialValues = {}) {
        this.maxResultCount = 10;
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key) &&
                initialValues[key] !== undefined) {
                this[key] = initialValues[key];
            }
        }
    }
}
class PagedResultRequestDto extends LimitedResultRequestDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class PagedAndSortedResultRequestDto extends PagedResultRequestDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class EntityDto {
    constructor(initialValues = {}) {
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                this[key] = initialValues[key];
            }
        }
    }
}
class CreationAuditedEntityDto extends EntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class CreationAuditedEntityWithUserDto extends CreationAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class AuditedEntityDto extends CreationAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class AuditedEntityWithUserDto extends AuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class FullAuditedEntityDto extends AuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class FullAuditedEntityWithUserDto extends FullAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleObject {
    constructor(initialValues = {}) {
        for (const key in initialValues) {
            if (Object.prototype.hasOwnProperty.call(initialValues, key)) {
                this[key] = initialValues[key];
            }
        }
    }
}
class ExtensibleEntityDto extends ExtensibleObject {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleCreationAuditedEntityDto extends ExtensibleEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleAuditedEntityDto extends ExtensibleCreationAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleAuditedEntityWithUserDto extends ExtensibleAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleCreationAuditedEntityWithUserDto extends ExtensibleCreationAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleFullAuditedEntityDto extends ExtensibleAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}
class ExtensibleFullAuditedEntityWithUserDto extends ExtensibleFullAuditedEntityDto {
    constructor(initialValues = {}) {
        super(initialValues);
    }
}

class AbpApiDefinitionService {
    constructor(restService) {
        this.restService = restService;
        this.apiName = 'abp';
        this.getByModel = (model) => this.restService.request({
            method: 'GET',
            url: '/api/abp/api-definition',
            params: { includeTypes: model.includeTypes },
        }, { apiName: this.apiName });
    }
}
AbpApiDefinitionService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbpApiDefinitionService, deps: [{ token: RestService }], target: i0.ɵɵFactoryTarget.Injectable });
AbpApiDefinitionService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbpApiDefinitionService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.6", ngImport: i0, type: AbpApiDefinitionService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: RestService }]; } });

/* eslint-disable @typescript-eslint/ban-types */

var index = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/* eslint-disable @typescript-eslint/ban-types */

class ContainerStrategy {
    constructor(containerRef) {
        this.containerRef = containerRef;
    }
    prepare() { }
}
class ClearContainerStrategy extends ContainerStrategy {
    getIndex() {
        return 0;
    }
    prepare() {
        this.containerRef.clear();
    }
}
class InsertIntoContainerStrategy extends ContainerStrategy {
    constructor(containerRef, index) {
        super(containerRef);
        this.index = index;
    }
    getIndex() {
        return Math.min(Math.max(0, this.index), this.containerRef.length);
    }
}
const CONTAINER_STRATEGY = {
    Clear(containerRef) {
        return new ClearContainerStrategy(containerRef);
    },
    Append(containerRef) {
        return new InsertIntoContainerStrategy(containerRef, containerRef.length);
    },
    Prepend(containerRef) {
        return new InsertIntoContainerStrategy(containerRef, 0);
    },
    Insert(containerRef, index) {
        return new InsertIntoContainerStrategy(containerRef, index);
    },
};

class ContentSecurityStrategy {
    constructor(nonce) {
        this.nonce = nonce;
    }
}
class LooseContentSecurityStrategy extends ContentSecurityStrategy {
    constructor(nonce) {
        super(nonce);
    }
    applyCSP(element) {
        element.setAttribute('nonce', this.nonce);
    }
}
class NoContentSecurityStrategy extends ContentSecurityStrategy {
    constructor() {
        super();
    }
    applyCSP(_) { }
}
const CONTENT_SECURITY_STRATEGY = {
    Loose(nonce) {
        return new LooseContentSecurityStrategy(nonce);
    },
    None() {
        return new NoContentSecurityStrategy();
    },
};

class ContentStrategy {
    constructor(content, domStrategy = DOM_STRATEGY.AppendToHead(), contentSecurityStrategy = CONTENT_SECURITY_STRATEGY.None(), options = {}) {
        this.content = content;
        this.domStrategy = domStrategy;
        this.contentSecurityStrategy = contentSecurityStrategy;
        this.options = options;
    }
    insertElement() {
        const element = this.createElement();
        if (this.options && Object.keys(this.options).length > 0) {
            Object.keys(this.options).forEach(key => (element[key] = this.options[key]));
        }
        this.contentSecurityStrategy.applyCSP(element);
        this.domStrategy.insertElement(element);
        return element;
    }
}
class StyleContentStrategy extends ContentStrategy {
    createElement() {
        const element = document.createElement('style');
        element.textContent = this.content;
        return element;
    }
}
class ScriptContentStrategy extends ContentStrategy {
    createElement() {
        const element = document.createElement('script');
        element.textContent = this.content;
        return element;
    }
}
const CONTENT_STRATEGY = {
    AppendScriptToBody(content, options) {
        return new ScriptContentStrategy(content, DOM_STRATEGY.AppendToBody(), undefined, options);
    },
    AppendScriptToHead(content, options) {
        return new ScriptContentStrategy(content, DOM_STRATEGY.AppendToHead(), undefined, options);
    },
    AppendStyleToHead(content, options) {
        return new StyleContentStrategy(content, DOM_STRATEGY.AppendToHead(), undefined, options);
    },
    PrependStyleToHead(content, options) {
        return new StyleContentStrategy(content, DOM_STRATEGY.PrependToHead(), undefined, options);
    },
};

class ContextStrategy {
    constructor(context) {
        this.context = context;
    }
    setContext(componentRef) {
        return this.context;
    }
}
class NoContextStrategy extends ContextStrategy {
    constructor() {
        super(undefined);
    }
}
class ComponentContextStrategy extends ContextStrategy {
    setContext(componentRef) {
        Object.keys(this.context).forEach(key => (componentRef.instance[key] = this.context[key]));
        componentRef.changeDetectorRef.detectChanges();
        return this.context;
    }
}
class TemplateContextStrategy extends ContextStrategy {
    setContext() {
        return this.context;
    }
}
const CONTEXT_STRATEGY = {
    None() {
        return new NoContextStrategy();
    },
    Component(context) {
        return new ComponentContextStrategy(context);
    },
    Template(context) {
        return new TemplateContextStrategy(context);
    },
};

class LoadingStrategy {
    constructor(path, domStrategy = DOM_STRATEGY.AppendToHead(), crossOriginStrategy = CROSS_ORIGIN_STRATEGY.Anonymous()) {
        this.path = path;
        this.domStrategy = domStrategy;
        this.crossOriginStrategy = crossOriginStrategy;
    }
    createStream() {
        this.element = this.createElement();
        return of(null).pipe(switchMap(() => fromLazyLoad(this.element, this.domStrategy, this.crossOriginStrategy)));
    }
}
class ScriptLoadingStrategy extends LoadingStrategy {
    constructor(src, domStrategy, crossOriginStrategy) {
        super(src, domStrategy, crossOriginStrategy);
    }
    createElement() {
        const element = document.createElement('script');
        element.src = this.path;
        return element;
    }
}
class StyleLoadingStrategy extends LoadingStrategy {
    constructor(href, domStrategy, crossOriginStrategy) {
        super(href, domStrategy, crossOriginStrategy);
    }
    createElement() {
        const element = document.createElement('link');
        element.rel = 'stylesheet';
        element.href = this.path;
        return element;
    }
}
const LOADING_STRATEGY = {
    AppendScriptToBody(src) {
        return new ScriptLoadingStrategy(src, DOM_STRATEGY.AppendToBody(), CROSS_ORIGIN_STRATEGY.None());
    },
    AppendAnonymousScriptToBody(src, integrity) {
        return new ScriptLoadingStrategy(src, DOM_STRATEGY.AppendToBody(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
    AppendAnonymousScriptToHead(src, integrity) {
        return new ScriptLoadingStrategy(src, DOM_STRATEGY.AppendToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
    AppendAnonymousStyleToHead(src, integrity) {
        return new StyleLoadingStrategy(src, DOM_STRATEGY.AppendToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
    PrependAnonymousScriptToHead(src, integrity) {
        return new ScriptLoadingStrategy(src, DOM_STRATEGY.PrependToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
    PrependAnonymousStyleToHead(src, integrity) {
        return new StyleLoadingStrategy(src, DOM_STRATEGY.PrependToHead(), CROSS_ORIGIN_STRATEGY.Anonymous(integrity));
    },
};

class ProjectionStrategy {
    constructor(content) {
        this.content = content;
    }
}
class ComponentProjectionStrategy extends ProjectionStrategy {
    constructor(component, containerStrategy, contextStrategy = CONTEXT_STRATEGY.None()) {
        super(component);
        this.containerStrategy = containerStrategy;
        this.contextStrategy = contextStrategy;
    }
    injectContent(injector) {
        this.containerStrategy.prepare();
        const resolver = injector.get(ComponentFactoryResolver);
        const factory = resolver.resolveComponentFactory(this.content);
        const componentRef = this.containerStrategy.containerRef.createComponent(factory, this.containerStrategy.getIndex(), injector);
        this.contextStrategy.setContext(componentRef);
        return componentRef;
    }
}
class RootComponentProjectionStrategy extends ProjectionStrategy {
    constructor(component, contextStrategy = CONTEXT_STRATEGY.None(), domStrategy = DOM_STRATEGY.AppendToBody()) {
        super(component);
        this.contextStrategy = contextStrategy;
        this.domStrategy = domStrategy;
    }
    injectContent(injector) {
        const appRef = injector.get(ApplicationRef);
        const resolver = injector.get(ComponentFactoryResolver);
        const componentRef = resolver
            .resolveComponentFactory(this.content)
            .create(injector);
        this.contextStrategy.setContext(componentRef);
        appRef.attachView(componentRef.hostView);
        const element = componentRef.hostView.rootNodes[0];
        this.domStrategy.insertElement(element);
        return componentRef;
    }
}
class TemplateProjectionStrategy extends ProjectionStrategy {
    constructor(templateRef, containerStrategy, contextStrategy = CONTEXT_STRATEGY.None()) {
        super(templateRef);
        this.containerStrategy = containerStrategy;
        this.contextStrategy = contextStrategy;
    }
    injectContent() {
        this.containerStrategy.prepare();
        const embeddedViewRef = this.containerStrategy.containerRef.createEmbeddedView(this.content, this.contextStrategy.context, this.containerStrategy.getIndex());
        embeddedViewRef.detectChanges();
        return embeddedViewRef;
    }
}
const PROJECTION_STRATEGY = {
    AppendComponentToBody(component, context) {
        return new RootComponentProjectionStrategy(component, context && CONTEXT_STRATEGY.Component(context));
    },
    AppendComponentToContainer(component, containerRef, context) {
        return new ComponentProjectionStrategy(component, CONTAINER_STRATEGY.Append(containerRef), context && CONTEXT_STRATEGY.Component(context));
    },
    AppendTemplateToContainer(templateRef, containerRef, context) {
        return new TemplateProjectionStrategy(templateRef, CONTAINER_STRATEGY.Append(containerRef), context && CONTEXT_STRATEGY.Template(context));
    },
    PrependComponentToContainer(component, containerRef, context) {
        return new ComponentProjectionStrategy(component, CONTAINER_STRATEGY.Prepend(containerRef), context && CONTEXT_STRATEGY.Component(context));
    },
    PrependTemplateToContainer(templateRef, containerRef, context) {
        return new TemplateProjectionStrategy(templateRef, CONTAINER_STRATEGY.Prepend(containerRef), context && CONTEXT_STRATEGY.Template(context));
    },
    ProjectComponentToContainer(component, containerRef, context) {
        return new ComponentProjectionStrategy(component, CONTAINER_STRATEGY.Clear(containerRef), context && CONTEXT_STRATEGY.Component(context));
    },
    ProjectTemplateToContainer(templateRef, containerRef, context) {
        return new TemplateProjectionStrategy(templateRef, CONTAINER_STRATEGY.Clear(containerRef), context && CONTEXT_STRATEGY.Template(context));
    },
};

const NAVIGATE_TO_MANAGE_PROFILE = new InjectionToken('NAVIGATE_TO_MANAGE_PROFILE', {
    providedIn: 'root',
    factory: () => {
        const environment = inject(EnvironmentService);
        return () => {
            window.open(`${environment.getEnvironment().oAuthConfig.issuer}/Account/Manage?returnUrl=${window.location.href}`, '_self');
        };
    },
});

function validateMinAge({ age = 18 } = {}) {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        return isValidMinAge(control.value, age) ? null : { minAge: { age } };
    };
}
function isValidMinAge(value, minAge) {
    const date = new Date();
    date.setFullYear(date.getFullYear() - minAge);
    date.setHours(23, 59, 59, 999);
    return Number(new Date(value)) <= date.valueOf();
}

function validateCreditCard() {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        return isValidCreditCard(String(control.value)) ? null : { creditCard: true };
    };
}
function isValidCreditCard(value) {
    value = value.replace(/[ -]/g, '');
    if (!/^[0-9]{13,19}$/.test(value))
        return false;
    let checksum = 0;
    let multiplier = 1;
    for (let i = value.length; i > 0; i--) {
        const digit = Number(value[i - 1]) * multiplier;
        checksum += (digit % 10) + ~~(digit / 10);
        multiplier = (multiplier * 2) % 3;
    }
    return checksum % 10 === 0;
}

function validateRange({ maximum = Infinity, minimum = 0 } = {}) {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        const value = Number(control.value);
        return getMinError(value, minimum, maximum) || getMaxError(value, maximum, minimum);
    };
}
function getMaxError(value, max, min) {
    return value > max ? { range: { max, min } } : null;
}
function getMinError(value, min, max) {
    return value < min ? { range: { min, max } } : null;
}

function validateRequired({ allowEmptyStrings } = {}) {
    return (control) => {
        return isValidRequired(control.value, allowEmptyStrings) ? null : { required: true };
    };
}
function isValidRequired(value, allowEmptyStrings) {
    if (value || value === 0 || value === false)
        return true;
    if (allowEmptyStrings && value === '')
        return true;
    return false;
}

function validateStringLength({ maximumLength = Infinity, minimumLength = 0, } = {}) {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        const value = String(control.value);
        return getMinLengthError(value, minimumLength) || getMaxLengthError(value, maximumLength);
    };
}
function getMaxLengthError(value, requiredLength) {
    return value.length > requiredLength ? { maxlength: { requiredLength } } : null;
}
function getMinLengthError(value, requiredLength) {
    return value.length < requiredLength ? { minlength: { requiredLength } } : null;
}

function validateUrl() {
    return (control) => {
        if (['', null, undefined].indexOf(control.value) > -1)
            return null;
        return isValidUrl(control.value) ? null : { url: true };
    };
}
function isValidUrl(value) {
    if (/^http(s)?:\/\/[^/]/.test(value) || /^ftp:\/\/[^/]/.test(value)) {
        const a = document.createElement('a');
        a.href = value;
        return !!a.host;
    }
    return false;
}

const AbpValidators = {
    creditCard: validateCreditCard,
    emailAddress: () => Validators.email,
    minAge: validateMinAge,
    range: validateRange,
    required: validateRequired,
    stringLength: validateStringLength,
    url: validateUrl,
};

// export * from './lib/handlers';

/**
 * Generated bundle index. Do not edit.
 */

export { APP_INIT_ERROR_HANDLERS, AbpApiDefinitionService, AbpApplicationConfigurationService, AbpTenantService, AbpValidators, AbstractNavTreeService, AbstractNgModelComponent, AbstractTreeService, ApiInterceptor, AuditedEntityDto, AuditedEntityWithUserDto, AuthGuard, AuthService, AutofocusDirective, BaseCoreModule, BaseTreeNode, CONTAINER_STRATEGY, CONTENT_SECURITY_STRATEGY, CONTENT_STRATEGY, CONTEXT_STRATEGY, COOKIE_LANGUAGE_KEY, CORE_OPTIONS, CROSS_ORIGIN_STRATEGY, ClearContainerStrategy, ComponentContextStrategy, ComponentProjectionStrategy, ConfigStateService, ContainerStrategy, ContentProjectionService, ContentSecurityStrategy, ContentStrategy, ContextStrategy, CoreModule, CreationAuditedEntityDto, CreationAuditedEntityWithUserDto, CrossOriginStrategy, DOM_STRATEGY, DomInsertionService, DomStrategy, DynamicLayoutComponent, EntityDto, EnvironmentService, ExtensibleAuditedEntityDto, ExtensibleAuditedEntityWithUserDto, ExtensibleCreationAuditedEntityDto, ExtensibleCreationAuditedEntityWithUserDto, ExtensibleEntityDto, ExtensibleFullAuditedEntityDto, ExtensibleFullAuditedEntityWithUserDto, ExtensibleObject, ForDirective, FormSubmitDirective, FullAuditedEntityDto, FullAuditedEntityWithUserDto, HttpErrorReporterService, HttpWaitService, INJECTOR_PIPE_DATA_TOKEN, InitDirective, InputEventDebounceDirective, InsertIntoContainerStrategy, InternalStore, LIST_QUERY_DEBOUNCE_TIME, LOADER_DELAY, LOADING_STRATEGY, LOCALIZATIONS, LazyLoadService, LazyModuleFactory, LimitedResultRequestDto, ListResultDto, ListService, LoadingStrategy, LocalizationModule, LocalizationPipe, LocalizationService, LooseContentSecurityStrategy, MultiTenancyService, NAVIGATE_TO_MANAGE_PROFILE, NavigationEvent, NoContentSecurityStrategy, NoContextStrategy, NoCrossOriginStrategy, index as ObjectExtending, PROJECTION_STRATEGY, PagedAndSortedResultRequestDto, PagedResultDto, PagedResultRequestDto, PermissionDirective, PermissionGuard, PermissionService, ProjectionStrategy, ReplaceableComponentsService, ReplaceableRouteContainerComponent, ReplaceableTemplateDirective, ResourceWaitService, RestService, RootComponentProjectionStrategy, RootCoreModule, RouterEvents, RouterOutletComponent, RouterWaitService, RoutesService, ScriptContentStrategy, ScriptLoadingStrategy, SessionStateService, ShortDatePipe, ShortDateTimePipe, ShortTimePipe, SortPipe, StopPropagationDirective, StyleContentStrategy, StyleLoadingStrategy, SubscriptionService, TENANT_KEY, TemplateContextStrategy, TemplateProjectionStrategy, ToInjectorPipe, TrackByService, WebHttpUrlEncodingCodec, checkAccessToken, coreOptionsFactory, createLocalizationPipeKeyGenerator, createLocalizer, createLocalizerWithFallback, createMapFromList, createTokenParser, createTreeFromList, createTreeNodeFilterCreator, deepMerge, differentLocales, downloadBlob, escapeHtmlChars, exists, featuresFactory, findRoute, fromLazyLoad, generateHash, generatePassword, getInitialData, getLocaleDirection, getPathName, getRemoteEnv, getRoutePath, getShortDateFormat, getShortDateShortTimeFormat, getShortTimeFormat, interpolate, isArray, isNode, isNullOrUndefined, isNumber, isObject, isObjectAndNotArray, isObjectAndNotArrayNotNode, isUndefinedOrEmptyString, localeInitializer, localizationContributor, localizations$, mapEnumToOptions, noop, parseTenantFromUrl, pipeToLogin, pushValueTo, reloadRoute, removeRememberMe, setRememberMe, setTokenResponseToStorage, storageFactory, trackBy, trackByDeep, uuid, validateCreditCard, validateMinAge, validateRange, validateRequired, validateStringLength, validateUrl };
//# sourceMappingURL=abp-ng.core.mjs.map
