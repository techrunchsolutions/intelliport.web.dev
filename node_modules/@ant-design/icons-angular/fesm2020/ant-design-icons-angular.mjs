import { DOCUMENT, CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { isDevMode, InjectionToken, SecurityContext, Injectable, Optional, Inject, Directive, Input, NgModule } from '@angular/core';
import { generate } from '@ant-design/colors';
import * as i1 from '@angular/common/http';
import { HttpClient } from '@angular/common/http';
import { Subject, of, Observable } from 'rxjs';
import { map, tap, finalize, catchError, share, filter, take } from 'rxjs/operators';
import * as i2 from '@angular/platform-browser';

const ANT_ICON_ANGULAR_CONSOLE_PREFIX = '[@ant-design/icons-angular]:';
function error(message) {
    console.error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX} ${message}.`);
}
function warn(message) {
    if (isDevMode()) {
        console.warn(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX} ${message}.`);
    }
}
function getSecondaryColor(primaryColor) {
    return generate(primaryColor)[0];
}
function withSuffix(name, theme) {
    switch (theme) {
        case 'fill': return `${name}-fill`;
        case 'outline': return `${name}-o`;
        case 'twotone': return `${name}-twotone`;
        case undefined: return name;
        default: throw new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}Theme "${theme}" is not a recognized theme!`);
    }
}
function withSuffixAndColor(name, theme, pri, sec) {
    return `${withSuffix(name, theme)}-${pri}-${sec}`;
}
function mapAbbrToTheme(abbr) {
    return abbr === 'o' ? 'outline' : abbr;
}
function alreadyHasAThemeSuffix(name) {
    return name.endsWith('-fill') || name.endsWith('-o') || name.endsWith('-twotone');
}
function isIconDefinition(target) {
    return (typeof target === 'object' &&
        typeof target.name === 'string' &&
        (typeof target.theme === 'string' || target.theme === undefined) &&
        typeof target.icon === 'string');
}
/**
 * Get an `IconDefinition` object from abbreviation type, like `account-book-fill`.
 * @param str
 */
function getIconDefinitionFromAbbr(str) {
    const arr = str.split('-');
    const theme = mapAbbrToTheme(arr.splice(arr.length - 1, 1)[0]);
    const name = arr.join('-');
    return {
        name,
        theme,
        icon: ''
    };
}
function cloneSVG(svg) {
    return svg.cloneNode(true);
}
/**
 * Parse inline SVG string and replace colors with placeholders. For twotone icons only.
 */
function replaceFillColor(raw) {
    return raw
        .replace(/['"]#333['"]/g, '"primaryColor"')
        .replace(/['"]#E6E6E6['"]/g, '"secondaryColor"')
        .replace(/['"]#D9D9D9['"]/g, '"secondaryColor"')
        .replace(/['"]#D8D8D8['"]/g, '"secondaryColor"');
}
/**
 * Split a name with namespace in it into a tuple like [ name, namespace ].
 */
function getNameAndNamespace(type) {
    const split = type.split(':');
    switch (split.length) {
        case 1: return [type, ''];
        case 2: return [split[1], split[0]];
        default: throw new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}The icon type ${type} is not valid!`);
    }
}
function hasNamespace(type) {
    return getNameAndNamespace(type)[1] !== '';
}

function NameSpaceIsNotSpecifyError() {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}Type should have a namespace. Try "namespace:${name}".`);
}
function IconNotFoundError(icon) {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}the icon ${icon} does not exist or is not registered.`);
}
function HttpModuleNotImport() {
    error(`you need to import "HttpClientModule" to use dynamic importing.`);
    return null;
}
function UrlNotSafeError(url) {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}The url "${url}" is unsafe.`);
}
function SVGTagNotFoundError() {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}<svg> tag not found.`);
}
function DynamicLoadingTimeoutError() {
    return new Error(`${ANT_ICON_ANGULAR_CONSOLE_PREFIX}Importing timeout error.`);
}

// tslint:disable:no-any
const JSONP_HANDLER_NAME = '__ant_icon_load';
const ANT_ICONS = new InjectionToken('ant_icons');
class IconService {
    // TODO@wendellhu: change parameter sequence in the next major version
    constructor(_rendererFactory, _handler, _document, sanitizer, _antIcons) {
        this._rendererFactory = _rendererFactory;
        this._handler = _handler;
        this._document = _document;
        this.sanitizer = sanitizer;
        this._antIcons = _antIcons;
        this.defaultTheme = 'outline';
        /**
         * All icon definitions would be registered here.
         */
        this._svgDefinitions = new Map();
        /**
         * Cache all rendered icons. Icons are identified by name, theme,
         * and for twotone icons, primary color and secondary color.
         */
        this._svgRenderedDefinitions = new Map();
        this._inProgressFetches = new Map();
        /**
         * Url prefix for fetching inline SVG by dynamic importing.
         */
        this._assetsUrlRoot = '';
        this._twoToneColorPalette = {
            primaryColor: '#333333',
            secondaryColor: '#E6E6E6'
        };
        /** A flag indicates whether jsonp loading is enabled. */
        this._enableJsonpLoading = false;
        this._jsonpIconLoad$ = new Subject();
        this._renderer = this._rendererFactory.createRenderer(null, null);
        if (this._handler) {
            this._http = new HttpClient(this._handler);
        }
        if (this._antIcons) {
            this.addIcon(...this._antIcons);
        }
    }
    set twoToneColor({ primaryColor, secondaryColor }) {
        this._twoToneColorPalette.primaryColor = primaryColor;
        this._twoToneColorPalette.secondaryColor =
            secondaryColor || getSecondaryColor(primaryColor);
    }
    get twoToneColor() {
        // Make a copy to avoid unexpected changes.
        return { ...this._twoToneColorPalette };
    }
    /**
     * Disable dynamic loading (support static loading only).
     */
    get _disableDynamicLoading() {
        return false;
    }
    /**
     * Call this method to switch to jsonp like loading.
     */
    useJsonpLoading() {
        if (!this._enableJsonpLoading) {
            this._enableJsonpLoading = true;
            window[JSONP_HANDLER_NAME] = (icon) => {
                this._jsonpIconLoad$.next(icon);
            };
        }
        else {
            warn('You are already using jsonp loading.');
        }
    }
    /**
     * Change the prefix of the inline svg resources, so they could be deployed elsewhere, like CDN.
     * @param prefix
     */
    changeAssetsSource(prefix) {
        this._assetsUrlRoot = prefix.endsWith('/') ? prefix : prefix + '/';
    }
    /**
     * Add icons provided by ant design.
     * @param icons
     */
    addIcon(...icons) {
        icons.forEach(icon => {
            this._svgDefinitions.set(withSuffix(icon.name, icon.theme), icon);
        });
    }
    /**
     * Register an icon. Namespace is required.
     * @param type
     * @param literal
     */
    addIconLiteral(type, literal) {
        const [_, namespace] = getNameAndNamespace(type);
        if (!namespace) {
            throw NameSpaceIsNotSpecifyError();
        }
        this.addIcon({ name: type, icon: literal });
    }
    /**
     * Remove all cache.
     */
    clear() {
        this._svgDefinitions.clear();
        this._svgRenderedDefinitions.clear();
    }
    /**
     * Get a rendered `SVGElement`.
     * @param icon
     * @param twoToneColor
     */
    getRenderedContent(icon, twoToneColor) {
        // If `icon` is a `IconDefinition`, go to the next step. If not, try to fetch it from cache.
        const definition = isIconDefinition(icon)
            ? icon
            : this._svgDefinitions.get(icon) || null;
        if (!definition && this._disableDynamicLoading) {
            throw IconNotFoundError(icon);
        }
        // If `icon` is a `IconDefinition` of successfully fetch, wrap it in an `Observable`.
        // Otherwise try to fetch it from remote.
        const $iconDefinition = definition
            ? of(definition)
            : this._loadIconDynamically(icon);
        // If finally get an `IconDefinition`, render and return it. Otherwise throw an error.
        return $iconDefinition.pipe(map(i => {
            if (!i) {
                throw IconNotFoundError(icon);
            }
            return this._loadSVGFromCacheOrCreateNew(i, twoToneColor);
        }));
    }
    getCachedIcons() {
        return this._svgDefinitions;
    }
    /**
     * Get raw svg and assemble a `IconDefinition` object.
     * @param type
     */
    _loadIconDynamically(type) {
        // If developer doesn't provide HTTP module nor enable jsonp loading, just throw an error.
        if (!this._http && !this._enableJsonpLoading) {
            return of(HttpModuleNotImport());
        }
        // If multi directive ask for the same icon at the same time,
        // request should only be fired once.
        let inProgress = this._inProgressFetches.get(type);
        if (!inProgress) {
            const [name, namespace] = getNameAndNamespace(type);
            // If the string has a namespace within, create a simple `IconDefinition`.
            const icon = namespace
                ? { name: type, icon: '' }
                : getIconDefinitionFromAbbr(name);
            const suffix = this._enableJsonpLoading ? '.js' : '.svg';
            const url = (namespace
                ? `${this._assetsUrlRoot}assets/${namespace}/${name}`
                : `${this._assetsUrlRoot}assets/${icon.theme}/${icon.name}`) + suffix;
            const safeUrl = this.sanitizer.sanitize(SecurityContext.URL, url);
            if (!safeUrl) {
                throw UrlNotSafeError(url);
            }
            const source = !this._enableJsonpLoading
                ? this._http
                    .get(safeUrl, { responseType: 'text' })
                    .pipe(map(literal => ({ ...icon, icon: literal })))
                : this._loadIconDynamicallyWithJsonp(icon, safeUrl);
            inProgress = source.pipe(tap(definition => this.addIcon(definition)), finalize(() => this._inProgressFetches.delete(type)), catchError(() => of(null)), share());
            this._inProgressFetches.set(type, inProgress);
        }
        return inProgress;
    }
    _loadIconDynamicallyWithJsonp(icon, url) {
        return new Observable(subscriber => {
            const loader = this._document.createElement('script');
            const timer = setTimeout(() => {
                clean();
                subscriber.error(DynamicLoadingTimeoutError());
            }, 6000);
            loader.src = url;
            function clean() {
                loader.parentNode.removeChild(loader);
                clearTimeout(timer);
            }
            this._document.body.appendChild(loader);
            this._jsonpIconLoad$
                .pipe(filter(i => i.name === icon.name && i.theme === icon.theme), take(1))
                .subscribe(i => {
                subscriber.next(i);
                clean();
            });
        });
    }
    /**
     * Render a new `SVGElement` for a given `IconDefinition`, or make a copy from cache.
     * @param icon
     * @param twoToneColor
     */
    _loadSVGFromCacheOrCreateNew(icon, twoToneColor) {
        let svg;
        const pri = twoToneColor || this._twoToneColorPalette.primaryColor;
        const sec = getSecondaryColor(pri) || this._twoToneColorPalette.secondaryColor;
        const key = icon.theme === 'twotone'
            ? withSuffixAndColor(icon.name, icon.theme, pri, sec)
            : icon.theme === undefined
                ? icon.name
                : withSuffix(icon.name, icon.theme);
        // Try to make a copy from cache.
        const cached = this._svgRenderedDefinitions.get(key);
        if (cached) {
            svg = cached.icon;
        }
        else {
            svg = this._setSVGAttribute(this._colorizeSVGIcon(
            // Icons provided by ant design should be refined to remove preset colors.
            this._createSVGElementFromString(hasNamespace(icon.name) ? icon.icon : replaceFillColor(icon.icon)), icon.theme === 'twotone', pri, sec));
            // Cache it.
            this._svgRenderedDefinitions.set(key, {
                ...icon,
                icon: svg
            });
        }
        return cloneSVG(svg);
    }
    _createSVGElementFromString(str) {
        const div = this._document.createElement('div');
        div.innerHTML = str;
        const svg = div.querySelector('svg');
        if (!svg) {
            throw SVGTagNotFoundError;
        }
        return svg;
    }
    _setSVGAttribute(svg) {
        this._renderer.setAttribute(svg, 'width', '1em');
        this._renderer.setAttribute(svg, 'height', '1em');
        return svg;
    }
    _colorizeSVGIcon(svg, twotone, pri, sec) {
        if (twotone) {
            const children = svg.childNodes;
            const length = children.length;
            for (let i = 0; i < length; i++) {
                const child = children[i];
                if (child.getAttribute('fill') === 'secondaryColor') {
                    this._renderer.setAttribute(child, 'fill', sec);
                }
                else {
                    this._renderer.setAttribute(child, 'fill', pri);
                }
            }
        }
        this._renderer.setAttribute(svg, 'fill', 'currentColor');
        return svg;
    }
}
IconService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.1", ngImport: i0, type: IconService, deps: [{ token: i0.RendererFactory2 }, { token: i1.HttpBackend, optional: true }, { token: DOCUMENT, optional: true }, { token: i2.DomSanitizer }, { token: ANT_ICONS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
IconService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.1", ngImport: i0, type: IconService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.1", ngImport: i0, type: IconService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i0.RendererFactory2 }, { type: i1.HttpBackend, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i2.DomSanitizer }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [ANT_ICONS]
                }] }]; } });

function checkMeta(prev, after) {
    return prev.type === after.type && prev.theme === after.theme && prev.twoToneColor === after.twoToneColor;
}
class IconDirective {
    constructor(_iconService, _elementRef, _renderer) {
        this._iconService = _iconService;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
    }
    ngOnChanges(changes) {
        if (changes.type || changes.theme || changes.twoToneColor) {
            this._changeIcon();
        }
    }
    /**
     * Render a new icon in the current element. Remove the icon when `type` is falsy.
     */
    _changeIcon() {
        return new Promise(resolve => {
            if (!this.type) {
                this._clearSVGElement();
                resolve(null);
                return;
            }
            const beforeMeta = this._getSelfRenderMeta();
            this._iconService.getRenderedContent(this._parseIconType(this.type, this.theme), this.twoToneColor).subscribe(svg => {
                // avoid race condition
                // see https://github.com/ant-design/ant-design-icons/issues/315
                const afterMeta = this._getSelfRenderMeta();
                if (checkMeta(beforeMeta, afterMeta)) {
                    this._setSVGElement(svg);
                    resolve(svg);
                }
                else {
                    resolve(null);
                }
            });
        });
    }
    _getSelfRenderMeta() {
        return {
            type: this.type,
            theme: this.theme,
            twoToneColor: this.twoToneColor
        };
    }
    /**
     * Parse a icon to the standard form, an `IconDefinition` or a string like 'account-book-fill` (with a theme suffixed).
     * If namespace is specified, ignore theme because it meaningless for users' icons.
     *
     * @param type
     * @param theme
     */
    _parseIconType(type, theme) {
        if (isIconDefinition(type)) {
            return type;
        }
        else {
            const [name, namespace] = getNameAndNamespace(type);
            if (namespace) {
                return type;
            }
            if (alreadyHasAThemeSuffix(name)) {
                if (!!theme) {
                    warn(`'type' ${name} already gets a theme inside so 'theme' ${theme} would be ignored`);
                }
                return name;
            }
            else {
                return withSuffix(name, theme || this._iconService.defaultTheme);
            }
        }
    }
    _setSVGElement(svg) {
        this._clearSVGElement();
        this._renderer.appendChild(this._elementRef.nativeElement, svg);
    }
    _clearSVGElement() {
        const el = this._elementRef.nativeElement;
        const children = el.childNodes;
        const length = children.length;
        for (let i = length - 1; i >= 0; i--) {
            const child = children[i];
            if (child.tagName?.toLowerCase() === 'svg') {
                this._renderer.removeChild(el, child);
            }
        }
    }
}
IconDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.1", ngImport: i0, type: IconDirective, deps: [{ token: IconService }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
IconDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.0.1", type: IconDirective, selector: "[antIcon]", inputs: { type: "type", theme: "theme", twoToneColor: "twoToneColor" }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.1", ngImport: i0, type: IconDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[antIcon]'
                }]
        }], ctorParameters: function () { return [{ type: IconService }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { type: [{
                type: Input
            }], theme: [{
                type: Input
            }], twoToneColor: [{
                type: Input
            }] } });

class IconModule {
}
IconModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.1", ngImport: i0, type: IconModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
IconModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.1", ngImport: i0, type: IconModule, declarations: [IconDirective], imports: [CommonModule], exports: [IconDirective] });
IconModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.0.1", ngImport: i0, type: IconModule, providers: [IconService], imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.1", ngImport: i0, type: IconModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    exports: [IconDirective],
                    declarations: [IconDirective],
                    providers: [IconService]
                }]
        }] });

const manifest = {
    fill: [
        'alert', 'account-book', 'amazon-circle', 'alipay-circle', 'amazon-square', 'android', 'apple', 'api', 'appstore', 'audio', 'alipay-square', 'backward', 'bank', 'behance-square', 'bell', 'behance-circle', 'box-plot', 'book', 'bug', 'calculator', 'calendar', 'build', 'aliwangwang', 'camera', 'caret-left', 'caret-up', 'carry-out', 'check-square', 'check-circle', 'caret-right', 'chrome', 'ci-circle', 'cloud', 'close-circle', 'bulb', 'caret-down', 'codepen-circle', 'code-sandbox-square', 'code', 'close-square', 'codepen-square', 'car', 'compass', 'contacts', 'container', 'copyright-circle', 'clock-circle', 'credit-card', 'customer-service', 'crown', 'dashboard', 'delete', 'database', 'diff', 'dingtalk-circle', 'dingtalk-square', 'dislike', 'down-circle', 'dollar-circle', 'dribbble-circle', 'dribbble-square', 'edit', 'dropbox-circle', 'environment', 'copy', 'dropbox-square', 'down-square', 'experiment', 'euro-circle', 'eye', 'fast-forward', 'control', 'fast-backward', 'facebook', 'file-add', 'code-sandbox-circle', 'file-excel', 'file-exclamation', 'file', 'eye-invisible', 'file-ppt', 'file-image', 'file-text', 'file-unknown', 'file-markdown', 'file-word', 'filter', 'file-zip', 'exclamation-circle', 'fire', 'file-pdf', 'folder', 'folder-open', 'flag', 'forward', 'fund', 'frown', 'format-painter', 'funnel-plot', 'gift', 'google-plus-circle', 'google-circle', 'golden', 'github', 'hdd', 'gold', 'google-square', 'google-plus-square', 'gitlab', 'highlight', 'heart', 'html5', 'home', 'ie-square', 'ie-circle', 'instagram', 'info-circle', 'idcard', 'insurance', 'hourglass', 'interaction', 'layout', 'left-circle', 'left-square', 'like', 'linkedin', 'lock', 'mail', 'meh', 'medicine-box', 'mac-command', 'medium-square', 'minus-square', 'money-collect', 'mobile', 'message', 'folder-add', 'medium-circle', 'notification', 'pay-circle', 'pause-circle', 'phone', 'play-circle', 'play-square', 'pie-chart', 'picture', 'plus-square', 'plus-circle', 'profile', 'pound-circle', 'project', 'printer', 'pushpin', 'qq-circle', 'qq-square', 'question-circle', 'red-envelope', 'read', 'reconciliation', 'minus-circle', 'reddit-square', 'reddit-circle', 'property-safety', 'right-circle', 'right-square', 'rocket', 'rest', 'robot', 'save', 'schedule', 'safety-certificate', 'security-scan', 'shop', 'shopping', 'sketch-circle', 'sketch-square', 'slack-circle', 'setting', 'signal', 'skin', 'sliders', 'slack-square', 'snippets', 'smile', 'sound', 'step-backward', 'stop', 'star', 'switcher', 'tablet', 'tag', 'skype', 'step-forward', 'thunderbolt', 'taobao-square', 'taobao-circle', 'tags', 'trademark-circle', 'tool', 'twitter-circle', 'unlock', 'twitter-square', 'trophy', 'up-circle', 'up-square', 'usb', 'wallet', 'warning', 'weibo-square', 'wechat', 'video-camera', 'windows', 'yuque', 'yahoo', 'zhihu-square', 'zhihu-circle', 'weibo-circle', 'youtube'
    ],
    outline: [
        'alert', 'aim', 'alibaba', 'amazon', 'aliyun', 'ant-design', 'account-book', 'apartment', 'android', 'api', 'apple', 'area-chart', 'appstore', 'ant-cloud', 'arrow-right', 'arrow-down', 'alipay-circle', 'audio-muted', 'align-center', 'arrow-up', 'arrows-alt', 'aliwangwang', 'backward', 'audit', 'bank', 'bar-chart', 'barcode', 'bars', 'behance', 'block', 'book', 'behance-square', 'bell', 'appstore-add', 'border-bottom', 'border-horizontal', 'audio', 'border-outer', 'border-left', 'border', 'bg-colors', 'align-right', 'border-right', 'borderless-table', 'box-plot', 'border-top', 'border-verticle', 'border-inner', 'bug', 'alipay', 'branches', 'camera', 'calculator', 'calendar', 'build', 'align-left', 'arrow-left', 'caret-left', 'caret-right', 'caret-up', 'carry-out', 'caret-down', 'check-circle', 'check', 'bulb', 'car', 'clear', 'ci', 'clock-circle', 'close-circle', 'close-square', 'close', 'bold', 'cloud-download', 'cloud', 'cloud-sync', 'cloud-server', 'cloud-upload', 'check-square', 'code', 'code-sandbox', 'coffee', 'codepen', 'chrome', 'compress', 'compass', 'column-width', 'comment', 'ci-circle', 'copy', 'container', 'control', 'copyright', 'credit-card', 'cluster', 'customer-service', 'contacts', 'console-sql', 'dash', 'dashboard', 'column-height', 'database', 'copyright-circle', 'codepen-circle', 'delete-column', 'desktop', 'deployment-unit', 'delivered-procedure', 'dingding', 'disconnect', 'dingtalk', 'dollar-circle', 'dislike', 'delete-row', 'diff', 'dollar', 'double-right', 'dot-chart', 'down', 'crown', 'down-circle', 'down-square', 'double-left', 'download', 'edit', 'ellipsis', 'dribbble', 'dribbble-square', 'delete', 'dropbox', 'environment', 'euro-circle', 'enter', 'exception', 'expand-alt', 'exclamation-circle', 'drag', 'euro', 'experiment', 'export', 'expand', 'fall', 'eye-invisible', 'eye', 'fast-forward', 'fast-backward', 'file-add', 'field-string', 'file-exclamation', 'file-done', 'field-time', 'file-excel', 'field-binary', 'file-gif', 'file-image', 'file', 'file-markdown', 'file-ppt', 'file-pdf', 'field-number', 'file-search', 'file-sync', 'file-jpg', 'file-text', 'filter', 'exclamation', 'file-zip', 'flag', 'folder-add', 'file-unknown', 'folder-open', 'fire', 'file-protect', 'folder-view', 'folder', 'fork', 'font-colors', 'font-size', 'facebook', 'format-painter', 'frown', 'form', 'fullscreen', 'fund-projection-screen', 'fullscreen-exit', 'fund', 'gift', 'gateway', 'github', 'fund-view', 'gif', 'funnel-plot', 'gold', 'gitlab', 'global', 'google', 'group', 'hdd', 'heat-map', 'highlight', 'google-plus', 'function', 'history', 'file-word', 'forward', 'home', 'idcard', 'holder', 'hourglass', 'info-circle', 'heart', 'insert-row-below', 'import', 'insert-row-left', 'insert-row-above', 'insert-row-right', 'ie', 'info', 'key', 'inbox', 'italic', 'insurance', 'laptop', 'issues-close', 'instagram', 'left-square', 'like', 'line', 'link', 'loading-3-quarters', 'linkedin', 'line-height', 'loading', 'lock', 'login', 'line-chart', 'man', 'mail', 'left-circle', 'mac-command', 'logout', 'medicine-box', 'layout', 'medium', 'medium-workmark', 'left', 'meh', 'menu-fold', 'menu-unfold', 'interaction', 'message', 'minus', 'minus-square', 'minus-circle', 'menu', 'merge-cells', 'mobile', 'money-collect', 'node-index', 'monitor', 'node-expand', 'ordered-list', 'more', 'number', 'notification', 'one-to-one', 'pause-circle', 'percentage', 'phone', 'pause', 'paper-clip', 'partition', 'pie-chart', 'pic-left', 'pic-center', 'picture', 'node-collapse', 'pic-right', 'play-square', 'play-circle', 'pay-circle', 'plus', 'plus-circle', 'html5', 'plus-square', 'pound', 'profile', 'project', 'property-safety', 'poweroff', 'pushpin', 'qrcode', 'printer', 'pound-circle', 'pull-request', 'question', 'qq', 'radar-chart', 'question-circle', 'radius-bottomleft', 'radius-upleft', 'redo', 'radius-setting', 'radius-upright', 'reddit', 'rest', 'read', 'reload', 'radius-bottomright', 'reconciliation', 'right', 'robot', 'rocket', 'right-square', 'right-circle', 'rotate-right', 'safety-certificate', 'red-envelope', 'rotate-left', 'retweet', 'rollback', 'rise', 'save', 'safety', 'search', 'security-scan', 'scan', 'send', 'setting', 'scissor', 'select', 'shake', 'shopping-cart', 'sisternode', 'shop', 'sketch', 'shopping', 'share-alt', 'schedule', 'skin', 'shrink', 'small-dash', 'sliders', 'skype', 'slack-square', 'snippets', 'sort-ascending', 'smile', 'solution', 'slack', 'sound', 'split-cells', 'sort-descending', 'step-forward', 'star', 'step-backward', 'subnode', 'swap', 'stock', 'swap-right', 'tags', 'tablet', 'tag', 'table', 'taobao-circle', 'switcher', 'stop', 'taobao', 'swap-left', 'sync', 'team', 'tool', 'trademark-circle', 'thunderbolt', 'to-top', 'translation', 'trademark', 'trophy', 'underline', 'ungroup', 'strikethrough', 'up-square', 'up-circle', 'up', 'unordered-list', 'twitter', 'undo', 'unlock', 'upload', 'transaction', 'user-delete', 'usb', 'user-add', 'usergroup-delete', 'video-camera-add', 'verified', 'vertical-right', 'vertical-align-bottom', 'usergroup-add', 'user', 'vertical-align-top', 'user-switch', 'video-camera', 'weibo', 'weibo-circle', 'vertical-left', 'vertical-align-middle', 'wifi', 'wallet', 'warning', 'whats-app', 'wechat', 'zhihu', 'youtube', 'woman', 'weibo-square', 'windows', 'yahoo', 'zoom-in', 'yuque', 'zoom-out'
    ],
    twotone: [
        'account-book', 'alert', 'api', 'audio', 'bank', 'bell', 'appstore', 'book', 'box-plot', 'bulb', 'calendar', 'camera', 'car', 'bug', 'carry-out', 'check-square', 'build', 'check-circle', 'ci-circle', 'ci', 'clock-circle', 'close-square', 'calculator', 'cloud', 'close-circle', 'code', 'container', 'compass', 'control', 'contacts', 'copy', 'copyright-circle', 'copyright', 'credit-card', 'crown', 'delete', 'diff', 'customer-service', 'database', 'dollar-circle', 'dashboard', 'dollar', 'down-square', 'edit', 'dislike', 'exclamation-circle', 'environment', 'experiment', 'euro-circle', 'down-circle', 'euro', 'eye', 'file-add', 'file-excel', 'eye-invisible', 'file-markdown', 'file-exclamation', 'file-pdf', 'file-ppt', 'file-unknown', 'file', 'file-word', 'file-text', 'filter', 'file-zip', 'flag', 'fire', 'folder', 'file-image', 'folder-add', 'folder-open', 'frown', 'fund', 'funnel-plot', 'gift', 'gold', 'highlight', 'hdd', 'home', 'hourglass', 'heart', 'html5', 'idcard', 'insurance', 'interaction', 'info-circle', 'layout', 'like', 'left-circle', 'lock', 'left-square', 'mail', 'meh', 'medicine-box', 'minus-circle', 'minus-square', 'money-collect', 'pause-circle', 'mobile', 'notification', 'message', 'phone', 'pie-chart', 'play-square', 'picture', 'play-circle', 'plus-circle', 'plus-square', 'pound-circle', 'printer', 'property-safety', 'pushpin', 'project', 'question-circle', 'profile', 'red-envelope', 'reconciliation', 'right-square', 'right-circle', 'schedule', 'save', 'safety-certificate', 'security-scan', 'rocket', 'shop', 'rest', 'setting', 'sliders', 'smile', 'snippets', 'sound', 'star', 'skin', 'shopping', 'switcher', 'tablet', 'tag', 'tags', 'thunderbolt', 'tool', 'stop', 'trademark-circle', 'trophy', 'up-circle', 'up-square', 'usb', 'unlock', 'wallet', 'video-camera', 'warning'
    ]
};

/**
 * Generated bundle index. Do not edit.
 */

export { ANT_ICONS, ANT_ICON_ANGULAR_CONSOLE_PREFIX, DynamicLoadingTimeoutError, HttpModuleNotImport, IconDirective, IconModule, IconNotFoundError, IconService, NameSpaceIsNotSpecifyError, SVGTagNotFoundError, UrlNotSafeError, alreadyHasAThemeSuffix, cloneSVG, error, getIconDefinitionFromAbbr, getNameAndNamespace, getSecondaryColor, hasNamespace, isIconDefinition, manifest, mapAbbrToTheme, replaceFillColor, warn, withSuffix, withSuffixAndColor };
//# sourceMappingURL=ant-design-icons-angular.mjs.map
