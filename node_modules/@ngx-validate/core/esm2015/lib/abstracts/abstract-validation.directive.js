/**
 * @fileoverview added by tsickle
 * Generated from: lib/abstracts/abstract-validation.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, Injector, Input, } from '@angular/core';
import { merge, NEVER } from 'rxjs';
import { BLUEPRINTS } from '../constants';
import { VALIDATION_BLUEPRINTS, VALIDATION_ERROR_TEMPLATE, VALIDATION_INVALID_CLASSES, VALIDATION_MAP_ERRORS_FN, VALIDATION_TARGET_SELECTOR, VALIDATION_VALIDATE_ON_SUBMIT, } from '../tokens';
import { evalPropTruthy } from '../utils';
export class AbstractValidationDirective {
    /**
     * @param {?} injector
     */
    constructor(injector) {
        this.injector = injector;
        this.config = {
            blueprints: injector.get(VALIDATION_BLUEPRINTS),
            errorTemplate: injector.get(VALIDATION_ERROR_TEMPLATE),
            invalidClasses: injector.get(VALIDATION_INVALID_CLASSES),
            mapErrorsFn: injector.get(VALIDATION_MAP_ERRORS_FN),
            targetSelector: injector.get(VALIDATION_TARGET_SELECTOR),
            validateOnSubmit: injector.get(VALIDATION_VALIDATE_ON_SUBMIT),
        };
        this.elRef = injector.get(ElementRef);
    }
    /**
     * @return {?}
     */
    get group() {
        return ((this.groupRef || ((/** @type {?} */ ({})))).form ||
            (this.groupName || ((/** @type {?} */ ({})))).control);
    }
    /**
     * @return {?}
     */
    get parent() {
        return this.parentRef || { getStream: (/**
             * @return {?}
             */
            () => null) };
    }
    /**
     * @return {?}
     */
    get blueprints() {
        return Object.assign({}, BLUEPRINTS, (this._blueprints ||
            this.parent.blueprints ||
            this.config.blueprints ||
            {}));
    }
    /**
     * @return {?}
     */
    get errorTemplate() {
        return (this._errorTemplate ||
            this.parent.errorTemplate ||
            this.config.errorTemplate);
    }
    /**
     * @return {?}
     */
    get invalidClasses() {
        return (this._invalidClasses ||
            this.parent.invalidClasses ||
            this.config.invalidClasses);
    }
    /**
     * @return {?}
     */
    get mapErrorsFn() {
        return (this._mapErrorsFn || this.parent.mapErrorsFn || this.config.mapErrorsFn);
    }
    /**
     * @return {?}
     */
    get skipValidation() {
        return (evalPropTruthy(this._skipValidation) ||
            this.parent.skipValidation ||
            this.config.skipValidation);
    }
    /**
     * @return {?}
     */
    get targetSelector() {
        return (this._targetSelector ||
            this.parent.targetSelector ||
            this.config.targetSelector);
    }
    /**
     * @return {?}
     */
    get validateOnSubmit() {
        return (evalPropTruthy(this._validateOnSubmit) ||
            this.parent.validateOnSubmit ||
            this.config.validateOnSubmit);
    }
    /**
     * @param {?} streamName
     * @return {?}
     */
    getStream(streamName) {
        return merge(this[streamName + '$']
            ? ((/** @type {?} */ (this[streamName + '$']))).asObservable()
            : NEVER, this.parent.getStream(streamName) || NEVER);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() { }
}
AbstractValidationDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line */
                selector: "abstractValidationDirective"
            },] }
];
/** @nocollapse */
AbstractValidationDirective.ctorParameters = () => [
    { type: Injector }
];
AbstractValidationDirective.propDecorators = {
    _blueprints: [{ type: Input, args: ['blueprints',] }],
    _errorTemplate: [{ type: Input, args: ['errorTemplate',] }],
    _invalidClasses: [{ type: Input, args: ['invalidClasses',] }],
    _mapErrorsFn: [{ type: Input, args: ['mapErrorsFn',] }],
    _skipValidation: [{ type: Input, args: ['skipValidation',] }],
    _targetSelector: [{ type: Input, args: ['targetSelector',] }],
    _validateOnSubmit: [{ type: Input, args: ['validateOnSubmit',] }]
};
if (false) {
    /** @type {?} */
    AbstractValidationDirective.prototype._blueprints;
    /** @type {?} */
    AbstractValidationDirective.prototype._errorTemplate;
    /** @type {?} */
    AbstractValidationDirective.prototype._invalidClasses;
    /** @type {?} */
    AbstractValidationDirective.prototype._mapErrorsFn;
    /** @type {?} */
    AbstractValidationDirective.prototype._skipValidation;
    /** @type {?} */
    AbstractValidationDirective.prototype._targetSelector;
    /** @type {?} */
    AbstractValidationDirective.prototype._validateOnSubmit;
    /** @type {?} */
    AbstractValidationDirective.prototype.config;
    /** @type {?} */
    AbstractValidationDirective.prototype.elRef;
    /** @type {?} */
    AbstractValidationDirective.prototype.groupName;
    /** @type {?} */
    AbstractValidationDirective.prototype.groupRef;
    /** @type {?} */
    AbstractValidationDirective.prototype.parentRef;
    /** @type {?} */
    AbstractValidationDirective.prototype.injector;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJzdHJhY3QtdmFsaWRhdGlvbi5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4LXZhbGlkYXRlL2NvcmUvIiwic291cmNlcyI6WyJsaWIvYWJzdHJhY3RzL2Fic3RyYWN0LXZhbGlkYXRpb24uZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsUUFBUSxFQUNSLEtBQUssR0FJTixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBNkIsTUFBTSxNQUFNLENBQUM7QUFDL0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUcxQyxPQUFPLEVBQ0wscUJBQXFCLEVBQ3JCLHlCQUF5QixFQUN6QiwwQkFBMEIsRUFDMUIsd0JBQXdCLEVBQ3hCLDBCQUEwQixFQUMxQiw2QkFBNkIsR0FDOUIsTUFBTSxXQUFXLENBQUM7QUFDbkIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQU0xQyxNQUFNLE9BQU8sMkJBQTJCOzs7O0lBOEZ0QyxZQUFtQixRQUFrQjtRQUFsQixhQUFRLEdBQVIsUUFBUSxDQUFVO1FBQ25DLElBQUksQ0FBQyxNQUFNLEdBQUc7WUFDWixVQUFVLEVBQUUsUUFBUSxDQUFDLEdBQUcsQ0FBQyxxQkFBcUIsQ0FBQztZQUMvQyxhQUFhLEVBQUUsUUFBUSxDQUFDLEdBQUcsQ0FBQyx5QkFBeUIsQ0FBQztZQUN0RCxjQUFjLEVBQUUsUUFBUSxDQUFDLEdBQUcsQ0FBQywwQkFBMEIsQ0FBQztZQUN4RCxXQUFXLEVBQUUsUUFBUSxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsQ0FBQztZQUNuRCxjQUFjLEVBQUUsUUFBUSxDQUFDLEdBQUcsQ0FBQywwQkFBMEIsQ0FBQztZQUN4RCxnQkFBZ0IsRUFBRSxRQUFRLENBQUMsR0FBRyxDQUFDLDZCQUE2QixDQUFDO1NBQzlELENBQUM7UUFDRixJQUFJLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDeEMsQ0FBQzs7OztJQWxGRCxJQUFJLEtBQUs7UUFDUCxPQUFPLENBQ0wsQ0FBQyxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsbUJBQUEsRUFBRSxFQUFzQixDQUFDLENBQUMsQ0FBQyxJQUFJO1lBQ2xELENBQUMsSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFDLG1CQUFBLEVBQUUsRUFBaUIsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUNsRCxDQUFDO0lBQ0osQ0FBQzs7OztJQUVELElBQUksTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDLFNBQVMsSUFBSSxFQUFFLFNBQVM7OztZQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQSxFQUFFLENBQUM7SUFDckQsQ0FBQzs7OztJQUVELElBQUksVUFBVTtRQUNaLHlCQUNLLFVBQVUsRUFDVixDQUFDLElBQUksQ0FBQyxXQUFXO1lBQ2xCLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVTtZQUN0QixJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVU7WUFDdEIsRUFBRSxDQUFDLEVBQ0w7SUFDSixDQUFDOzs7O0lBRUQsSUFBSSxhQUFhO1FBQ2YsT0FBTyxDQUNMLElBQUksQ0FBQyxjQUFjO1lBQ25CLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYTtZQUN6QixJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FDMUIsQ0FBQztJQUNKLENBQUM7Ozs7SUFFRCxJQUFJLGNBQWM7UUFDaEIsT0FBTyxDQUNMLElBQUksQ0FBQyxlQUFlO1lBQ3BCLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYztZQUMxQixJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FDM0IsQ0FBQztJQUNKLENBQUM7Ozs7SUFFRCxJQUFJLFdBQVc7UUFDYixPQUFPLENBQ0wsSUFBSSxDQUFDLFlBQVksSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FDeEUsQ0FBQztJQUNKLENBQUM7Ozs7SUFFRCxJQUFJLGNBQWM7UUFDaEIsT0FBTyxDQUNMLGNBQWMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYztZQUMxQixJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FDM0IsQ0FBQztJQUNKLENBQUM7Ozs7SUFFRCxJQUFJLGNBQWM7UUFDaEIsT0FBTyxDQUNMLElBQUksQ0FBQyxlQUFlO1lBQ3BCLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYztZQUMxQixJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FDM0IsQ0FBQztJQUNKLENBQUM7Ozs7SUFFRCxJQUFJLGdCQUFnQjtRQUNsQixPQUFPLENBQ0wsY0FBYyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztZQUN0QyxJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQjtZQUM1QixJQUFJLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUM3QixDQUFDO0lBQ0osQ0FBQzs7Ozs7SUFtQkQsU0FBUyxDQUFDLFVBQWlDO1FBQ3pDLE9BQU8sS0FBSyxDQUNWLElBQUksQ0FBQyxVQUFVLEdBQUcsR0FBRyxDQUFDO1lBQ3BCLENBQUMsQ0FBQyxDQUFDLG1CQUFBLElBQUksQ0FBQyxVQUFVLEdBQUcsR0FBRyxDQUFDLEVBQTRCLENBQUMsQ0FBQyxZQUFZLEVBQUU7WUFDckUsQ0FBQyxDQUFDLEtBQUssRUFDVCxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxLQUFLLENBQzNDLENBQUM7SUFDSixDQUFDOzs7O0lBRUQsV0FBVyxLQUFJLENBQUM7OztZQXZIakIsU0FBUyxTQUFDOztnQkFFVCxRQUFRLEVBQUUsNkJBQTZCO2FBQ3hDOzs7O1lBeEJDLFFBQVE7OzswQkEwQlAsS0FBSyxTQUFDLFlBQVk7NkJBR2xCLEtBQUssU0FBQyxlQUFlOzhCQUdyQixLQUFLLFNBQUMsZ0JBQWdCOzJCQUd0QixLQUFLLFNBQUMsYUFBYTs4QkFHbkIsS0FBSyxTQUFDLGdCQUFnQjs4QkFHdEIsS0FBSyxTQUFDLGdCQUFnQjtnQ0FHdEIsS0FBSyxTQUFDLGtCQUFrQjs7OztJQWxCekIsa0RBQ21DOztJQUVuQyxxREFDNkM7O0lBRTdDLHNEQUN3Qjs7SUFFeEIsbURBQ3FDOztJQUVyQyxzREFDeUI7O0lBRXpCLHNEQUN3Qjs7SUFFeEIsd0RBQzJCOztJQXFFM0IsNkNBQTBCOztJQUMxQiw0Q0FBa0I7O0lBQ2xCLGdEQUF5Qjs7SUFDekIsK0NBQTZCOztJQUM3QixnREFBb0M7O0lBQ3hCLCtDQUF5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERpcmVjdGl2ZSxcbiAgRWxlbWVudFJlZixcbiAgSW5qZWN0b3IsXG4gIElucHV0LFxuICBPbkRlc3Ryb3ksXG4gIFRlbXBsYXRlUmVmLFxuICBUeXBlLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Hcm91cCwgRm9ybUdyb3VwRGlyZWN0aXZlLCBGb3JtR3JvdXBOYW1lIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgbWVyZ2UsIE5FVkVSLCBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBCTFVFUFJJTlRTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IFZhbGlkYXRpb25Hcm91cERpcmVjdGl2ZSB9IGZyb20gJy4uL2RpcmVjdGl2ZXMvdmFsaWRhdGlvbi1ncm91cC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVmFsaWRhdGlvbiB9IGZyb20gJy4uL21vZGVscyc7XG5pbXBvcnQge1xuICBWQUxJREFUSU9OX0JMVUVQUklOVFMsXG4gIFZBTElEQVRJT05fRVJST1JfVEVNUExBVEUsXG4gIFZBTElEQVRJT05fSU5WQUxJRF9DTEFTU0VTLFxuICBWQUxJREFUSU9OX01BUF9FUlJPUlNfRk4sXG4gIFZBTElEQVRJT05fVEFSR0VUX1NFTEVDVE9SLFxuICBWQUxJREFUSU9OX1ZBTElEQVRFX09OX1NVQk1JVCxcbn0gZnJvbSAnLi4vdG9rZW5zJztcbmltcG9ydCB7IGV2YWxQcm9wVHJ1dGh5IH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgLyogdHNsaW50OmRpc2FibGUtbmV4dC1saW5lICovXG4gIHNlbGVjdG9yOiBcImFic3RyYWN0VmFsaWRhdGlvbkRpcmVjdGl2ZVwiXG59KVxuZXhwb3J0IGNsYXNzIEFic3RyYWN0VmFsaWRhdGlvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gIEBJbnB1dCgnYmx1ZXByaW50cycpXG4gIF9ibHVlcHJpbnRzOiBWYWxpZGF0aW9uLkJsdWVwcmludHM7XG5cbiAgQElucHV0KCdlcnJvclRlbXBsYXRlJylcbiAgX2Vycm9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4gfCBUeXBlPGFueT47XG5cbiAgQElucHV0KCdpbnZhbGlkQ2xhc3NlcycpXG4gIF9pbnZhbGlkQ2xhc3Nlczogc3RyaW5nO1xuXG4gIEBJbnB1dCgnbWFwRXJyb3JzRm4nKVxuICBfbWFwRXJyb3JzRm46IFZhbGlkYXRpb24uTWFwRXJyb3JzRm47XG5cbiAgQElucHV0KCdza2lwVmFsaWRhdGlvbicpXG4gIF9za2lwVmFsaWRhdGlvbjogYm9vbGVhbjtcblxuICBASW5wdXQoJ3RhcmdldFNlbGVjdG9yJylcbiAgX3RhcmdldFNlbGVjdG9yOiBzdHJpbmc7XG5cbiAgQElucHV0KCd2YWxpZGF0ZU9uU3VibWl0JylcbiAgX3ZhbGlkYXRlT25TdWJtaXQ6IGJvb2xlYW47XG5cbiAgZ2V0IGdyb3VwKCk6IEZvcm1Hcm91cCB7XG4gICAgcmV0dXJuIChcbiAgICAgICh0aGlzLmdyb3VwUmVmIHx8ICh7fSBhcyBGb3JtR3JvdXBEaXJlY3RpdmUpKS5mb3JtIHx8XG4gICAgICAodGhpcy5ncm91cE5hbWUgfHwgKHt9IGFzIEZvcm1Hcm91cE5hbWUpKS5jb250cm9sXG4gICAgKTtcbiAgfVxuXG4gIGdldCBwYXJlbnQoKTogUGFydGlhbDxWYWxpZGF0aW9uR3JvdXBEaXJlY3RpdmU+IHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRSZWYgfHwgeyBnZXRTdHJlYW06ICgpID0+IG51bGwgfTtcbiAgfVxuXG4gIGdldCBibHVlcHJpbnRzKCk6IFZhbGlkYXRpb24uQmx1ZXByaW50cyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLkJMVUVQUklOVFMsXG4gICAgICAuLi4odGhpcy5fYmx1ZXByaW50cyB8fFxuICAgICAgICB0aGlzLnBhcmVudC5ibHVlcHJpbnRzIHx8XG4gICAgICAgIHRoaXMuY29uZmlnLmJsdWVwcmludHMgfHxcbiAgICAgICAge30pLFxuICAgIH07XG4gIH1cblxuICBnZXQgZXJyb3JUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHwgVHlwZTxhbnk+IHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fZXJyb3JUZW1wbGF0ZSB8fFxuICAgICAgdGhpcy5wYXJlbnQuZXJyb3JUZW1wbGF0ZSB8fFxuICAgICAgdGhpcy5jb25maWcuZXJyb3JUZW1wbGF0ZVxuICAgICk7XG4gIH1cblxuICBnZXQgaW52YWxpZENsYXNzZXMoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5faW52YWxpZENsYXNzZXMgfHxcbiAgICAgIHRoaXMucGFyZW50LmludmFsaWRDbGFzc2VzIHx8XG4gICAgICB0aGlzLmNvbmZpZy5pbnZhbGlkQ2xhc3Nlc1xuICAgICk7XG4gIH1cblxuICBnZXQgbWFwRXJyb3JzRm4oKTogVmFsaWRhdGlvbi5NYXBFcnJvcnNGbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuX21hcEVycm9yc0ZuIHx8IHRoaXMucGFyZW50Lm1hcEVycm9yc0ZuIHx8IHRoaXMuY29uZmlnLm1hcEVycm9yc0ZuXG4gICAgKTtcbiAgfVxuXG4gIGdldCBza2lwVmFsaWRhdGlvbigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXZhbFByb3BUcnV0aHkodGhpcy5fc2tpcFZhbGlkYXRpb24pIHx8XG4gICAgICB0aGlzLnBhcmVudC5za2lwVmFsaWRhdGlvbiB8fFxuICAgICAgdGhpcy5jb25maWcuc2tpcFZhbGlkYXRpb25cbiAgICApO1xuICB9XG5cbiAgZ2V0IHRhcmdldFNlbGVjdG9yKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuX3RhcmdldFNlbGVjdG9yIHx8XG4gICAgICB0aGlzLnBhcmVudC50YXJnZXRTZWxlY3RvciB8fFxuICAgICAgdGhpcy5jb25maWcudGFyZ2V0U2VsZWN0b3JcbiAgICApO1xuICB9XG5cbiAgZ2V0IHZhbGlkYXRlT25TdWJtaXQoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIGV2YWxQcm9wVHJ1dGh5KHRoaXMuX3ZhbGlkYXRlT25TdWJtaXQpIHx8XG4gICAgICB0aGlzLnBhcmVudC52YWxpZGF0ZU9uU3VibWl0IHx8XG4gICAgICB0aGlzLmNvbmZpZy52YWxpZGF0ZU9uU3VibWl0XG4gICAgKTtcbiAgfVxuXG4gIGNvbmZpZzogVmFsaWRhdGlvbi5Db25maWc7XG4gIGVsUmVmOiBFbGVtZW50UmVmO1xuICBncm91cE5hbWU6IEZvcm1Hcm91cE5hbWU7XG4gIGdyb3VwUmVmOiBGb3JtR3JvdXBEaXJlY3RpdmU7XG4gIHBhcmVudFJlZjogVmFsaWRhdGlvbkdyb3VwRGlyZWN0aXZlO1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBibHVlcHJpbnRzOiBpbmplY3Rvci5nZXQoVkFMSURBVElPTl9CTFVFUFJJTlRTKSxcbiAgICAgIGVycm9yVGVtcGxhdGU6IGluamVjdG9yLmdldChWQUxJREFUSU9OX0VSUk9SX1RFTVBMQVRFKSxcbiAgICAgIGludmFsaWRDbGFzc2VzOiBpbmplY3Rvci5nZXQoVkFMSURBVElPTl9JTlZBTElEX0NMQVNTRVMpLFxuICAgICAgbWFwRXJyb3JzRm46IGluamVjdG9yLmdldChWQUxJREFUSU9OX01BUF9FUlJPUlNfRk4pLFxuICAgICAgdGFyZ2V0U2VsZWN0b3I6IGluamVjdG9yLmdldChWQUxJREFUSU9OX1RBUkdFVF9TRUxFQ1RPUiksXG4gICAgICB2YWxpZGF0ZU9uU3VibWl0OiBpbmplY3Rvci5nZXQoVkFMSURBVElPTl9WQUxJREFURV9PTl9TVUJNSVQpLFxuICAgIH07XG4gICAgdGhpcy5lbFJlZiA9IGluamVjdG9yLmdldChFbGVtZW50UmVmKTtcbiAgfVxuXG4gIGdldFN0cmVhbShzdHJlYW1OYW1lOiBWYWxpZGF0aW9uLlN0cmVhbU5hbWUpOiBPYnNlcnZhYmxlPEZvcm1Hcm91cD4ge1xuICAgIHJldHVybiBtZXJnZShcbiAgICAgIHRoaXNbc3RyZWFtTmFtZSArICckJ11cbiAgICAgICAgPyAodGhpc1tzdHJlYW1OYW1lICsgJyQnXSBhcyBSZXBsYXlTdWJqZWN0PEZvcm1Hcm91cD4pLmFzT2JzZXJ2YWJsZSgpXG4gICAgICAgIDogTkVWRVIsXG4gICAgICB0aGlzLnBhcmVudC5nZXRTdHJlYW0oc3RyZWFtTmFtZSkgfHwgTkVWRVIsXG4gICAgKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge31cbn1cbiJdfQ==