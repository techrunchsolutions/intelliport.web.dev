import { __assign, __extends, __read } from 'tslib';
import { InjectionToken, ElementRef, Directive, Injector, Input, Component, ChangeDetectionStrategy, ViewEncapsulation, ViewContainerRef, ContentChild, ChangeDetectorRef, Optional, Self, SkipSelf, TemplateRef, ComponentRef, ComponentFactoryResolver, Renderer2, NgModule } from '@angular/core';
import { Subject, merge, NEVER, ReplaySubject, Subscription } from 'rxjs';
import { takeUntil, mapTo, filter, tap, map } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { FormGroupName, FormGroupDirective, NgControl, FormsModule, ReactiveFormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/constants/blueprints.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var BLUEPRINTS = {
    email: 'Please enter a valid email address.',
    max: 'Max. value should be {{ max }}. ({{ actual }} entered)',
    maxlength: 'Max. {{ requiredLength }} characters are allowed. (has {{ actualLength }})',
    min: 'Min. value should be {{ min }}. ({{ actual }} entered)',
    minlength: 'Min. {{ requiredLength }} characters are required. (has {{ actualLength }})',
    pattern: 'Invalid pattern. Please review your input.',
    required: 'This field is required.',
    passwordMismatch: 'Passwords do not match.',
    invalidPassword: 'Password should include {{ description }}.',
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/constants/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/blueprints.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var VALIDATION_BLUEPRINTS = new InjectionToken('validation.blueprints');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/error-template.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var VALIDATION_ERROR_TEMPLATE = new InjectionToken('validation.error.template');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/invalid-classes.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var VALIDATION_INVALID_CLASSES = new InjectionToken('validation.invalid.classes');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/map-errors-fn.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var VALIDATION_MAP_ERRORS_FN = new InjectionToken('validation.map.errors.fn');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/target-selector.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var VALIDATION_TARGET_SELECTOR = new InjectionToken('validation.target.selector');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/validate-on-submit.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var VALIDATION_VALIDATE_ON_SUBMIT = new InjectionToken('validation.validate.on.submit');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/common.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} prop
 * @return {?}
 */
function evalPropTruthy(prop) {
    return prop || typeof prop === 'string';
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/string-utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var CHARMAP = {
    á: 'a',
    Á: 'A',
    À: 'A',
    à: 'a',
    Ă: 'A',
    ă: 'a',
    Ắ: 'A',
    ắ: 'a',
    ằ: 'a',
    Ằ: 'A',
    Ẵ: 'A',
    ẵ: 'a',
    ẳ: 'a',
    Ẳ: 'A',
    â: 'a',
    Â: 'A',
    ấ: 'a',
    Ấ: 'A',
    ầ: 'a',
    Ầ: 'A',
    ǎ: 'a',
    Ǎ: 'A',
    å: 'a',
    Å: 'A',
    Ǻ: 'A',
    ǻ: 'a',
    ä: 'a',
    Ä: 'A',
    a̋: 'a',
    A̋: 'A',
    Ã: 'A',
    ã: 'a',
    A̧: 'A',
    a̧: 'a',
    Ą: 'A',
    ą: 'a',
    ā: 'a',
    Ā: 'A',
    ȁ: 'a',
    Ȁ: 'A',
    ȃ: 'a',
    Ȃ: 'A',
    Ặ: 'A',
    ặ: 'a',
    æ: 'a',
    Æ: 'A',
    Ǽ: 'A',
    ǽ: 'a',
    b̌: 'b',
    B̌: 'B',
    b̧: 'b',
    B̧: 'B',
    ć: 'c',
    Ć: 'C',
    c̆: 'c',
    C̆: 'C',
    ĉ: 'c',
    Ĉ: 'C',
    č: 'c',
    Č: 'C',
    ċ: 'c',
    Ċ: 'C',
    Ç: 'C',
    ç: 'c',
    Ḉ: 'C',
    ḉ: 'c',
    č̣: 'c',
    Č̣: 'C',
    Ď: 'D',
    ď: 'd',
    ḑ: 'd',
    Ḑ: 'D',
    đ: 'd',
    Đ: 'D',
    Ð: 'D',
    ð: 'd',
    É: 'E',
    é: 'e',
    È: 'E',
    è: 'e',
    Ĕ: 'E',
    ĕ: 'e',
    ê: 'e',
    Ê: 'E',
    Ế: 'E',
    ế: 'e',
    ề: 'e',
    Ề: 'E',
    Ê̌: 'E',
    ê̌: 'e',
    Ě: 'E',
    ě: 'e',
    ë: 'e',
    Ë: 'E',
    e̋: 'e',
    E̋: 'E',
    Ė: 'E',
    ė: 'e',
    Ȩ: 'E',
    ȩ: 'e',
    ḝ: 'e',
    Ḝ: 'E',
    Ę: 'E',
    ę: 'e',
    Ē: 'E',
    ē: 'e',
    Ḗ: 'E',
    ḗ: 'e',
    Ḕ: 'E',
    ḕ: 'e',
    Ȅ: 'E',
    ȅ: 'e',
    Ȇ: 'E',
    ȇ: 'e',
    ɛ̧: 'e',
    Ɛ̧: 'E',
    f̌: 'f',
    F̌: 'F',
    ƒ: 'f',
    ǵ: 'g',
    Ǵ: 'G',
    ğ: 'g',
    Ğ: 'G',
    Ĝ: 'G',
    ĝ: 'g',
    ǧ: 'g',
    Ǧ: 'G',
    Ġ: 'G',
    ġ: 'g',
    ģ: 'g',
    Ģ: 'G',
    Ĥ: 'H',
    ĥ: 'h',
    ȟ: 'h',
    Ȟ: 'H',
    ḩ: 'h',
    Ḩ: 'H',
    ħ: 'h',
    Ħ: 'H',
    ḫ: 'h',
    Ḫ: 'H',
    í: 'i',
    Í: 'I',
    Ì: 'I',
    ì: 'i',
    Ĭ: 'I',
    ĭ: 'i',
    Î: 'I',
    î: 'i',
    ǐ: 'i',
    Ǐ: 'I',
    ï: 'i',
    Ï: 'I',
    ḯ: 'i',
    Ḯ: 'I',
    I̋: 'I',
    i̋: 'i',
    ĩ: 'i',
    Ĩ: 'I',
    İ: 'I',
    I̧: 'I',
    i̧: 'i',
    Į: 'I',
    į: 'i',
    ī: 'i',
    Ī: 'I',
    ȉ: 'i',
    Ȉ: 'I',
    ȋ: 'i',
    Ȋ: 'I',
    ĳ: 'i',
    Ĳ: 'I',
    ı: 'i',
    Ɨ̧: 'I',
    ɨ̧: 'i',
    ĵ: 'j',
    Ĵ: 'J',
    ǰ: 'j',
    J̌: 'J',
    Ḱ: 'K',
    ḱ: 'k',
    k̆: 'k',
    K̆: 'K',
    ǩ: 'k',
    Ǩ: 'K',
    ķ: 'k',
    Ķ: 'K',
    Ĺ: 'L',
    ĺ: 'l',
    Ľ: 'L',
    ľ: 'l',
    ļ: 'l',
    Ļ: 'L',
    ł: 'l',
    Ł: 'l',
    Ŀ: 'L',
    ŀ: 'l',
    Ḿ: 'M',
    ḿ: 'm',
    m̆: 'm',
    M̆: 'M',
    m̌: 'm',
    M̌: 'M',
    M̧: 'M',
    m̧: 'm',
    Ń: 'N',
    ń: 'n',
    Ǹ: 'N',
    ǹ: 'n',
    n̆: 'n',
    N̆: 'N',
    Ň: 'N',
    ň: 'n',
    ñ: 'n',
    Ñ: 'N',
    Ņ: 'N',
    ņ: 'n',
    ó: 'o',
    Ó: 'O',
    Ò: 'O',
    ò: 'o',
    Ŏ: 'O',
    ŏ: 'o',
    Ô: 'O',
    ô: 'o',
    ố: 'o',
    Ố: 'O',
    ồ: 'o',
    Ồ: 'O',
    Ǒ: 'O',
    ǒ: 'o',
    Ö: 'O',
    ö: 'o',
    ő: 'o',
    Ő: 'O',
    Õ: 'O',
    õ: 'o',
    ṍ: 'o',
    Ṍ: 'O',
    Ø: 'O',
    ø: 'o',
    Ǿ: 'O',
    ǿ: 'o',
    o̧: 'o',
    O̧: 'O',
    Ō: 'O',
    ō: 'o',
    ṓ: 'o',
    Ṓ: 'O',
    ṑ: 'o',
    Ṑ: 'O',
    ȍ: 'o',
    Ȍ: 'O',
    ȏ: 'o',
    Ȏ: 'O',
    ơ: 'o',
    Ơ: 'O',
    œ: 'o',
    Œ: 'O',
    ṕ: 'p',
    Ṕ: 'P',
    p̆: 'p',
    P̆: 'P',
    P̌: 'P',
    p̌: 'p',
    Q̌: 'Q',
    q̌: 'q',
    Q̧: 'Q',
    q̧: 'q',
    ŕ: 'r',
    Ŕ: 'R',
    r̆: 'r',
    R̆: 'R',
    Ř: 'R',
    ř: 'r',
    ŗ: 'r',
    Ŗ: 'R',
    Ř̩: 'R',
    ř̩: 'r',
    ȑ: 'r',
    Ȑ: 'R',
    Ȓ: 'R',
    ȓ: 'r',
    Ś: 'S',
    ś: 's',
    Ṥ: 'S',
    ṥ: 's',
    Ŝ: 'S',
    ŝ: 's',
    š: 's',
    Š: 'S',
    Ṧ: 'S',
    ṧ: 's',
    ş: 's',
    Ş: 'S',
    ș: 's',
    Ș: 'S',
    ſ: 's',
    T̆: 'T',
    t̆: 't',
    Ť: 'T',
    ť: 't',
    ţ: 't',
    Ţ: 'T',
    Ț: 'T',
    ț: 't',
    ŧ: 't',
    Ŧ: 'T',
    Ú: 'U',
    ú: 'u',
    ù: 'u',
    Ù: 'U',
    ŭ: 'u',
    Ŭ: 'U',
    Û: 'U',
    û: 'u',
    ǔ: 'u',
    Ǔ: 'U',
    Ů: 'U',
    ů: 'u',
    ü: 'u',
    Ü: 'U',
    ǘ: 'u',
    Ǘ: 'U',
    Ǜ: 'U',
    ǜ: 'u',
    ǚ: 'u',
    Ǚ: 'U',
    ǖ: 'u',
    Ǖ: 'U',
    Ű: 'U',
    ű: 'u',
    ũ: 'u',
    Ũ: 'U',
    Ṹ: 'U',
    ṹ: 'u',
    u̧: 'u',
    U̧: 'U',
    Ų: 'U',
    ų: 'u',
    Ū: 'U',
    ū: 'u',
    ȕ: 'u',
    Ȕ: 'U',
    Ȗ: 'U',
    ȗ: 'u',
    ư: 'u',
    Ư: 'U',
    ứ: 'u',
    Ứ: 'U',
    ừ: 'u',
    Ừ: 'U',
    V̆: 'V',
    v̆: 'v',
    v̌: 'v',
    V̌: 'V',
    Ẃ: 'W',
    ẃ: 'w',
    Ẁ: 'W',
    ẁ: 'w',
    ŵ: 'w',
    Ŵ: 'W',
    W̌: 'W',
    w̌: 'w',
    x́: 'x',
    X́: 'X',
    X̆: 'X',
    x̆: 'x',
    x̌: 'x',
    X̌: 'X',
    X̧: 'X',
    x̧: 'x',
    Ý: 'Y',
    ý: 'y',
    Ỳ: 'Y',
    ỳ: 'y',
    y̆: 'y',
    Y̆: 'Y',
    Ŷ: 'Y',
    ŷ: 'y',
    y̌: 'y',
    Y̌: 'Y',
    ÿ: 'y',
    Ÿ: 'Y',
    ź: 'z',
    Ź: 'Z',
    Ž: 'Z',
    ž: 'z',
    Ż: 'Z',
    ż: 'z',
    Z̧: 'Z',
    z̧: 'z',
};
/**
 * @param {?} text
 * @return {?}
 */
function interpolate(text) {
    return '{{\\s*(' + text + ')\\s*}}';
}
/**
 * @param {?} blueprint
 * @param {?} map
 * @param {?=} interpolation
 * @return {?}
 */
function mapReplace(blueprint, map, interpolation) {
    if (typeof blueprint !== 'string')
        return '';
    if (typeof map !== 'object')
        return blueprint;
    /** @type {?} */
    var expression = Object.keys(map).join('|');
    /** @type {?} */
    var mapRegExp = new RegExp(interpolation ? interpolate(expression) : expression, 'g');
    return blueprint.replace(mapRegExp, (/**
     * @param {?} match
     * @return {?}
     */
    function (match) {
        if (interpolation)
            return String(map[match.replace(/\{\{\s*|\s*\}\}/g, '')]);
        return String(map[match]);
    }));
}
/**
 * @param {?} text
 * @return {?}
 */
function normalizeDiacritics(text) {
    return mapReplace(text, CHARMAP);
}
/**
 * @param {?} list
 * @return {?}
 */
function addCommas(list) {
    return list.reduce((/**
     * @param {?} acc
     * @param {?} item
     * @param {?} index
     * @param {?} __3
     * @return {?}
     */
    function (acc, item, index, _a) {
        var length = _a.length;
        return acc +
            (!index
                ? ''
                : length < 3
                    ? ' and '
                    : index === length - 1
                        ? ', and '
                        : ', ') +
            item;
    }), '');
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/mappers.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} key
 * @param {?} params
 * @param {?} blueprint
 * @return {?}
 */
function generateValidationError(key, params, blueprint) {
    return {
        key: key,
        params: params,
        message: mapReplace(blueprint, params, true),
    };
}
/** @type {?} */
var defaultMapErrorsFn = (/**
 * @param {?} errors
 * @return {?}
 */
function (errors) {
    return errors;
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/rxjs-utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated doesn't work with Ivy, will be removed in v1.0
 * @template T
 * @param {?} component
 * @return {?}
 */
function takeUntilDestroy(component) {
    /** @type {?} */
    var proto = Object.getPrototypeOf(component);
    /** @type {?} */
    var onDestroy = proto.ngOnDestroy;
    /** @type {?} */
    var destroy$ = new Subject();
    proto.ngOnDestroy = (/**
     * @return {?}
     */
    function () {
        onDestroy.apply(this, arguments);
        destroy$.next();
        destroy$.complete();
    });
    return takeUntil(destroy$);
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/abstracts/abstract-validation.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AbstractValidationDirective = /** @class */ (function () {
    function AbstractValidationDirective(injector) {
        this.injector = injector;
        this.config = {
            blueprints: injector.get(VALIDATION_BLUEPRINTS),
            errorTemplate: injector.get(VALIDATION_ERROR_TEMPLATE),
            invalidClasses: injector.get(VALIDATION_INVALID_CLASSES),
            mapErrorsFn: injector.get(VALIDATION_MAP_ERRORS_FN),
            targetSelector: injector.get(VALIDATION_TARGET_SELECTOR),
            validateOnSubmit: injector.get(VALIDATION_VALIDATE_ON_SUBMIT),
        };
        this.elRef = injector.get(ElementRef);
    }
    Object.defineProperty(AbstractValidationDirective.prototype, "group", {
        get: /**
         * @return {?}
         */
        function () {
            return ((this.groupRef || ((/** @type {?} */ ({})))).form ||
                (this.groupName || ((/** @type {?} */ ({})))).control);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractValidationDirective.prototype, "parent", {
        get: /**
         * @return {?}
         */
        function () {
            return this.parentRef || { getStream: (/**
                 * @return {?}
                 */
                function () { return null; }) };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractValidationDirective.prototype, "blueprints", {
        get: /**
         * @return {?}
         */
        function () {
            return __assign({}, BLUEPRINTS, (this._blueprints ||
                this.parent.blueprints ||
                this.config.blueprints ||
                {}));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractValidationDirective.prototype, "errorTemplate", {
        get: /**
         * @return {?}
         */
        function () {
            return (this._errorTemplate ||
                this.parent.errorTemplate ||
                this.config.errorTemplate);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractValidationDirective.prototype, "invalidClasses", {
        get: /**
         * @return {?}
         */
        function () {
            return (this._invalidClasses ||
                this.parent.invalidClasses ||
                this.config.invalidClasses);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractValidationDirective.prototype, "mapErrorsFn", {
        get: /**
         * @return {?}
         */
        function () {
            return (this._mapErrorsFn || this.parent.mapErrorsFn || this.config.mapErrorsFn);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractValidationDirective.prototype, "skipValidation", {
        get: /**
         * @return {?}
         */
        function () {
            return (evalPropTruthy(this._skipValidation) ||
                this.parent.skipValidation ||
                this.config.skipValidation);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractValidationDirective.prototype, "targetSelector", {
        get: /**
         * @return {?}
         */
        function () {
            return (this._targetSelector ||
                this.parent.targetSelector ||
                this.config.targetSelector);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AbstractValidationDirective.prototype, "validateOnSubmit", {
        get: /**
         * @return {?}
         */
        function () {
            return (evalPropTruthy(this._validateOnSubmit) ||
                this.parent.validateOnSubmit ||
                this.config.validateOnSubmit);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} streamName
     * @return {?}
     */
    AbstractValidationDirective.prototype.getStream = /**
     * @param {?} streamName
     * @return {?}
     */
    function (streamName) {
        return merge(this[streamName + '$']
            ? ((/** @type {?} */ (this[streamName + '$']))).asObservable()
            : NEVER, this.parent.getStream(streamName) || NEVER);
    };
    /**
     * @return {?}
     */
    AbstractValidationDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () { };
    AbstractValidationDirective.decorators = [
        { type: Directive, args: [{
                    /* tslint:disable-next-line */
                    selector: "abstractValidationDirective"
                },] }
    ];
    /** @nocollapse */
    AbstractValidationDirective.ctorParameters = function () { return [
        { type: Injector }
    ]; };
    AbstractValidationDirective.propDecorators = {
        _blueprints: [{ type: Input, args: ['blueprints',] }],
        _errorTemplate: [{ type: Input, args: ['errorTemplate',] }],
        _invalidClasses: [{ type: Input, args: ['invalidClasses',] }],
        _mapErrorsFn: [{ type: Input, args: ['mapErrorsFn',] }],
        _skipValidation: [{ type: Input, args: ['skipValidation',] }],
        _targetSelector: [{ type: Input, args: ['targetSelector',] }],
        _validateOnSubmit: [{ type: Input, args: ['validateOnSubmit',] }]
    };
    return AbstractValidationDirective;
}());
if (false) {
    /** @type {?} */
    AbstractValidationDirective.prototype._blueprints;
    /** @type {?} */
    AbstractValidationDirective.prototype._errorTemplate;
    /** @type {?} */
    AbstractValidationDirective.prototype._invalidClasses;
    /** @type {?} */
    AbstractValidationDirective.prototype._mapErrorsFn;
    /** @type {?} */
    AbstractValidationDirective.prototype._skipValidation;
    /** @type {?} */
    AbstractValidationDirective.prototype._targetSelector;
    /** @type {?} */
    AbstractValidationDirective.prototype._validateOnSubmit;
    /** @type {?} */
    AbstractValidationDirective.prototype.config;
    /** @type {?} */
    AbstractValidationDirective.prototype.elRef;
    /** @type {?} */
    AbstractValidationDirective.prototype.groupName;
    /** @type {?} */
    AbstractValidationDirective.prototype.groupRef;
    /** @type {?} */
    AbstractValidationDirective.prototype.parentRef;
    /** @type {?} */
    AbstractValidationDirective.prototype.injector;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/abstracts/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/validation-error.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ValidationErrorComponent = /** @class */ (function () {
    function ValidationErrorComponent() {
        this.trackByFn = (/**
         * @param {?} _
         * @param {?} item
         * @return {?}
         */
        function (_, item) { return item.key; });
    }
    Object.defineProperty(ValidationErrorComponent.prototype, "errors", {
        get: /**
         * @return {?}
         */
        function () {
            return this.validationErrors || [];
        },
        enumerable: true,
        configurable: true
    });
    ValidationErrorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'validation-error',
                    template: "\n    <div *ngFor=\"let error of errors; trackBy: trackByFn\" class=\"invalid-feedback\">{{ error.message }}</div>\n  ",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None
                }] }
    ];
    return ValidationErrorComponent;
}());
if (false) {
    /** @type {?} */
    ValidationErrorComponent.prototype.validationErrors;
    /** @type {?} */
    ValidationErrorComponent.prototype.trackByFn;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/validation-target.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ValidationTargetDirective = /** @class */ (function () {
    function ValidationTargetDirective(vcRef) {
        this.vcRef = vcRef;
    }
    ValidationTargetDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[validationTarget]',
                    exportAs: 'validationTarget',
                },] }
    ];
    /** @nocollapse */
    ValidationTargetDirective.ctorParameters = function () { return [
        { type: ViewContainerRef }
    ]; };
    return ValidationTargetDirective;
}());
if (false) {
    /** @type {?} */
    ValidationTargetDirective.prototype.vcRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/validation-container.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ValidationContainerDirective = /** @class */ (function () {
    function ValidationContainerDirective() {
    }
    ValidationContainerDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[validationContainer]',
                    exportAs: 'validationContainer',
                },] }
    ];
    ValidationContainerDirective.propDecorators = {
        targetRef: [{ type: ContentChild, args: [ValidationTargetDirective, { static: false },] }]
    };
    return ValidationContainerDirective;
}());
if (false) {
    /** @type {?} */
    ValidationContainerDirective.prototype.targetRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/validation-group.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ValidationGroupDirective = /** @class */ (function (_super) {
    __extends(ValidationGroupDirective, _super);
    function ValidationGroupDirective(injector, cdRef, groupName, groupRef, parentRef) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.cdRef = cdRef;
        _this.groupName = groupName;
        _this.groupRef = groupRef;
        _this.parentRef = parentRef;
        _this.status$ = new ReplaySubject(1);
        _this.submit$ = new ReplaySubject(1);
        _this.value$ = new ReplaySubject(1);
        _this.subs = new Subscription();
        return _this;
    }
    /**
     * @private
     * @return {?}
     */
    ValidationGroupDirective.prototype.subscribeToFormSubmit = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        ((/** @type {?} */ (this.elRef.nativeElement))).onsubmit = (/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            if (_this.group.invalid)
                event.preventDefault();
            _this.submit$.next(_this.group);
            _this.cdRef.markForCheck();
        });
    };
    /**
     * @private
     * @return {?}
     */
    ValidationGroupDirective.prototype.subscribeToStatusChanges = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.subs.add(this.group.statusChanges.subscribe((/**
         * @return {?}
         */
        function () {
            _this.status$.next(_this.group);
            _this.cdRef.markForCheck();
        })));
    };
    /**
     * @private
     * @return {?}
     */
    ValidationGroupDirective.prototype.subscribeToValueChanges = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.subs.add(this.group.valueChanges.subscribe((/**
         * @return {?}
         */
        function () {
            _this.value$.next(_this.group);
            _this.cdRef.markForCheck();
        })));
    };
    /**
     * @return {?}
     */
    ValidationGroupDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (!this.parentRef)
            this.subscribeToFormSubmit();
        this.subscribeToStatusChanges();
        this.subscribeToValueChanges();
    };
    /**
     * @return {?}
     */
    ValidationGroupDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subs.unsubscribe();
    };
    ValidationGroupDirective.decorators = [
        { type: Directive, args: [{
                    /* tslint:disable-next-line */
                    selector: '[formGroup],[formGroupName]',
                    exportAs: 'validationGroup',
                },] }
    ];
    /** @nocollapse */
    ValidationGroupDirective.ctorParameters = function () { return [
        { type: Injector },
        { type: ChangeDetectorRef },
        { type: FormGroupName, decorators: [{ type: Optional }, { type: Self }] },
        { type: FormGroupDirective, decorators: [{ type: Optional }, { type: Self }] },
        { type: ValidationGroupDirective, decorators: [{ type: Optional }, { type: SkipSelf }] }
    ]; };
    return ValidationGroupDirective;
}(AbstractValidationDirective));
if (false) {
    /** @type {?} */
    ValidationGroupDirective.prototype.status$;
    /** @type {?} */
    ValidationGroupDirective.prototype.submit$;
    /** @type {?} */
    ValidationGroupDirective.prototype.value$;
    /**
     * @type {?}
     * @private
     */
    ValidationGroupDirective.prototype.subs;
    /** @type {?} */
    ValidationGroupDirective.prototype.injector;
    /** @type {?} */
    ValidationGroupDirective.prototype.cdRef;
    /** @type {?} */
    ValidationGroupDirective.prototype.groupName;
    /** @type {?} */
    ValidationGroupDirective.prototype.groupRef;
    /** @type {?} */
    ValidationGroupDirective.prototype.parentRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/validation-style.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ValidationStyleDirective = /** @class */ (function () {
    function ValidationStyleDirective(elRef) {
        this.elRef = elRef;
    }
    ValidationStyleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[validationStyle]',
                    exportAs: 'validationStyle',
                },] }
    ];
    /** @nocollapse */
    ValidationStyleDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return ValidationStyleDirective;
}());
if (false) {
    /** @type {?} */
    ValidationStyleDirective.prototype.elRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/validation.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ValidationDirective = /** @class */ (function (_super) {
    __extends(ValidationDirective, _super);
    function ValidationDirective(injector, cdRef, cfRes, control, renderer, vcRef, parentRef, markRef, targetRef, containerRef, formGroupDirective) {
        var _this = _super.call(this, injector) || this;
        _this.injector = injector;
        _this.cdRef = cdRef;
        _this.cfRes = cfRes;
        _this.control = control;
        _this.renderer = renderer;
        _this.vcRef = vcRef;
        _this.parentRef = parentRef;
        _this.markRef = markRef;
        _this.targetRef = targetRef;
        _this.containerRef = containerRef;
        _this.formGroupDirective = formGroupDirective;
        _this.isSubmitted = false;
        _this.subscriptions = new Subscription();
        return _this;
    }
    Object.defineProperty(ValidationDirective.prototype, "validation$", {
        get: /**
         * @return {?}
         */
        function () {
            return merge(this.parent.getStream('status').pipe(mapTo(null)), this.parent.getStream('value').pipe(mapTo(null)), this.parent.getStream('submit'));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} errors
     * @return {?}
     */
    ValidationDirective.prototype.buildErrors = /**
     * @private
     * @param {?} errors
     * @return {?}
     */
    function (errors) {
        var _this = this;
        return Object.keys(errors || {}).map((/**
         * @param {?} key
         * @return {?}
         */
        function (key) {
            return generateValidationError(key, errors[key], _this.blueprints[key]);
        }));
    };
    /**
     * @private
     * @return {?}
     */
    ValidationDirective.prototype.insertErrorClasses = /**
     * @private
     * @return {?}
     */
    function () {
        this.renderer.addClass(this.markElement, this.invalidClasses);
    };
    /**
     * @private
     * @this {?}
     * @param {?} errors
     * @return {?}
     */
    ValidationDirective.prototype.insertErrors = /**
     * @private
     * @this {?}
     * @param {?} errors
     * @return {?}
     */
    function (errors) {
        /** @type {?} */
        var template = this.errorTemplate;
        /** @type {?} */
        var targetRef = this.containerRef ? this.containerRef.targetRef : this.targetRef;
        /** @type {?} */
        var vcRef = targetRef ? targetRef.vcRef : this.vcRef;
        this.errorRef =
            template instanceof TemplateRef
                ? vcRef.createEmbeddedView(template, { $implicit: errors }, vcRef.length)
                : vcRef.createComponent(this.cfRes.resolveComponentFactory(template), vcRef.length, this.injector);
        if (this.errorRef instanceof ComponentRef && this.errorRef.instance)
            ((/** @type {?} */ (this.errorRef))).instance.validationErrors = errors;
    };
    /**
     * @private
     * @return {?}
     */
    ValidationDirective.prototype.removeErrorClasses = /**
     * @private
     * @return {?}
     */
    function () {
        this.renderer.removeClass(this.markElement, this.invalidClasses);
    };
    /**
     * @private
     * @return {?}
     */
    ValidationDirective.prototype.removeErrors = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.errorRef) {
            this.errorRef.destroy();
            this.errorRef = null;
        }
    };
    /**
     * @private
     * @return {?}
     */
    ValidationDirective.prototype.setMarkElement = /**
     * @private
     * @return {?}
     */
    function () {
        this.markElement =
            (this.markRef
                ? this.markRef.elRef.nativeElement
                : this.targetSelector
                    ? this.elRef.nativeElement.closest(this.targetSelector)
                    : null) || this.elRef.nativeElement;
    };
    /**
     * @private
     * @param {?} errors
     * @return {?}
     */
    ValidationDirective.prototype.shouldValidate = /**
     * @private
     * @param {?} errors
     * @return {?}
     */
    function (errors) {
        return errors.length && this.control.dirty && (!this.validateOnSubmit || this.isSubmitted);
    };
    /**
     * @private
     * @return {?}
     */
    ValidationDirective.prototype.subscribeToValidation = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var cached;
        this.subscriptions.add(this.validation$
            .pipe(filter((/**
         * @return {?}
         */
        function () { return !_this.skipValidation; })), tap((/**
         * @param {?} form
         * @return {?}
         */
        function (form) {
            if (form && _this.formGroupDirective.submitted) {
                _this.control.control.markAsDirty();
                _this.isSubmitted = true;
            }
        })), map((/**
         * @return {?}
         */
        function () {
            return _this.mapErrorsFn(_this.buildErrors(_this.control.errors), _this.buildErrors((_this.parentRef.group || ((/** @type {?} */ ({})))).errors), _this.control);
        })))
            .subscribe((/**
         * @param {?} errors
         * @return {?}
         */
        function (errors) {
            if (cached === JSON.stringify(errors))
                return;
            _this.removeErrors();
            if (_this.shouldValidate(errors)) {
                _this.insertErrors(errors);
                if (!cached)
                    _this.insertErrorClasses();
                cached = JSON.stringify(errors);
            }
            else {
                _this.removeErrorClasses();
                cached = '';
            }
            _this.cdRef.markForCheck();
        })));
    };
    /**
     * @return {?}
     */
    ValidationDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.setMarkElement();
        this.subscribeToValidation();
    };
    /**
     * @return {?}
     */
    ValidationDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.subscriptions.unsubscribe();
    };
    ValidationDirective.decorators = [
        { type: Directive, args: [{
                    /* tslint:disable-next-line */
                    selector: '[formControl],[formControlName]',
                    exportAs: 'validationDirective',
                },] }
    ];
    /** @nocollapse */
    ValidationDirective.ctorParameters = function () { return [
        { type: Injector },
        { type: ChangeDetectorRef },
        { type: ComponentFactoryResolver },
        { type: NgControl, decorators: [{ type: Self }] },
        { type: Renderer2 },
        { type: ViewContainerRef },
        { type: ValidationGroupDirective, decorators: [{ type: SkipSelf }] },
        { type: ValidationStyleDirective, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: ValidationTargetDirective, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: ValidationContainerDirective, decorators: [{ type: Optional }] },
        { type: FormGroupDirective, decorators: [{ type: Optional }] }
    ]; };
    return ValidationDirective;
}(AbstractValidationDirective));
if (false) {
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.errorRef;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.markElement;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.isSubmitted;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.subscriptions;
    /** @type {?} */
    ValidationDirective.prototype.injector;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.cdRef;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.cfRes;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.control;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.vcRef;
    /** @type {?} */
    ValidationDirective.prototype.parentRef;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.markRef;
    /** @type {?} */
    ValidationDirective.prototype.targetRef;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.containerRef;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.formGroupDirective;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/core.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxValidateCoreModule = /** @class */ (function () {
    function NgxValidateCoreModule() {
    }
    /**
     * @param {?=} config
     * @return {?}
     */
    NgxValidateCoreModule.forRoot = /**
     * @param {?=} config
     * @return {?}
     */
    function (config) {
        if (config === void 0) { config = (/** @type {?} */ ({})); }
        return {
            ngModule: NgxValidateCoreModule,
            providers: [
                {
                    provide: VALIDATION_BLUEPRINTS,
                    useValue: config.blueprints || BLUEPRINTS,
                },
                {
                    provide: VALIDATION_ERROR_TEMPLATE,
                    useValue: config.errorTemplate || ValidationErrorComponent,
                },
                {
                    provide: VALIDATION_INVALID_CLASSES,
                    useValue: config.invalidClasses || 'is-invalid',
                },
                {
                    provide: VALIDATION_MAP_ERRORS_FN,
                    useValue: config.mapErrorsFn || defaultMapErrorsFn,
                },
                {
                    provide: VALIDATION_TARGET_SELECTOR,
                    useValue: config.targetSelector,
                },
                {
                    provide: VALIDATION_VALIDATE_ON_SUBMIT,
                    useValue: config.validateOnSubmit,
                },
            ],
        };
    };
    NgxValidateCoreModule.decorators = [
        { type: NgModule, args: [{
                    imports: [CommonModule, FormsModule, ReactiveFormsModule],
                    exports: [
                        ValidationContainerDirective,
                        ValidationGroupDirective,
                        ValidationStyleDirective,
                        ValidationTargetDirective,
                        ValidationDirective,
                    ],
                    declarations: [
                        ValidationErrorComponent,
                        AbstractValidationDirective,
                        ValidationContainerDirective,
                        ValidationGroupDirective,
                        ValidationStyleDirective,
                        ValidationTargetDirective,
                        ValidationDirective,
                    ],
                    entryComponents: [ValidationErrorComponent],
                },] }
    ];
    return NgxValidateCoreModule;
}());

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/validation.model.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Validation;
(function (Validation) {
    /**
     * @record
     */
    function Blueprints() { }
    Validation.Blueprints = Blueprints;
    /**
     * @record
     */
    function ParamMap() { }
    Validation.ParamMap = ParamMap;
    /**
     * @record
     */
    function Error() { }
    Validation.Error = Error;
    if (false) {
        /** @type {?} */
        Error.prototype.key;
        /** @type {?|undefined} */
        Error.prototype.params;
        /** @type {?|undefined} */
        Error.prototype.message;
    }
})(Validation || (Validation = {}));

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/validators/password-validators.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} __0
 * @return {?}
 */
function comparePasswords(_a) {
    var _b = __read(_a, 2), controlName1 = _b[0], controlName2 = _b[1];
    return (/**
     * @param {?} group
     * @return {?}
     */
    function (group) {
        /** @type {?} */
        var password = group.get(controlName1).value;
        /** @type {?} */
        var repeat = group.get(controlName2).value;
        return !password || !repeat || password === repeat
            ? null
            : {
                passwordMismatch: {
                    fields: [controlName1, controlName2],
                },
            };
    });
}
/**
 * @param {?=} shouldContain
 * @return {?}
 */
function validatePassword(shouldContain) {
    if (shouldContain === void 0) { shouldContain = ['small', 'capital', 'number', 'special']; }
    return (/**
     * @param {?} control
     * @return {?}
     */
    function (control) {
        if (!control.value)
            return null;
        /** @type {?} */
        var value = normalizeDiacritics(control.value);
        /** @type {?} */
        var regex = {
            small: /.*[a-z].*/,
            capital: /.*[A-Z].*/,
            number: /.*[0-9].*/,
            special: /.*[^0-9a-zA-Z].*/,
        };
        /** @type {?} */
        var missing = shouldContain.filter((/**
         * @param {?} key
         * @return {?}
         */
        function (key) { return !regex[key].test(value); }));
        return missing.length
            ? {
                invalidPassword: {
                    missing: missing,
                    description: addCommas(missing.map((/**
                     * @param {?} key
                     * @return {?}
                     */
                    function (key) {
                        return ({
                            small: 'a small letter',
                            capital: 'a capital',
                            number: 'a number',
                            special: 'a special character',
                        }[key]);
                    }))),
                },
            }
            : null;
    });
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/validators/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-validate-core.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AbstractValidationDirective, BLUEPRINTS, NgxValidateCoreModule, VALIDATION_BLUEPRINTS, VALIDATION_ERROR_TEMPLATE, VALIDATION_INVALID_CLASSES, VALIDATION_MAP_ERRORS_FN, VALIDATION_TARGET_SELECTOR, VALIDATION_VALIDATE_ON_SUBMIT, ValidationContainerDirective, ValidationDirective, ValidationErrorComponent, ValidationGroupDirective, ValidationStyleDirective, ValidationTargetDirective, addCommas, comparePasswords, defaultMapErrorsFn, evalPropTruthy, generateValidationError, interpolate, mapReplace, normalizeDiacritics, takeUntilDestroy, validatePassword, ValidationContainerDirective as ɵa, ValidationTargetDirective as ɵb, ValidationGroupDirective as ɵc, AbstractValidationDirective as ɵd, ValidationStyleDirective as ɵe, ValidationDirective as ɵf, ValidationErrorComponent as ɵg, AbstractValidationDirective as ɵh, VALIDATION_BLUEPRINTS as ɵi, BLUEPRINTS as ɵj, VALIDATION_ERROR_TEMPLATE as ɵk, VALIDATION_INVALID_CLASSES as ɵl, VALIDATION_MAP_ERRORS_FN as ɵm, defaultMapErrorsFn as ɵn, VALIDATION_TARGET_SELECTOR as ɵo, VALIDATION_VALIDATE_ON_SUBMIT as ɵp };
//# sourceMappingURL=ngx-validate-core.js.map
