(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular/common'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('@ngx-validate/core', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@angular/common', '@angular/forms'], factory) :
    (global = global || self, factory((global['ngx-validate'] = global['ngx-validate'] || {}, global['ngx-validate'].core = {}), global.ng.core, global.rxjs, global.rxjs.operators, global.ng.common, global.ng.forms));
}(this, (function (exports, core, rxjs, operators, common, forms) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/constants/blueprints.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var BLUEPRINTS = {
        email: 'Please enter a valid email address.',
        max: 'Max. value should be {{ max }}. ({{ actual }} entered)',
        maxlength: 'Max. {{ requiredLength }} characters are allowed. (has {{ actualLength }})',
        min: 'Min. value should be {{ min }}. ({{ actual }} entered)',
        minlength: 'Min. {{ requiredLength }} characters are required. (has {{ actualLength }})',
        pattern: 'Invalid pattern. Please review your input.',
        required: 'This field is required.',
        passwordMismatch: 'Passwords do not match.',
        invalidPassword: 'Password should include {{ description }}.',
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/constants/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/tokens/blueprints.token.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var VALIDATION_BLUEPRINTS = new core.InjectionToken('validation.blueprints');

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/tokens/error-template.token.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var VALIDATION_ERROR_TEMPLATE = new core.InjectionToken('validation.error.template');

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/tokens/invalid-classes.token.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var VALIDATION_INVALID_CLASSES = new core.InjectionToken('validation.invalid.classes');

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/tokens/map-errors-fn.token.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var VALIDATION_MAP_ERRORS_FN = new core.InjectionToken('validation.map.errors.fn');

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/tokens/target-selector.token.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var VALIDATION_TARGET_SELECTOR = new core.InjectionToken('validation.target.selector');

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/tokens/validate-on-submit.token.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var VALIDATION_VALIDATE_ON_SUBMIT = new core.InjectionToken('validation.validate.on.submit');

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/tokens/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/utils/common.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} prop
     * @return {?}
     */
    function evalPropTruthy(prop) {
        return prop || typeof prop === 'string';
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/utils/string-utils.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var CHARMAP = {
        á: 'a',
        Á: 'A',
        À: 'A',
        à: 'a',
        Ă: 'A',
        ă: 'a',
        Ắ: 'A',
        ắ: 'a',
        ằ: 'a',
        Ằ: 'A',
        Ẵ: 'A',
        ẵ: 'a',
        ẳ: 'a',
        Ẳ: 'A',
        â: 'a',
        Â: 'A',
        ấ: 'a',
        Ấ: 'A',
        ầ: 'a',
        Ầ: 'A',
        ǎ: 'a',
        Ǎ: 'A',
        å: 'a',
        Å: 'A',
        Ǻ: 'A',
        ǻ: 'a',
        ä: 'a',
        Ä: 'A',
        a̋: 'a',
        A̋: 'A',
        Ã: 'A',
        ã: 'a',
        A̧: 'A',
        a̧: 'a',
        Ą: 'A',
        ą: 'a',
        ā: 'a',
        Ā: 'A',
        ȁ: 'a',
        Ȁ: 'A',
        ȃ: 'a',
        Ȃ: 'A',
        Ặ: 'A',
        ặ: 'a',
        æ: 'a',
        Æ: 'A',
        Ǽ: 'A',
        ǽ: 'a',
        b̌: 'b',
        B̌: 'B',
        b̧: 'b',
        B̧: 'B',
        ć: 'c',
        Ć: 'C',
        c̆: 'c',
        C̆: 'C',
        ĉ: 'c',
        Ĉ: 'C',
        č: 'c',
        Č: 'C',
        ċ: 'c',
        Ċ: 'C',
        Ç: 'C',
        ç: 'c',
        Ḉ: 'C',
        ḉ: 'c',
        č̣: 'c',
        Č̣: 'C',
        Ď: 'D',
        ď: 'd',
        ḑ: 'd',
        Ḑ: 'D',
        đ: 'd',
        Đ: 'D',
        Ð: 'D',
        ð: 'd',
        É: 'E',
        é: 'e',
        È: 'E',
        è: 'e',
        Ĕ: 'E',
        ĕ: 'e',
        ê: 'e',
        Ê: 'E',
        Ế: 'E',
        ế: 'e',
        ề: 'e',
        Ề: 'E',
        Ê̌: 'E',
        ê̌: 'e',
        Ě: 'E',
        ě: 'e',
        ë: 'e',
        Ë: 'E',
        e̋: 'e',
        E̋: 'E',
        Ė: 'E',
        ė: 'e',
        Ȩ: 'E',
        ȩ: 'e',
        ḝ: 'e',
        Ḝ: 'E',
        Ę: 'E',
        ę: 'e',
        Ē: 'E',
        ē: 'e',
        Ḗ: 'E',
        ḗ: 'e',
        Ḕ: 'E',
        ḕ: 'e',
        Ȅ: 'E',
        ȅ: 'e',
        Ȇ: 'E',
        ȇ: 'e',
        ɛ̧: 'e',
        Ɛ̧: 'E',
        f̌: 'f',
        F̌: 'F',
        ƒ: 'f',
        ǵ: 'g',
        Ǵ: 'G',
        ğ: 'g',
        Ğ: 'G',
        Ĝ: 'G',
        ĝ: 'g',
        ǧ: 'g',
        Ǧ: 'G',
        Ġ: 'G',
        ġ: 'g',
        ģ: 'g',
        Ģ: 'G',
        Ĥ: 'H',
        ĥ: 'h',
        ȟ: 'h',
        Ȟ: 'H',
        ḩ: 'h',
        Ḩ: 'H',
        ħ: 'h',
        Ħ: 'H',
        ḫ: 'h',
        Ḫ: 'H',
        í: 'i',
        Í: 'I',
        Ì: 'I',
        ì: 'i',
        Ĭ: 'I',
        ĭ: 'i',
        Î: 'I',
        î: 'i',
        ǐ: 'i',
        Ǐ: 'I',
        ï: 'i',
        Ï: 'I',
        ḯ: 'i',
        Ḯ: 'I',
        I̋: 'I',
        i̋: 'i',
        ĩ: 'i',
        Ĩ: 'I',
        İ: 'I',
        I̧: 'I',
        i̧: 'i',
        Į: 'I',
        į: 'i',
        ī: 'i',
        Ī: 'I',
        ȉ: 'i',
        Ȉ: 'I',
        ȋ: 'i',
        Ȋ: 'I',
        ĳ: 'i',
        Ĳ: 'I',
        ı: 'i',
        Ɨ̧: 'I',
        ɨ̧: 'i',
        ĵ: 'j',
        Ĵ: 'J',
        ǰ: 'j',
        J̌: 'J',
        Ḱ: 'K',
        ḱ: 'k',
        k̆: 'k',
        K̆: 'K',
        ǩ: 'k',
        Ǩ: 'K',
        ķ: 'k',
        Ķ: 'K',
        Ĺ: 'L',
        ĺ: 'l',
        Ľ: 'L',
        ľ: 'l',
        ļ: 'l',
        Ļ: 'L',
        ł: 'l',
        Ł: 'l',
        Ŀ: 'L',
        ŀ: 'l',
        Ḿ: 'M',
        ḿ: 'm',
        m̆: 'm',
        M̆: 'M',
        m̌: 'm',
        M̌: 'M',
        M̧: 'M',
        m̧: 'm',
        Ń: 'N',
        ń: 'n',
        Ǹ: 'N',
        ǹ: 'n',
        n̆: 'n',
        N̆: 'N',
        Ň: 'N',
        ň: 'n',
        ñ: 'n',
        Ñ: 'N',
        Ņ: 'N',
        ņ: 'n',
        ó: 'o',
        Ó: 'O',
        Ò: 'O',
        ò: 'o',
        Ŏ: 'O',
        ŏ: 'o',
        Ô: 'O',
        ô: 'o',
        ố: 'o',
        Ố: 'O',
        ồ: 'o',
        Ồ: 'O',
        Ǒ: 'O',
        ǒ: 'o',
        Ö: 'O',
        ö: 'o',
        ő: 'o',
        Ő: 'O',
        Õ: 'O',
        õ: 'o',
        ṍ: 'o',
        Ṍ: 'O',
        Ø: 'O',
        ø: 'o',
        Ǿ: 'O',
        ǿ: 'o',
        o̧: 'o',
        O̧: 'O',
        Ō: 'O',
        ō: 'o',
        ṓ: 'o',
        Ṓ: 'O',
        ṑ: 'o',
        Ṑ: 'O',
        ȍ: 'o',
        Ȍ: 'O',
        ȏ: 'o',
        Ȏ: 'O',
        ơ: 'o',
        Ơ: 'O',
        œ: 'o',
        Œ: 'O',
        ṕ: 'p',
        Ṕ: 'P',
        p̆: 'p',
        P̆: 'P',
        P̌: 'P',
        p̌: 'p',
        Q̌: 'Q',
        q̌: 'q',
        Q̧: 'Q',
        q̧: 'q',
        ŕ: 'r',
        Ŕ: 'R',
        r̆: 'r',
        R̆: 'R',
        Ř: 'R',
        ř: 'r',
        ŗ: 'r',
        Ŗ: 'R',
        Ř̩: 'R',
        ř̩: 'r',
        ȑ: 'r',
        Ȑ: 'R',
        Ȓ: 'R',
        ȓ: 'r',
        Ś: 'S',
        ś: 's',
        Ṥ: 'S',
        ṥ: 's',
        Ŝ: 'S',
        ŝ: 's',
        š: 's',
        Š: 'S',
        Ṧ: 'S',
        ṧ: 's',
        ş: 's',
        Ş: 'S',
        ș: 's',
        Ș: 'S',
        ſ: 's',
        T̆: 'T',
        t̆: 't',
        Ť: 'T',
        ť: 't',
        ţ: 't',
        Ţ: 'T',
        Ț: 'T',
        ț: 't',
        ŧ: 't',
        Ŧ: 'T',
        Ú: 'U',
        ú: 'u',
        ù: 'u',
        Ù: 'U',
        ŭ: 'u',
        Ŭ: 'U',
        Û: 'U',
        û: 'u',
        ǔ: 'u',
        Ǔ: 'U',
        Ů: 'U',
        ů: 'u',
        ü: 'u',
        Ü: 'U',
        ǘ: 'u',
        Ǘ: 'U',
        Ǜ: 'U',
        ǜ: 'u',
        ǚ: 'u',
        Ǚ: 'U',
        ǖ: 'u',
        Ǖ: 'U',
        Ű: 'U',
        ű: 'u',
        ũ: 'u',
        Ũ: 'U',
        Ṹ: 'U',
        ṹ: 'u',
        u̧: 'u',
        U̧: 'U',
        Ų: 'U',
        ų: 'u',
        Ū: 'U',
        ū: 'u',
        ȕ: 'u',
        Ȕ: 'U',
        Ȗ: 'U',
        ȗ: 'u',
        ư: 'u',
        Ư: 'U',
        ứ: 'u',
        Ứ: 'U',
        ừ: 'u',
        Ừ: 'U',
        V̆: 'V',
        v̆: 'v',
        v̌: 'v',
        V̌: 'V',
        Ẃ: 'W',
        ẃ: 'w',
        Ẁ: 'W',
        ẁ: 'w',
        ŵ: 'w',
        Ŵ: 'W',
        W̌: 'W',
        w̌: 'w',
        x́: 'x',
        X́: 'X',
        X̆: 'X',
        x̆: 'x',
        x̌: 'x',
        X̌: 'X',
        X̧: 'X',
        x̧: 'x',
        Ý: 'Y',
        ý: 'y',
        Ỳ: 'Y',
        ỳ: 'y',
        y̆: 'y',
        Y̆: 'Y',
        Ŷ: 'Y',
        ŷ: 'y',
        y̌: 'y',
        Y̌: 'Y',
        ÿ: 'y',
        Ÿ: 'Y',
        ź: 'z',
        Ź: 'Z',
        Ž: 'Z',
        ž: 'z',
        Ż: 'Z',
        ż: 'z',
        Z̧: 'Z',
        z̧: 'z',
    };
    /**
     * @param {?} text
     * @return {?}
     */
    function interpolate(text) {
        return '{{\\s*(' + text + ')\\s*}}';
    }
    /**
     * @param {?} blueprint
     * @param {?} map
     * @param {?=} interpolation
     * @return {?}
     */
    function mapReplace(blueprint, map, interpolation) {
        if (typeof blueprint !== 'string')
            return '';
        if (typeof map !== 'object')
            return blueprint;
        /** @type {?} */
        var expression = Object.keys(map).join('|');
        /** @type {?} */
        var mapRegExp = new RegExp(interpolation ? interpolate(expression) : expression, 'g');
        return blueprint.replace(mapRegExp, (/**
         * @param {?} match
         * @return {?}
         */
        function (match) {
            if (interpolation)
                return String(map[match.replace(/\{\{\s*|\s*\}\}/g, '')]);
            return String(map[match]);
        }));
    }
    /**
     * @param {?} text
     * @return {?}
     */
    function normalizeDiacritics(text) {
        return mapReplace(text, CHARMAP);
    }
    /**
     * @param {?} list
     * @return {?}
     */
    function addCommas(list) {
        return list.reduce((/**
         * @param {?} acc
         * @param {?} item
         * @param {?} index
         * @param {?} __3
         * @return {?}
         */
        function (acc, item, index, _a) {
            var length = _a.length;
            return acc +
                (!index
                    ? ''
                    : length < 3
                        ? ' and '
                        : index === length - 1
                            ? ', and '
                            : ', ') +
                item;
        }), '');
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/utils/mappers.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} key
     * @param {?} params
     * @param {?} blueprint
     * @return {?}
     */
    function generateValidationError(key, params, blueprint) {
        return {
            key: key,
            params: params,
            message: mapReplace(blueprint, params, true),
        };
    }
    /** @type {?} */
    var defaultMapErrorsFn = (/**
     * @param {?} errors
     * @return {?}
     */
    function (errors) {
        return errors;
    });

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/utils/rxjs-utils.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @deprecated doesn't work with Ivy, will be removed in v1.0
     * @template T
     * @param {?} component
     * @return {?}
     */
    function takeUntilDestroy(component) {
        /** @type {?} */
        var proto = Object.getPrototypeOf(component);
        /** @type {?} */
        var onDestroy = proto.ngOnDestroy;
        /** @type {?} */
        var destroy$ = new rxjs.Subject();
        proto.ngOnDestroy = (/**
         * @return {?}
         */
        function () {
            onDestroy.apply(this, arguments);
            destroy$.next();
            destroy$.complete();
        });
        return operators.takeUntil(destroy$);
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/utils/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/abstracts/abstract-validation.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var AbstractValidationDirective = /** @class */ (function () {
        function AbstractValidationDirective(injector) {
            this.injector = injector;
            this.config = {
                blueprints: injector.get(VALIDATION_BLUEPRINTS),
                errorTemplate: injector.get(VALIDATION_ERROR_TEMPLATE),
                invalidClasses: injector.get(VALIDATION_INVALID_CLASSES),
                mapErrorsFn: injector.get(VALIDATION_MAP_ERRORS_FN),
                targetSelector: injector.get(VALIDATION_TARGET_SELECTOR),
                validateOnSubmit: injector.get(VALIDATION_VALIDATE_ON_SUBMIT),
            };
            this.elRef = injector.get(core.ElementRef);
        }
        Object.defineProperty(AbstractValidationDirective.prototype, "group", {
            get: /**
             * @return {?}
             */
            function () {
                return ((this.groupRef || ((/** @type {?} */ ({})))).form ||
                    (this.groupName || ((/** @type {?} */ ({})))).control);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbstractValidationDirective.prototype, "parent", {
            get: /**
             * @return {?}
             */
            function () {
                return this.parentRef || { getStream: (/**
                     * @return {?}
                     */
                    function () { return null; }) };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbstractValidationDirective.prototype, "blueprints", {
            get: /**
             * @return {?}
             */
            function () {
                return __assign({}, BLUEPRINTS, (this._blueprints ||
                    this.parent.blueprints ||
                    this.config.blueprints ||
                    {}));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbstractValidationDirective.prototype, "errorTemplate", {
            get: /**
             * @return {?}
             */
            function () {
                return (this._errorTemplate ||
                    this.parent.errorTemplate ||
                    this.config.errorTemplate);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbstractValidationDirective.prototype, "invalidClasses", {
            get: /**
             * @return {?}
             */
            function () {
                return (this._invalidClasses ||
                    this.parent.invalidClasses ||
                    this.config.invalidClasses);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbstractValidationDirective.prototype, "mapErrorsFn", {
            get: /**
             * @return {?}
             */
            function () {
                return (this._mapErrorsFn || this.parent.mapErrorsFn || this.config.mapErrorsFn);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbstractValidationDirective.prototype, "skipValidation", {
            get: /**
             * @return {?}
             */
            function () {
                return (evalPropTruthy(this._skipValidation) ||
                    this.parent.skipValidation ||
                    this.config.skipValidation);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbstractValidationDirective.prototype, "targetSelector", {
            get: /**
             * @return {?}
             */
            function () {
                return (this._targetSelector ||
                    this.parent.targetSelector ||
                    this.config.targetSelector);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbstractValidationDirective.prototype, "validateOnSubmit", {
            get: /**
             * @return {?}
             */
            function () {
                return (evalPropTruthy(this._validateOnSubmit) ||
                    this.parent.validateOnSubmit ||
                    this.config.validateOnSubmit);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} streamName
         * @return {?}
         */
        AbstractValidationDirective.prototype.getStream = /**
         * @param {?} streamName
         * @return {?}
         */
        function (streamName) {
            return rxjs.merge(this[streamName + '$']
                ? ((/** @type {?} */ (this[streamName + '$']))).asObservable()
                : rxjs.NEVER, this.parent.getStream(streamName) || rxjs.NEVER);
        };
        /**
         * @return {?}
         */
        AbstractValidationDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () { };
        AbstractValidationDirective.decorators = [
            { type: core.Directive, args: [{
                        /* tslint:disable-next-line */
                        selector: "abstractValidationDirective"
                    },] }
        ];
        /** @nocollapse */
        AbstractValidationDirective.ctorParameters = function () { return [
            { type: core.Injector }
        ]; };
        AbstractValidationDirective.propDecorators = {
            _blueprints: [{ type: core.Input, args: ['blueprints',] }],
            _errorTemplate: [{ type: core.Input, args: ['errorTemplate',] }],
            _invalidClasses: [{ type: core.Input, args: ['invalidClasses',] }],
            _mapErrorsFn: [{ type: core.Input, args: ['mapErrorsFn',] }],
            _skipValidation: [{ type: core.Input, args: ['skipValidation',] }],
            _targetSelector: [{ type: core.Input, args: ['targetSelector',] }],
            _validateOnSubmit: [{ type: core.Input, args: ['validateOnSubmit',] }]
        };
        return AbstractValidationDirective;
    }());
    if (false) {
        /** @type {?} */
        AbstractValidationDirective.prototype._blueprints;
        /** @type {?} */
        AbstractValidationDirective.prototype._errorTemplate;
        /** @type {?} */
        AbstractValidationDirective.prototype._invalidClasses;
        /** @type {?} */
        AbstractValidationDirective.prototype._mapErrorsFn;
        /** @type {?} */
        AbstractValidationDirective.prototype._skipValidation;
        /** @type {?} */
        AbstractValidationDirective.prototype._targetSelector;
        /** @type {?} */
        AbstractValidationDirective.prototype._validateOnSubmit;
        /** @type {?} */
        AbstractValidationDirective.prototype.config;
        /** @type {?} */
        AbstractValidationDirective.prototype.elRef;
        /** @type {?} */
        AbstractValidationDirective.prototype.groupName;
        /** @type {?} */
        AbstractValidationDirective.prototype.groupRef;
        /** @type {?} */
        AbstractValidationDirective.prototype.parentRef;
        /** @type {?} */
        AbstractValidationDirective.prototype.injector;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/abstracts/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/validation-error.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ValidationErrorComponent = /** @class */ (function () {
        function ValidationErrorComponent() {
            this.trackByFn = (/**
             * @param {?} _
             * @param {?} item
             * @return {?}
             */
            function (_, item) { return item.key; });
        }
        Object.defineProperty(ValidationErrorComponent.prototype, "errors", {
            get: /**
             * @return {?}
             */
            function () {
                return this.validationErrors || [];
            },
            enumerable: true,
            configurable: true
        });
        ValidationErrorComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'validation-error',
                        template: "\n    <div *ngFor=\"let error of errors; trackBy: trackByFn\" class=\"invalid-feedback\">{{ error.message }}</div>\n  ",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        encapsulation: core.ViewEncapsulation.None
                    }] }
        ];
        return ValidationErrorComponent;
    }());
    if (false) {
        /** @type {?} */
        ValidationErrorComponent.prototype.validationErrors;
        /** @type {?} */
        ValidationErrorComponent.prototype.trackByFn;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/components/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/validation-target.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ValidationTargetDirective = /** @class */ (function () {
        function ValidationTargetDirective(vcRef) {
            this.vcRef = vcRef;
        }
        ValidationTargetDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[validationTarget]',
                        exportAs: 'validationTarget',
                    },] }
        ];
        /** @nocollapse */
        ValidationTargetDirective.ctorParameters = function () { return [
            { type: core.ViewContainerRef }
        ]; };
        return ValidationTargetDirective;
    }());
    if (false) {
        /** @type {?} */
        ValidationTargetDirective.prototype.vcRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/validation-container.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ValidationContainerDirective = /** @class */ (function () {
        function ValidationContainerDirective() {
        }
        ValidationContainerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[validationContainer]',
                        exportAs: 'validationContainer',
                    },] }
        ];
        ValidationContainerDirective.propDecorators = {
            targetRef: [{ type: core.ContentChild, args: [ValidationTargetDirective, { static: false },] }]
        };
        return ValidationContainerDirective;
    }());
    if (false) {
        /** @type {?} */
        ValidationContainerDirective.prototype.targetRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/validation-group.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ValidationGroupDirective = /** @class */ (function (_super) {
        __extends(ValidationGroupDirective, _super);
        function ValidationGroupDirective(injector, cdRef, groupName, groupRef, parentRef) {
            var _this = _super.call(this, injector) || this;
            _this.injector = injector;
            _this.cdRef = cdRef;
            _this.groupName = groupName;
            _this.groupRef = groupRef;
            _this.parentRef = parentRef;
            _this.status$ = new rxjs.ReplaySubject(1);
            _this.submit$ = new rxjs.ReplaySubject(1);
            _this.value$ = new rxjs.ReplaySubject(1);
            _this.subs = new rxjs.Subscription();
            return _this;
        }
        /**
         * @private
         * @return {?}
         */
        ValidationGroupDirective.prototype.subscribeToFormSubmit = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            ((/** @type {?} */ (this.elRef.nativeElement))).onsubmit = (/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                if (_this.group.invalid)
                    event.preventDefault();
                _this.submit$.next(_this.group);
                _this.cdRef.markForCheck();
            });
        };
        /**
         * @private
         * @return {?}
         */
        ValidationGroupDirective.prototype.subscribeToStatusChanges = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.subs.add(this.group.statusChanges.subscribe((/**
             * @return {?}
             */
            function () {
                _this.status$.next(_this.group);
                _this.cdRef.markForCheck();
            })));
        };
        /**
         * @private
         * @return {?}
         */
        ValidationGroupDirective.prototype.subscribeToValueChanges = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.subs.add(this.group.valueChanges.subscribe((/**
             * @return {?}
             */
            function () {
                _this.value$.next(_this.group);
                _this.cdRef.markForCheck();
            })));
        };
        /**
         * @return {?}
         */
        ValidationGroupDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            if (!this.parentRef)
                this.subscribeToFormSubmit();
            this.subscribeToStatusChanges();
            this.subscribeToValueChanges();
        };
        /**
         * @return {?}
         */
        ValidationGroupDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.subs.unsubscribe();
        };
        ValidationGroupDirective.decorators = [
            { type: core.Directive, args: [{
                        /* tslint:disable-next-line */
                        selector: '[formGroup],[formGroupName]',
                        exportAs: 'validationGroup',
                    },] }
        ];
        /** @nocollapse */
        ValidationGroupDirective.ctorParameters = function () { return [
            { type: core.Injector },
            { type: core.ChangeDetectorRef },
            { type: forms.FormGroupName, decorators: [{ type: core.Optional }, { type: core.Self }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }, { type: core.Self }] },
            { type: ValidationGroupDirective, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] }
        ]; };
        return ValidationGroupDirective;
    }(AbstractValidationDirective));
    if (false) {
        /** @type {?} */
        ValidationGroupDirective.prototype.status$;
        /** @type {?} */
        ValidationGroupDirective.prototype.submit$;
        /** @type {?} */
        ValidationGroupDirective.prototype.value$;
        /**
         * @type {?}
         * @private
         */
        ValidationGroupDirective.prototype.subs;
        /** @type {?} */
        ValidationGroupDirective.prototype.injector;
        /** @type {?} */
        ValidationGroupDirective.prototype.cdRef;
        /** @type {?} */
        ValidationGroupDirective.prototype.groupName;
        /** @type {?} */
        ValidationGroupDirective.prototype.groupRef;
        /** @type {?} */
        ValidationGroupDirective.prototype.parentRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/validation-style.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ValidationStyleDirective = /** @class */ (function () {
        function ValidationStyleDirective(elRef) {
            this.elRef = elRef;
        }
        ValidationStyleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[validationStyle]',
                        exportAs: 'validationStyle',
                    },] }
        ];
        /** @nocollapse */
        ValidationStyleDirective.ctorParameters = function () { return [
            { type: core.ElementRef }
        ]; };
        return ValidationStyleDirective;
    }());
    if (false) {
        /** @type {?} */
        ValidationStyleDirective.prototype.elRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/validation.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ValidationDirective = /** @class */ (function (_super) {
        __extends(ValidationDirective, _super);
        function ValidationDirective(injector, cdRef, cfRes, control, renderer, vcRef, parentRef, markRef, targetRef, containerRef, formGroupDirective) {
            var _this = _super.call(this, injector) || this;
            _this.injector = injector;
            _this.cdRef = cdRef;
            _this.cfRes = cfRes;
            _this.control = control;
            _this.renderer = renderer;
            _this.vcRef = vcRef;
            _this.parentRef = parentRef;
            _this.markRef = markRef;
            _this.targetRef = targetRef;
            _this.containerRef = containerRef;
            _this.formGroupDirective = formGroupDirective;
            _this.isSubmitted = false;
            _this.subscriptions = new rxjs.Subscription();
            return _this;
        }
        Object.defineProperty(ValidationDirective.prototype, "validation$", {
            get: /**
             * @return {?}
             */
            function () {
                return rxjs.merge(this.parent.getStream('status').pipe(operators.mapTo(null)), this.parent.getStream('value').pipe(operators.mapTo(null)), this.parent.getStream('submit'));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @private
         * @param {?} errors
         * @return {?}
         */
        ValidationDirective.prototype.buildErrors = /**
         * @private
         * @param {?} errors
         * @return {?}
         */
        function (errors) {
            var _this = this;
            return Object.keys(errors || {}).map((/**
             * @param {?} key
             * @return {?}
             */
            function (key) {
                return generateValidationError(key, errors[key], _this.blueprints[key]);
            }));
        };
        /**
         * @private
         * @return {?}
         */
        ValidationDirective.prototype.insertErrorClasses = /**
         * @private
         * @return {?}
         */
        function () {
            this.renderer.addClass(this.markElement, this.invalidClasses);
        };
        /**
         * @private
         * @this {?}
         * @param {?} errors
         * @return {?}
         */
        ValidationDirective.prototype.insertErrors = /**
         * @private
         * @this {?}
         * @param {?} errors
         * @return {?}
         */
        function (errors) {
            /** @type {?} */
            var template = this.errorTemplate;
            /** @type {?} */
            var targetRef = this.containerRef ? this.containerRef.targetRef : this.targetRef;
            /** @type {?} */
            var vcRef = targetRef ? targetRef.vcRef : this.vcRef;
            this.errorRef =
                template instanceof core.TemplateRef
                    ? vcRef.createEmbeddedView(template, { $implicit: errors }, vcRef.length)
                    : vcRef.createComponent(this.cfRes.resolveComponentFactory(template), vcRef.length, this.injector);
            if (this.errorRef instanceof core.ComponentRef && this.errorRef.instance)
                ((/** @type {?} */ (this.errorRef))).instance.validationErrors = errors;
        };
        /**
         * @private
         * @return {?}
         */
        ValidationDirective.prototype.removeErrorClasses = /**
         * @private
         * @return {?}
         */
        function () {
            this.renderer.removeClass(this.markElement, this.invalidClasses);
        };
        /**
         * @private
         * @return {?}
         */
        ValidationDirective.prototype.removeErrors = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.errorRef) {
                this.errorRef.destroy();
                this.errorRef = null;
            }
        };
        /**
         * @private
         * @return {?}
         */
        ValidationDirective.prototype.setMarkElement = /**
         * @private
         * @return {?}
         */
        function () {
            this.markElement =
                (this.markRef
                    ? this.markRef.elRef.nativeElement
                    : this.targetSelector
                        ? this.elRef.nativeElement.closest(this.targetSelector)
                        : null) || this.elRef.nativeElement;
        };
        /**
         * @private
         * @param {?} errors
         * @return {?}
         */
        ValidationDirective.prototype.shouldValidate = /**
         * @private
         * @param {?} errors
         * @return {?}
         */
        function (errors) {
            return errors.length && this.control.dirty && (!this.validateOnSubmit || this.isSubmitted);
        };
        /**
         * @private
         * @return {?}
         */
        ValidationDirective.prototype.subscribeToValidation = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var cached;
            this.subscriptions.add(this.validation$
                .pipe(operators.filter((/**
             * @return {?}
             */
            function () { return !_this.skipValidation; })), operators.tap((/**
             * @param {?} form
             * @return {?}
             */
            function (form) {
                if (form && _this.formGroupDirective.submitted) {
                    _this.control.control.markAsDirty();
                    _this.isSubmitted = true;
                }
            })), operators.map((/**
             * @return {?}
             */
            function () {
                return _this.mapErrorsFn(_this.buildErrors(_this.control.errors), _this.buildErrors((_this.parentRef.group || ((/** @type {?} */ ({})))).errors), _this.control);
            })))
                .subscribe((/**
             * @param {?} errors
             * @return {?}
             */
            function (errors) {
                if (cached === JSON.stringify(errors))
                    return;
                _this.removeErrors();
                if (_this.shouldValidate(errors)) {
                    _this.insertErrors(errors);
                    if (!cached)
                        _this.insertErrorClasses();
                    cached = JSON.stringify(errors);
                }
                else {
                    _this.removeErrorClasses();
                    cached = '';
                }
                _this.cdRef.markForCheck();
            })));
        };
        /**
         * @return {?}
         */
        ValidationDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            this.setMarkElement();
            this.subscribeToValidation();
        };
        /**
         * @return {?}
         */
        ValidationDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            this.subscriptions.unsubscribe();
        };
        ValidationDirective.decorators = [
            { type: core.Directive, args: [{
                        /* tslint:disable-next-line */
                        selector: '[formControl],[formControlName]',
                        exportAs: 'validationDirective',
                    },] }
        ];
        /** @nocollapse */
        ValidationDirective.ctorParameters = function () { return [
            { type: core.Injector },
            { type: core.ChangeDetectorRef },
            { type: core.ComponentFactoryResolver },
            { type: forms.NgControl, decorators: [{ type: core.Self }] },
            { type: core.Renderer2 },
            { type: core.ViewContainerRef },
            { type: ValidationGroupDirective, decorators: [{ type: core.SkipSelf }] },
            { type: ValidationStyleDirective, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: ValidationTargetDirective, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: ValidationContainerDirective, decorators: [{ type: core.Optional }] },
            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] }
        ]; };
        return ValidationDirective;
    }(AbstractValidationDirective));
    if (false) {
        /**
         * @type {?}
         * @private
         */
        ValidationDirective.prototype.errorRef;
        /**
         * @type {?}
         * @private
         */
        ValidationDirective.prototype.markElement;
        /**
         * @type {?}
         * @private
         */
        ValidationDirective.prototype.isSubmitted;
        /**
         * @type {?}
         * @private
         */
        ValidationDirective.prototype.subscriptions;
        /** @type {?} */
        ValidationDirective.prototype.injector;
        /**
         * @type {?}
         * @private
         */
        ValidationDirective.prototype.cdRef;
        /**
         * @type {?}
         * @private
         */
        ValidationDirective.prototype.cfRes;
        /**
         * @type {?}
         * @private
         */
        ValidationDirective.prototype.control;
        /**
         * @type {?}
         * @private
         */
        ValidationDirective.prototype.renderer;
        /**
         * @type {?}
         * @private
         */
        ValidationDirective.prototype.vcRef;
        /** @type {?} */
        ValidationDirective.prototype.parentRef;
        /**
         * @type {?}
         * @private
         */
        ValidationDirective.prototype.markRef;
        /** @type {?} */
        ValidationDirective.prototype.targetRef;
        /**
         * @type {?}
         * @private
         */
        ValidationDirective.prototype.containerRef;
        /**
         * @type {?}
         * @private
         */
        ValidationDirective.prototype.formGroupDirective;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NgxValidateCoreModule = /** @class */ (function () {
        function NgxValidateCoreModule() {
        }
        /**
         * @param {?=} config
         * @return {?}
         */
        NgxValidateCoreModule.forRoot = /**
         * @param {?=} config
         * @return {?}
         */
        function (config) {
            if (config === void 0) { config = (/** @type {?} */ ({})); }
            return {
                ngModule: NgxValidateCoreModule,
                providers: [
                    {
                        provide: VALIDATION_BLUEPRINTS,
                        useValue: config.blueprints || BLUEPRINTS,
                    },
                    {
                        provide: VALIDATION_ERROR_TEMPLATE,
                        useValue: config.errorTemplate || ValidationErrorComponent,
                    },
                    {
                        provide: VALIDATION_INVALID_CLASSES,
                        useValue: config.invalidClasses || 'is-invalid',
                    },
                    {
                        provide: VALIDATION_MAP_ERRORS_FN,
                        useValue: config.mapErrorsFn || defaultMapErrorsFn,
                    },
                    {
                        provide: VALIDATION_TARGET_SELECTOR,
                        useValue: config.targetSelector,
                    },
                    {
                        provide: VALIDATION_VALIDATE_ON_SUBMIT,
                        useValue: config.validateOnSubmit,
                    },
                ],
            };
        };
        NgxValidateCoreModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule, forms.FormsModule, forms.ReactiveFormsModule],
                        exports: [
                            ValidationContainerDirective,
                            ValidationGroupDirective,
                            ValidationStyleDirective,
                            ValidationTargetDirective,
                            ValidationDirective,
                        ],
                        declarations: [
                            ValidationErrorComponent,
                            AbstractValidationDirective,
                            ValidationContainerDirective,
                            ValidationGroupDirective,
                            ValidationStyleDirective,
                            ValidationTargetDirective,
                            ValidationDirective,
                        ],
                        entryComponents: [ValidationErrorComponent],
                    },] }
        ];
        return NgxValidateCoreModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/directives/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/models/validation.model.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Validation;
    (function (Validation) {
        /**
         * @record
         */
        function Blueprints() { }
        Validation.Blueprints = Blueprints;
        /**
         * @record
         */
        function ParamMap() { }
        Validation.ParamMap = ParamMap;
        /**
         * @record
         */
        function Error() { }
        Validation.Error = Error;
        if (false) {
            /** @type {?} */
            Error.prototype.key;
            /** @type {?|undefined} */
            Error.prototype.params;
            /** @type {?|undefined} */
            Error.prototype.message;
        }
    })(Validation || (Validation = {}));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/models/index.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/validators/password-validators.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @param {?} __0
     * @return {?}
     */
    function comparePasswords(_a) {
        var _b = __read(_a, 2), controlName1 = _b[0], controlName2 = _b[1];
        return (/**
         * @param {?} group
         * @return {?}
         */
        function (group) {
            /** @type {?} */
            var password = group.get(controlName1).value;
            /** @type {?} */
            var repeat = group.get(controlName2).value;
            return !password || !repeat || password === repeat
                ? null
                : {
                    passwordMismatch: {
                        fields: [controlName1, controlName2],
                    },
                };
        });
    }
    /**
     * @param {?=} shouldContain
     * @return {?}
     */
    function validatePassword(shouldContain) {
        if (shouldContain === void 0) { shouldContain = ['small', 'capital', 'number', 'special']; }
        return (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            if (!control.value)
                return null;
            /** @type {?} */
            var value = normalizeDiacritics(control.value);
            /** @type {?} */
            var regex = {
                small: /.*[a-z].*/,
                capital: /.*[A-Z].*/,
                number: /.*[0-9].*/,
                special: /.*[^0-9a-zA-Z].*/,
            };
            /** @type {?} */
            var missing = shouldContain.filter((/**
             * @param {?} key
             * @return {?}
             */
            function (key) { return !regex[key].test(value); }));
            return missing.length
                ? {
                    invalidPassword: {
                        missing: missing,
                        description: addCommas(missing.map((/**
                         * @param {?} key
                         * @return {?}
                         */
                        function (key) {
                            return ({
                                small: 'a small letter',
                                capital: 'a capital',
                                number: 'a number',
                                special: 'a special character',
                            }[key]);
                        }))),
                    },
                }
                : null;
        });
    }

    exports.AbstractValidationDirective = AbstractValidationDirective;
    exports.BLUEPRINTS = BLUEPRINTS;
    exports.NgxValidateCoreModule = NgxValidateCoreModule;
    exports.VALIDATION_BLUEPRINTS = VALIDATION_BLUEPRINTS;
    exports.VALIDATION_ERROR_TEMPLATE = VALIDATION_ERROR_TEMPLATE;
    exports.VALIDATION_INVALID_CLASSES = VALIDATION_INVALID_CLASSES;
    exports.VALIDATION_MAP_ERRORS_FN = VALIDATION_MAP_ERRORS_FN;
    exports.VALIDATION_TARGET_SELECTOR = VALIDATION_TARGET_SELECTOR;
    exports.VALIDATION_VALIDATE_ON_SUBMIT = VALIDATION_VALIDATE_ON_SUBMIT;
    exports.ValidationContainerDirective = ValidationContainerDirective;
    exports.ValidationDirective = ValidationDirective;
    exports.ValidationErrorComponent = ValidationErrorComponent;
    exports.ValidationGroupDirective = ValidationGroupDirective;
    exports.ValidationStyleDirective = ValidationStyleDirective;
    exports.ValidationTargetDirective = ValidationTargetDirective;
    exports.addCommas = addCommas;
    exports.comparePasswords = comparePasswords;
    exports.defaultMapErrorsFn = defaultMapErrorsFn;
    exports.evalPropTruthy = evalPropTruthy;
    exports.generateValidationError = generateValidationError;
    exports.interpolate = interpolate;
    exports.mapReplace = mapReplace;
    exports.normalizeDiacritics = normalizeDiacritics;
    exports.takeUntilDestroy = takeUntilDestroy;
    exports.validatePassword = validatePassword;
    exports.ɵa = ValidationContainerDirective;
    exports.ɵb = ValidationTargetDirective;
    exports.ɵc = ValidationGroupDirective;
    exports.ɵd = AbstractValidationDirective;
    exports.ɵe = ValidationStyleDirective;
    exports.ɵf = ValidationDirective;
    exports.ɵg = ValidationErrorComponent;
    exports.ɵh = AbstractValidationDirective;
    exports.ɵi = VALIDATION_BLUEPRINTS;
    exports.ɵj = BLUEPRINTS;
    exports.ɵk = VALIDATION_ERROR_TEMPLATE;
    exports.ɵl = VALIDATION_INVALID_CLASSES;
    exports.ɵm = VALIDATION_MAP_ERRORS_FN;
    exports.ɵn = defaultMapErrorsFn;
    exports.ɵo = VALIDATION_TARGET_SELECTOR;
    exports.ɵp = VALIDATION_VALIDATE_ON_SUBMIT;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-validate-core.umd.js.map
