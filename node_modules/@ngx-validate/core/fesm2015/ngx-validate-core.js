import { InjectionToken, ElementRef, Directive, Injector, Input, Component, ChangeDetectionStrategy, ViewEncapsulation, ViewContainerRef, ContentChild, ChangeDetectorRef, Optional, Self, SkipSelf, TemplateRef, ComponentRef, ComponentFactoryResolver, Renderer2, NgModule } from '@angular/core';
import { Subject, merge, NEVER, ReplaySubject, Subscription } from 'rxjs';
import { takeUntil, mapTo, filter, tap, map } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { FormGroupName, FormGroupDirective, NgControl, FormsModule, ReactiveFormsModule } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/constants/blueprints.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const BLUEPRINTS = {
    email: 'Please enter a valid email address.',
    max: 'Max. value should be {{ max }}. ({{ actual }} entered)',
    maxlength: 'Max. {{ requiredLength }} characters are allowed. (has {{ actualLength }})',
    min: 'Min. value should be {{ min }}. ({{ actual }} entered)',
    minlength: 'Min. {{ requiredLength }} characters are required. (has {{ actualLength }})',
    pattern: 'Invalid pattern. Please review your input.',
    required: 'This field is required.',
    passwordMismatch: 'Passwords do not match.',
    invalidPassword: 'Password should include {{ description }}.',
};

/**
 * @fileoverview added by tsickle
 * Generated from: lib/constants/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/blueprints.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const VALIDATION_BLUEPRINTS = new InjectionToken('validation.blueprints');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/error-template.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const VALIDATION_ERROR_TEMPLATE = new InjectionToken('validation.error.template');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/invalid-classes.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const VALIDATION_INVALID_CLASSES = new InjectionToken('validation.invalid.classes');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/map-errors-fn.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const VALIDATION_MAP_ERRORS_FN = new InjectionToken('validation.map.errors.fn');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/target-selector.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const VALIDATION_TARGET_SELECTOR = new InjectionToken('validation.target.selector');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/validate-on-submit.token.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const VALIDATION_VALIDATE_ON_SUBMIT = new InjectionToken('validation.validate.on.submit');

/**
 * @fileoverview added by tsickle
 * Generated from: lib/tokens/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/common.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} prop
 * @return {?}
 */
function evalPropTruthy(prop) {
    return prop || typeof prop === 'string';
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/string-utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CHARMAP = {
    á: 'a',
    Á: 'A',
    À: 'A',
    à: 'a',
    Ă: 'A',
    ă: 'a',
    Ắ: 'A',
    ắ: 'a',
    ằ: 'a',
    Ằ: 'A',
    Ẵ: 'A',
    ẵ: 'a',
    ẳ: 'a',
    Ẳ: 'A',
    â: 'a',
    Â: 'A',
    ấ: 'a',
    Ấ: 'A',
    ầ: 'a',
    Ầ: 'A',
    ǎ: 'a',
    Ǎ: 'A',
    å: 'a',
    Å: 'A',
    Ǻ: 'A',
    ǻ: 'a',
    ä: 'a',
    Ä: 'A',
    a̋: 'a',
    A̋: 'A',
    Ã: 'A',
    ã: 'a',
    A̧: 'A',
    a̧: 'a',
    Ą: 'A',
    ą: 'a',
    ā: 'a',
    Ā: 'A',
    ȁ: 'a',
    Ȁ: 'A',
    ȃ: 'a',
    Ȃ: 'A',
    Ặ: 'A',
    ặ: 'a',
    æ: 'a',
    Æ: 'A',
    Ǽ: 'A',
    ǽ: 'a',
    b̌: 'b',
    B̌: 'B',
    b̧: 'b',
    B̧: 'B',
    ć: 'c',
    Ć: 'C',
    c̆: 'c',
    C̆: 'C',
    ĉ: 'c',
    Ĉ: 'C',
    č: 'c',
    Č: 'C',
    ċ: 'c',
    Ċ: 'C',
    Ç: 'C',
    ç: 'c',
    Ḉ: 'C',
    ḉ: 'c',
    č̣: 'c',
    Č̣: 'C',
    Ď: 'D',
    ď: 'd',
    ḑ: 'd',
    Ḑ: 'D',
    đ: 'd',
    Đ: 'D',
    Ð: 'D',
    ð: 'd',
    É: 'E',
    é: 'e',
    È: 'E',
    è: 'e',
    Ĕ: 'E',
    ĕ: 'e',
    ê: 'e',
    Ê: 'E',
    Ế: 'E',
    ế: 'e',
    ề: 'e',
    Ề: 'E',
    Ê̌: 'E',
    ê̌: 'e',
    Ě: 'E',
    ě: 'e',
    ë: 'e',
    Ë: 'E',
    e̋: 'e',
    E̋: 'E',
    Ė: 'E',
    ė: 'e',
    Ȩ: 'E',
    ȩ: 'e',
    ḝ: 'e',
    Ḝ: 'E',
    Ę: 'E',
    ę: 'e',
    Ē: 'E',
    ē: 'e',
    Ḗ: 'E',
    ḗ: 'e',
    Ḕ: 'E',
    ḕ: 'e',
    Ȅ: 'E',
    ȅ: 'e',
    Ȇ: 'E',
    ȇ: 'e',
    ɛ̧: 'e',
    Ɛ̧: 'E',
    f̌: 'f',
    F̌: 'F',
    ƒ: 'f',
    ǵ: 'g',
    Ǵ: 'G',
    ğ: 'g',
    Ğ: 'G',
    Ĝ: 'G',
    ĝ: 'g',
    ǧ: 'g',
    Ǧ: 'G',
    Ġ: 'G',
    ġ: 'g',
    ģ: 'g',
    Ģ: 'G',
    Ĥ: 'H',
    ĥ: 'h',
    ȟ: 'h',
    Ȟ: 'H',
    ḩ: 'h',
    Ḩ: 'H',
    ħ: 'h',
    Ħ: 'H',
    ḫ: 'h',
    Ḫ: 'H',
    í: 'i',
    Í: 'I',
    Ì: 'I',
    ì: 'i',
    Ĭ: 'I',
    ĭ: 'i',
    Î: 'I',
    î: 'i',
    ǐ: 'i',
    Ǐ: 'I',
    ï: 'i',
    Ï: 'I',
    ḯ: 'i',
    Ḯ: 'I',
    I̋: 'I',
    i̋: 'i',
    ĩ: 'i',
    Ĩ: 'I',
    İ: 'I',
    I̧: 'I',
    i̧: 'i',
    Į: 'I',
    į: 'i',
    ī: 'i',
    Ī: 'I',
    ȉ: 'i',
    Ȉ: 'I',
    ȋ: 'i',
    Ȋ: 'I',
    ĳ: 'i',
    Ĳ: 'I',
    ı: 'i',
    Ɨ̧: 'I',
    ɨ̧: 'i',
    ĵ: 'j',
    Ĵ: 'J',
    ǰ: 'j',
    J̌: 'J',
    Ḱ: 'K',
    ḱ: 'k',
    k̆: 'k',
    K̆: 'K',
    ǩ: 'k',
    Ǩ: 'K',
    ķ: 'k',
    Ķ: 'K',
    Ĺ: 'L',
    ĺ: 'l',
    Ľ: 'L',
    ľ: 'l',
    ļ: 'l',
    Ļ: 'L',
    ł: 'l',
    Ł: 'l',
    Ŀ: 'L',
    ŀ: 'l',
    Ḿ: 'M',
    ḿ: 'm',
    m̆: 'm',
    M̆: 'M',
    m̌: 'm',
    M̌: 'M',
    M̧: 'M',
    m̧: 'm',
    Ń: 'N',
    ń: 'n',
    Ǹ: 'N',
    ǹ: 'n',
    n̆: 'n',
    N̆: 'N',
    Ň: 'N',
    ň: 'n',
    ñ: 'n',
    Ñ: 'N',
    Ņ: 'N',
    ņ: 'n',
    ó: 'o',
    Ó: 'O',
    Ò: 'O',
    ò: 'o',
    Ŏ: 'O',
    ŏ: 'o',
    Ô: 'O',
    ô: 'o',
    ố: 'o',
    Ố: 'O',
    ồ: 'o',
    Ồ: 'O',
    Ǒ: 'O',
    ǒ: 'o',
    Ö: 'O',
    ö: 'o',
    ő: 'o',
    Ő: 'O',
    Õ: 'O',
    õ: 'o',
    ṍ: 'o',
    Ṍ: 'O',
    Ø: 'O',
    ø: 'o',
    Ǿ: 'O',
    ǿ: 'o',
    o̧: 'o',
    O̧: 'O',
    Ō: 'O',
    ō: 'o',
    ṓ: 'o',
    Ṓ: 'O',
    ṑ: 'o',
    Ṑ: 'O',
    ȍ: 'o',
    Ȍ: 'O',
    ȏ: 'o',
    Ȏ: 'O',
    ơ: 'o',
    Ơ: 'O',
    œ: 'o',
    Œ: 'O',
    ṕ: 'p',
    Ṕ: 'P',
    p̆: 'p',
    P̆: 'P',
    P̌: 'P',
    p̌: 'p',
    Q̌: 'Q',
    q̌: 'q',
    Q̧: 'Q',
    q̧: 'q',
    ŕ: 'r',
    Ŕ: 'R',
    r̆: 'r',
    R̆: 'R',
    Ř: 'R',
    ř: 'r',
    ŗ: 'r',
    Ŗ: 'R',
    Ř̩: 'R',
    ř̩: 'r',
    ȑ: 'r',
    Ȑ: 'R',
    Ȓ: 'R',
    ȓ: 'r',
    Ś: 'S',
    ś: 's',
    Ṥ: 'S',
    ṥ: 's',
    Ŝ: 'S',
    ŝ: 's',
    š: 's',
    Š: 'S',
    Ṧ: 'S',
    ṧ: 's',
    ş: 's',
    Ş: 'S',
    ș: 's',
    Ș: 'S',
    ſ: 's',
    T̆: 'T',
    t̆: 't',
    Ť: 'T',
    ť: 't',
    ţ: 't',
    Ţ: 'T',
    Ț: 'T',
    ț: 't',
    ŧ: 't',
    Ŧ: 'T',
    Ú: 'U',
    ú: 'u',
    ù: 'u',
    Ù: 'U',
    ŭ: 'u',
    Ŭ: 'U',
    Û: 'U',
    û: 'u',
    ǔ: 'u',
    Ǔ: 'U',
    Ů: 'U',
    ů: 'u',
    ü: 'u',
    Ü: 'U',
    ǘ: 'u',
    Ǘ: 'U',
    Ǜ: 'U',
    ǜ: 'u',
    ǚ: 'u',
    Ǚ: 'U',
    ǖ: 'u',
    Ǖ: 'U',
    Ű: 'U',
    ű: 'u',
    ũ: 'u',
    Ũ: 'U',
    Ṹ: 'U',
    ṹ: 'u',
    u̧: 'u',
    U̧: 'U',
    Ų: 'U',
    ų: 'u',
    Ū: 'U',
    ū: 'u',
    ȕ: 'u',
    Ȕ: 'U',
    Ȗ: 'U',
    ȗ: 'u',
    ư: 'u',
    Ư: 'U',
    ứ: 'u',
    Ứ: 'U',
    ừ: 'u',
    Ừ: 'U',
    V̆: 'V',
    v̆: 'v',
    v̌: 'v',
    V̌: 'V',
    Ẃ: 'W',
    ẃ: 'w',
    Ẁ: 'W',
    ẁ: 'w',
    ŵ: 'w',
    Ŵ: 'W',
    W̌: 'W',
    w̌: 'w',
    x́: 'x',
    X́: 'X',
    X̆: 'X',
    x̆: 'x',
    x̌: 'x',
    X̌: 'X',
    X̧: 'X',
    x̧: 'x',
    Ý: 'Y',
    ý: 'y',
    Ỳ: 'Y',
    ỳ: 'y',
    y̆: 'y',
    Y̆: 'Y',
    Ŷ: 'Y',
    ŷ: 'y',
    y̌: 'y',
    Y̌: 'Y',
    ÿ: 'y',
    Ÿ: 'Y',
    ź: 'z',
    Ź: 'Z',
    Ž: 'Z',
    ž: 'z',
    Ż: 'Z',
    ż: 'z',
    Z̧: 'Z',
    z̧: 'z',
};
/**
 * @param {?} text
 * @return {?}
 */
function interpolate(text) {
    return '{{\\s*(' + text + ')\\s*}}';
}
/**
 * @param {?} blueprint
 * @param {?} map
 * @param {?=} interpolation
 * @return {?}
 */
function mapReplace(blueprint, map, interpolation) {
    if (typeof blueprint !== 'string')
        return '';
    if (typeof map !== 'object')
        return blueprint;
    /** @type {?} */
    const expression = Object.keys(map).join('|');
    /** @type {?} */
    const mapRegExp = new RegExp(interpolation ? interpolate(expression) : expression, 'g');
    return blueprint.replace(mapRegExp, (/**
     * @param {?} match
     * @return {?}
     */
    match => {
        if (interpolation)
            return String(map[match.replace(/\{\{\s*|\s*\}\}/g, '')]);
        return String(map[match]);
    }));
}
/**
 * @param {?} text
 * @return {?}
 */
function normalizeDiacritics(text) {
    return mapReplace(text, CHARMAP);
}
/**
 * @param {?} list
 * @return {?}
 */
function addCommas(list) {
    return list.reduce((/**
     * @param {?} acc
     * @param {?} item
     * @param {?} index
     * @param {?} __3
     * @return {?}
     */
    (acc, item, index, { length }) => acc +
        (!index
            ? ''
            : length < 3
                ? ' and '
                : index === length - 1
                    ? ', and '
                    : ', ') +
        item), '');
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/mappers.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} key
 * @param {?} params
 * @param {?} blueprint
 * @return {?}
 */
function generateValidationError(key, params, blueprint) {
    return {
        key,
        params,
        message: mapReplace(blueprint, params, true),
    };
}
/** @type {?} */
const defaultMapErrorsFn = (/**
 * @param {?} errors
 * @return {?}
 */
(errors) => {
    return errors;
});

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/rxjs-utils.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @deprecated doesn't work with Ivy, will be removed in v1.0
 * @template T
 * @param {?} component
 * @return {?}
 */
function takeUntilDestroy(component) {
    /** @type {?} */
    const proto = Object.getPrototypeOf(component);
    /** @type {?} */
    const onDestroy = proto.ngOnDestroy;
    /** @type {?} */
    const destroy$ = new Subject();
    proto.ngOnDestroy = (/**
     * @return {?}
     */
    function () {
        onDestroy.apply(this, arguments);
        destroy$.next();
        destroy$.complete();
    });
    return takeUntil(destroy$);
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/utils/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/abstracts/abstract-validation.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AbstractValidationDirective {
    /**
     * @param {?} injector
     */
    constructor(injector) {
        this.injector = injector;
        this.config = {
            blueprints: injector.get(VALIDATION_BLUEPRINTS),
            errorTemplate: injector.get(VALIDATION_ERROR_TEMPLATE),
            invalidClasses: injector.get(VALIDATION_INVALID_CLASSES),
            mapErrorsFn: injector.get(VALIDATION_MAP_ERRORS_FN),
            targetSelector: injector.get(VALIDATION_TARGET_SELECTOR),
            validateOnSubmit: injector.get(VALIDATION_VALIDATE_ON_SUBMIT),
        };
        this.elRef = injector.get(ElementRef);
    }
    /**
     * @return {?}
     */
    get group() {
        return ((this.groupRef || ((/** @type {?} */ ({})))).form ||
            (this.groupName || ((/** @type {?} */ ({})))).control);
    }
    /**
     * @return {?}
     */
    get parent() {
        return this.parentRef || { getStream: (/**
             * @return {?}
             */
            () => null) };
    }
    /**
     * @return {?}
     */
    get blueprints() {
        return Object.assign({}, BLUEPRINTS, (this._blueprints ||
            this.parent.blueprints ||
            this.config.blueprints ||
            {}));
    }
    /**
     * @return {?}
     */
    get errorTemplate() {
        return (this._errorTemplate ||
            this.parent.errorTemplate ||
            this.config.errorTemplate);
    }
    /**
     * @return {?}
     */
    get invalidClasses() {
        return (this._invalidClasses ||
            this.parent.invalidClasses ||
            this.config.invalidClasses);
    }
    /**
     * @return {?}
     */
    get mapErrorsFn() {
        return (this._mapErrorsFn || this.parent.mapErrorsFn || this.config.mapErrorsFn);
    }
    /**
     * @return {?}
     */
    get skipValidation() {
        return (evalPropTruthy(this._skipValidation) ||
            this.parent.skipValidation ||
            this.config.skipValidation);
    }
    /**
     * @return {?}
     */
    get targetSelector() {
        return (this._targetSelector ||
            this.parent.targetSelector ||
            this.config.targetSelector);
    }
    /**
     * @return {?}
     */
    get validateOnSubmit() {
        return (evalPropTruthy(this._validateOnSubmit) ||
            this.parent.validateOnSubmit ||
            this.config.validateOnSubmit);
    }
    /**
     * @param {?} streamName
     * @return {?}
     */
    getStream(streamName) {
        return merge(this[streamName + '$']
            ? ((/** @type {?} */ (this[streamName + '$']))).asObservable()
            : NEVER, this.parent.getStream(streamName) || NEVER);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() { }
}
AbstractValidationDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line */
                selector: "abstractValidationDirective"
            },] }
];
/** @nocollapse */
AbstractValidationDirective.ctorParameters = () => [
    { type: Injector }
];
AbstractValidationDirective.propDecorators = {
    _blueprints: [{ type: Input, args: ['blueprints',] }],
    _errorTemplate: [{ type: Input, args: ['errorTemplate',] }],
    _invalidClasses: [{ type: Input, args: ['invalidClasses',] }],
    _mapErrorsFn: [{ type: Input, args: ['mapErrorsFn',] }],
    _skipValidation: [{ type: Input, args: ['skipValidation',] }],
    _targetSelector: [{ type: Input, args: ['targetSelector',] }],
    _validateOnSubmit: [{ type: Input, args: ['validateOnSubmit',] }]
};
if (false) {
    /** @type {?} */
    AbstractValidationDirective.prototype._blueprints;
    /** @type {?} */
    AbstractValidationDirective.prototype._errorTemplate;
    /** @type {?} */
    AbstractValidationDirective.prototype._invalidClasses;
    /** @type {?} */
    AbstractValidationDirective.prototype._mapErrorsFn;
    /** @type {?} */
    AbstractValidationDirective.prototype._skipValidation;
    /** @type {?} */
    AbstractValidationDirective.prototype._targetSelector;
    /** @type {?} */
    AbstractValidationDirective.prototype._validateOnSubmit;
    /** @type {?} */
    AbstractValidationDirective.prototype.config;
    /** @type {?} */
    AbstractValidationDirective.prototype.elRef;
    /** @type {?} */
    AbstractValidationDirective.prototype.groupName;
    /** @type {?} */
    AbstractValidationDirective.prototype.groupRef;
    /** @type {?} */
    AbstractValidationDirective.prototype.parentRef;
    /** @type {?} */
    AbstractValidationDirective.prototype.injector;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/abstracts/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/validation-error.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidationErrorComponent {
    constructor() {
        this.trackByFn = (/**
         * @param {?} _
         * @param {?} item
         * @return {?}
         */
        (_, item) => item.key);
    }
    /**
     * @return {?}
     */
    get errors() {
        return this.validationErrors || [];
    }
}
ValidationErrorComponent.decorators = [
    { type: Component, args: [{
                selector: 'validation-error',
                template: `
    <div *ngFor="let error of errors; trackBy: trackByFn" class="invalid-feedback">{{ error.message }}</div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None
            }] }
];
if (false) {
    /** @type {?} */
    ValidationErrorComponent.prototype.validationErrors;
    /** @type {?} */
    ValidationErrorComponent.prototype.trackByFn;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/components/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/validation-target.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidationTargetDirective {
    /**
     * @param {?} vcRef
     */
    constructor(vcRef) {
        this.vcRef = vcRef;
    }
}
ValidationTargetDirective.decorators = [
    { type: Directive, args: [{
                selector: '[validationTarget]',
                exportAs: 'validationTarget',
            },] }
];
/** @nocollapse */
ValidationTargetDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
if (false) {
    /** @type {?} */
    ValidationTargetDirective.prototype.vcRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/validation-container.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidationContainerDirective {
}
ValidationContainerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[validationContainer]',
                exportAs: 'validationContainer',
            },] }
];
ValidationContainerDirective.propDecorators = {
    targetRef: [{ type: ContentChild, args: [ValidationTargetDirective, { static: false },] }]
};
if (false) {
    /** @type {?} */
    ValidationContainerDirective.prototype.targetRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/validation-group.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidationGroupDirective extends AbstractValidationDirective {
    /**
     * @param {?} injector
     * @param {?} cdRef
     * @param {?} groupName
     * @param {?} groupRef
     * @param {?} parentRef
     */
    constructor(injector, cdRef, groupName, groupRef, parentRef) {
        super(injector);
        this.injector = injector;
        this.cdRef = cdRef;
        this.groupName = groupName;
        this.groupRef = groupRef;
        this.parentRef = parentRef;
        this.status$ = new ReplaySubject(1);
        this.submit$ = new ReplaySubject(1);
        this.value$ = new ReplaySubject(1);
        this.subs = new Subscription();
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToFormSubmit() {
        ((/** @type {?} */ (this.elRef.nativeElement))).onsubmit = (/**
         * @param {?} event
         * @return {?}
         */
        event => {
            if (this.group.invalid)
                event.preventDefault();
            this.submit$.next(this.group);
            this.cdRef.markForCheck();
        });
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToStatusChanges() {
        this.subs.add(this.group.statusChanges.subscribe((/**
         * @return {?}
         */
        () => {
            this.status$.next(this.group);
            this.cdRef.markForCheck();
        })));
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToValueChanges() {
        this.subs.add(this.group.valueChanges.subscribe((/**
         * @return {?}
         */
        () => {
            this.value$.next(this.group);
            this.cdRef.markForCheck();
        })));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.parentRef)
            this.subscribeToFormSubmit();
        this.subscribeToStatusChanges();
        this.subscribeToValueChanges();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
}
ValidationGroupDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line */
                selector: '[formGroup],[formGroupName]',
                exportAs: 'validationGroup',
            },] }
];
/** @nocollapse */
ValidationGroupDirective.ctorParameters = () => [
    { type: Injector },
    { type: ChangeDetectorRef },
    { type: FormGroupName, decorators: [{ type: Optional }, { type: Self }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }, { type: Self }] },
    { type: ValidationGroupDirective, decorators: [{ type: Optional }, { type: SkipSelf }] }
];
if (false) {
    /** @type {?} */
    ValidationGroupDirective.prototype.status$;
    /** @type {?} */
    ValidationGroupDirective.prototype.submit$;
    /** @type {?} */
    ValidationGroupDirective.prototype.value$;
    /**
     * @type {?}
     * @private
     */
    ValidationGroupDirective.prototype.subs;
    /** @type {?} */
    ValidationGroupDirective.prototype.injector;
    /** @type {?} */
    ValidationGroupDirective.prototype.cdRef;
    /** @type {?} */
    ValidationGroupDirective.prototype.groupName;
    /** @type {?} */
    ValidationGroupDirective.prototype.groupRef;
    /** @type {?} */
    ValidationGroupDirective.prototype.parentRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/validation-style.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidationStyleDirective {
    /**
     * @param {?} elRef
     */
    constructor(elRef) {
        this.elRef = elRef;
    }
}
ValidationStyleDirective.decorators = [
    { type: Directive, args: [{
                selector: '[validationStyle]',
                exportAs: 'validationStyle',
            },] }
];
/** @nocollapse */
ValidationStyleDirective.ctorParameters = () => [
    { type: ElementRef }
];
if (false) {
    /** @type {?} */
    ValidationStyleDirective.prototype.elRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/validation.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ValidationDirective extends AbstractValidationDirective {
    /**
     * @param {?} injector
     * @param {?} cdRef
     * @param {?} cfRes
     * @param {?} control
     * @param {?} renderer
     * @param {?} vcRef
     * @param {?} parentRef
     * @param {?} markRef
     * @param {?} targetRef
     * @param {?} containerRef
     * @param {?} formGroupDirective
     */
    constructor(injector, cdRef, cfRes, control, renderer, vcRef, parentRef, markRef, targetRef, containerRef, formGroupDirective) {
        super(injector);
        this.injector = injector;
        this.cdRef = cdRef;
        this.cfRes = cfRes;
        this.control = control;
        this.renderer = renderer;
        this.vcRef = vcRef;
        this.parentRef = parentRef;
        this.markRef = markRef;
        this.targetRef = targetRef;
        this.containerRef = containerRef;
        this.formGroupDirective = formGroupDirective;
        this.isSubmitted = false;
        this.subscriptions = new Subscription();
    }
    /**
     * @return {?}
     */
    get validation$() {
        return merge(this.parent.getStream('status').pipe(mapTo(null)), this.parent.getStream('value').pipe(mapTo(null)), this.parent.getStream('submit'));
    }
    /**
     * @private
     * @param {?} errors
     * @return {?}
     */
    buildErrors(errors) {
        return Object.keys(errors || {}).map((/**
         * @param {?} key
         * @return {?}
         */
        key => generateValidationError(key, errors[key], this.blueprints[key])));
    }
    /**
     * @private
     * @return {?}
     */
    insertErrorClasses() {
        this.renderer.addClass(this.markElement, this.invalidClasses);
    }
    /**
     * @private
     * @this {?}
     * @param {?} errors
     * @return {?}
     */
    insertErrors(errors) {
        /** @type {?} */
        const template = this.errorTemplate;
        /** @type {?} */
        const targetRef = this.containerRef ? this.containerRef.targetRef : this.targetRef;
        /** @type {?} */
        const vcRef = targetRef ? targetRef.vcRef : this.vcRef;
        this.errorRef =
            template instanceof TemplateRef
                ? vcRef.createEmbeddedView(template, { $implicit: errors }, vcRef.length)
                : vcRef.createComponent(this.cfRes.resolveComponentFactory(template), vcRef.length, this.injector);
        if (this.errorRef instanceof ComponentRef && this.errorRef.instance)
            ((/** @type {?} */ (this.errorRef))).instance.validationErrors = errors;
    }
    /**
     * @private
     * @return {?}
     */
    removeErrorClasses() {
        this.renderer.removeClass(this.markElement, this.invalidClasses);
    }
    /**
     * @private
     * @return {?}
     */
    removeErrors() {
        if (this.errorRef) {
            this.errorRef.destroy();
            this.errorRef = null;
        }
    }
    /**
     * @private
     * @return {?}
     */
    setMarkElement() {
        this.markElement =
            (this.markRef
                ? this.markRef.elRef.nativeElement
                : this.targetSelector
                    ? this.elRef.nativeElement.closest(this.targetSelector)
                    : null) || this.elRef.nativeElement;
    }
    /**
     * @private
     * @param {?} errors
     * @return {?}
     */
    shouldValidate(errors) {
        return errors.length && this.control.dirty && (!this.validateOnSubmit || this.isSubmitted);
    }
    /**
     * @private
     * @return {?}
     */
    subscribeToValidation() {
        /** @type {?} */
        let cached;
        this.subscriptions.add(this.validation$
            .pipe(filter((/**
         * @return {?}
         */
        () => !this.skipValidation)), tap((/**
         * @param {?} form
         * @return {?}
         */
        form => {
            if (form && this.formGroupDirective.submitted) {
                this.control.control.markAsDirty();
                this.isSubmitted = true;
            }
        })), map((/**
         * @return {?}
         */
        () => this.mapErrorsFn(this.buildErrors(this.control.errors), this.buildErrors((this.parentRef.group || ((/** @type {?} */ ({})))).errors), this.control))))
            .subscribe((/**
         * @param {?} errors
         * @return {?}
         */
        errors => {
            if (cached === JSON.stringify(errors))
                return;
            this.removeErrors();
            if (this.shouldValidate(errors)) {
                this.insertErrors(errors);
                if (!cached)
                    this.insertErrorClasses();
                cached = JSON.stringify(errors);
            }
            else {
                this.removeErrorClasses();
                cached = '';
            }
            this.cdRef.markForCheck();
        })));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.setMarkElement();
        this.subscribeToValidation();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
ValidationDirective.decorators = [
    { type: Directive, args: [{
                /* tslint:disable-next-line */
                selector: '[formControl],[formControlName]',
                exportAs: 'validationDirective',
            },] }
];
/** @nocollapse */
ValidationDirective.ctorParameters = () => [
    { type: Injector },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: NgControl, decorators: [{ type: Self }] },
    { type: Renderer2 },
    { type: ViewContainerRef },
    { type: ValidationGroupDirective, decorators: [{ type: SkipSelf }] },
    { type: ValidationStyleDirective, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: ValidationTargetDirective, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: ValidationContainerDirective, decorators: [{ type: Optional }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.errorRef;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.markElement;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.isSubmitted;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.subscriptions;
    /** @type {?} */
    ValidationDirective.prototype.injector;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.cdRef;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.cfRes;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.control;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.vcRef;
    /** @type {?} */
    ValidationDirective.prototype.parentRef;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.markRef;
    /** @type {?} */
    ValidationDirective.prototype.targetRef;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.containerRef;
    /**
     * @type {?}
     * @private
     */
    ValidationDirective.prototype.formGroupDirective;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/core.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxValidateCoreModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config = (/** @type {?} */ ({}))) {
        return {
            ngModule: NgxValidateCoreModule,
            providers: [
                {
                    provide: VALIDATION_BLUEPRINTS,
                    useValue: config.blueprints || BLUEPRINTS,
                },
                {
                    provide: VALIDATION_ERROR_TEMPLATE,
                    useValue: config.errorTemplate || ValidationErrorComponent,
                },
                {
                    provide: VALIDATION_INVALID_CLASSES,
                    useValue: config.invalidClasses || 'is-invalid',
                },
                {
                    provide: VALIDATION_MAP_ERRORS_FN,
                    useValue: config.mapErrorsFn || defaultMapErrorsFn,
                },
                {
                    provide: VALIDATION_TARGET_SELECTOR,
                    useValue: config.targetSelector,
                },
                {
                    provide: VALIDATION_VALIDATE_ON_SUBMIT,
                    useValue: config.validateOnSubmit,
                },
            ],
        };
    }
}
NgxValidateCoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ReactiveFormsModule],
                exports: [
                    ValidationContainerDirective,
                    ValidationGroupDirective,
                    ValidationStyleDirective,
                    ValidationTargetDirective,
                    ValidationDirective,
                ],
                declarations: [
                    ValidationErrorComponent,
                    AbstractValidationDirective,
                    ValidationContainerDirective,
                    ValidationGroupDirective,
                    ValidationStyleDirective,
                    ValidationTargetDirective,
                    ValidationDirective,
                ],
                entryComponents: [ValidationErrorComponent],
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/directives/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/validation.model.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Validation;
(function (Validation) {
    /**
     * @record
     */
    function Blueprints() { }
    Validation.Blueprints = Blueprints;
    /**
     * @record
     */
    function ParamMap() { }
    Validation.ParamMap = ParamMap;
    /**
     * @record
     */
    function Error() { }
    Validation.Error = Error;
    if (false) {
        /** @type {?} */
        Error.prototype.key;
        /** @type {?|undefined} */
        Error.prototype.params;
        /** @type {?|undefined} */
        Error.prototype.message;
    }
})(Validation || (Validation = {}));

/**
 * @fileoverview added by tsickle
 * Generated from: lib/models/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: lib/validators/password-validators.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} __0
 * @return {?}
 */
function comparePasswords([controlName1, controlName2]) {
    return (/**
     * @param {?} group
     * @return {?}
     */
    (group) => {
        /** @type {?} */
        const password = group.get(controlName1).value;
        /** @type {?} */
        const repeat = group.get(controlName2).value;
        return !password || !repeat || password === repeat
            ? null
            : {
                passwordMismatch: {
                    fields: [controlName1, controlName2],
                },
            };
    });
}
/**
 * @param {?=} shouldContain
 * @return {?}
 */
function validatePassword(shouldContain = ['small', 'capital', 'number', 'special']) {
    return (/**
     * @param {?} control
     * @return {?}
     */
    (control) => {
        if (!control.value)
            return null;
        /** @type {?} */
        const value = normalizeDiacritics(control.value);
        /** @type {?} */
        const regex = {
            small: /.*[a-z].*/,
            capital: /.*[A-Z].*/,
            number: /.*[0-9].*/,
            special: /.*[^0-9a-zA-Z].*/,
        };
        /** @type {?} */
        const missing = shouldContain.filter((/**
         * @param {?} key
         * @return {?}
         */
        key => !regex[key].test(value)));
        return missing.length
            ? {
                invalidPassword: {
                    missing,
                    description: addCommas(missing.map((/**
                     * @param {?} key
                     * @return {?}
                     */
                    key => ({
                        small: 'a small letter',
                        capital: 'a capital',
                        number: 'a number',
                        special: 'a special character',
                    }[key])))),
                },
            }
            : null;
    });
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/validators/index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-validate-core.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AbstractValidationDirective, BLUEPRINTS, NgxValidateCoreModule, VALIDATION_BLUEPRINTS, VALIDATION_ERROR_TEMPLATE, VALIDATION_INVALID_CLASSES, VALIDATION_MAP_ERRORS_FN, VALIDATION_TARGET_SELECTOR, VALIDATION_VALIDATE_ON_SUBMIT, ValidationContainerDirective, ValidationDirective, ValidationErrorComponent, ValidationGroupDirective, ValidationStyleDirective, ValidationTargetDirective, addCommas, comparePasswords, defaultMapErrorsFn, evalPropTruthy, generateValidationError, interpolate, mapReplace, normalizeDiacritics, takeUntilDestroy, validatePassword, ValidationContainerDirective as ɵa, ValidationTargetDirective as ɵb, ValidationGroupDirective as ɵc, AbstractValidationDirective as ɵd, ValidationStyleDirective as ɵe, ValidationDirective as ɵf, ValidationErrorComponent as ɵg, AbstractValidationDirective as ɵh, VALIDATION_BLUEPRINTS as ɵi, BLUEPRINTS as ɵj, VALIDATION_ERROR_TEMPLATE as ɵk, VALIDATION_INVALID_CLASSES as ɵl, VALIDATION_MAP_ERRORS_FN as ɵm, defaultMapErrorsFn as ɵn, VALIDATION_TARGET_SELECTOR as ɵo, VALIDATION_VALIDATE_ON_SUBMIT as ɵp };
//# sourceMappingURL=ngx-validate-core.js.map
